{"ast":null,"code":"// copied from signal-exit\n\n// This is not the set of all possible signals.\n//\n// It IS, however, the set of all signals that trigger\n// an exit on either Linux or BSD systems.  Linux is a\n// superset of the signal names supported on BSD, and\n// the unknown signals just fail to register, so we can\n// catch that easily enough.\n//\n// Don't bother with SIGKILL.  It's uncatchable, which\n// means that we can't fire any callbacks anyway.\n//\n// If a user does happen to register a handler on a non-\n// fatal signal like SIGWINCH or something, and then\n// exit, it'll end up firing `process.emit('exit')`, so\n// the handler will be fired anyway.\n//\n// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n// artificially, inherently leave the process in a\n// state from which it is not safe to try and enter JS\n// listeners.\n\nconst platform = global.__ARBORIST_FAKE_PLATFORM__ || process.platform;\nmodule.exports = ['SIGABRT', 'SIGALRM', 'SIGHUP', 'SIGINT', 'SIGTERM'];\nif (platform !== 'win32') {\n  module.exports.push('SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT'\n  // should detect profiler and enable/disable accordingly.\n  // see #21\n  // 'SIGPROF'\n  );\n}\nif (platform === 'linux') {\n  module.exports.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT', 'SIGUNUSED');\n}","map":{"version":3,"names":["platform","global","__ARBORIST_FAKE_PLATFORM__","process","module","exports","push"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/signals.js"],"sourcesContent":["// copied from signal-exit\n\n// This is not the set of all possible signals.\n//\n// It IS, however, the set of all signals that trigger\n// an exit on either Linux or BSD systems.  Linux is a\n// superset of the signal names supported on BSD, and\n// the unknown signals just fail to register, so we can\n// catch that easily enough.\n//\n// Don't bother with SIGKILL.  It's uncatchable, which\n// means that we can't fire any callbacks anyway.\n//\n// If a user does happen to register a handler on a non-\n// fatal signal like SIGWINCH or something, and then\n// exit, it'll end up firing `process.emit('exit')`, so\n// the handler will be fired anyway.\n//\n// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n// artificially, inherently leave the process in a\n// state from which it is not safe to try and enter JS\n// listeners.\n\nconst platform = global.__ARBORIST_FAKE_PLATFORM__ || process.platform\n\nmodule.exports = [\n  'SIGABRT',\n  'SIGALRM',\n  'SIGHUP',\n  'SIGINT',\n  'SIGTERM',\n]\n\nif (platform !== 'win32') {\n  module.exports.push(\n    'SIGVTALRM',\n    'SIGXCPU',\n    'SIGXFSZ',\n    'SIGUSR2',\n    'SIGTRAP',\n    'SIGSYS',\n    'SIGQUIT',\n    'SIGIOT'\n    // should detect profiler and enable/disable accordingly.\n    // see #21\n    // 'SIGPROF'\n  )\n}\n\nif (platform === 'linux') {\n  module.exports.push(\n    'SIGIO',\n    'SIGPOLL',\n    'SIGPWR',\n    'SIGSTKFLT',\n    'SIGUNUSED'\n  )\n}\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,MAAM,CAACC,0BAA0B,IAAIC,OAAO,CAACH,QAAQ;AAEtEI,MAAM,CAACC,OAAO,GAAG,CACf,SAAS,EACT,SAAS,EACT,QAAQ,EACR,QAAQ,EACR,SAAS,CACV;AAED,IAAIL,QAAQ,KAAK,OAAO,EAAE;EACxBI,MAAM,CAACC,OAAO,CAACC,IAAI,CACjB,WAAW,EACX,SAAS,EACT,SAAS,EACT,SAAS,EACT,SAAS,EACT,QAAQ,EACR,SAAS,EACT;EACA;EACA;EACA;EACF,CAAC;AACH;AAEA,IAAIN,QAAQ,KAAK,OAAO,EAAE;EACxBI,MAAM,CAACC,OAAO,CAACC,IAAI,CACjB,OAAO,EACP,SAAS,EACT,QAAQ,EACR,WAAW,EACX,WACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}