{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\nconst os = require('os');\nconst tar = require('tar');\nconst path = require('path');\nconst crypto = require('crypto');\nconst log = require('npmlog');\nconst semver = require('semver');\nconst request = require('request');\nconst processRelease = require('./process-release');\nconst win = process.platform === 'win32';\nconst getProxyFromURI = require('./proxy');\nfunction install(fs, gyp, argv, callback) {\n  var release = processRelease(argv, gyp, process.version, process.release);\n\n  // ensure no double-callbacks happen\n  function cb(err) {\n    if (cb.done) {\n      return;\n    }\n    cb.done = true;\n    if (err) {\n      log.warn('install', 'got an error, rolling back install');\n      // roll-back the install if anything went wrong\n      gyp.commands.remove([release.versionDir], function () {\n        callback(err);\n      });\n    } else {\n      callback(null, release.version);\n    }\n  }\n\n  // Determine which node dev files version we are installing\n  log.verbose('install', 'input version string %j', release.version);\n  if (!release.semver) {\n    // could not parse the version string with semver\n    return callback(new Error('Invalid version number: ' + release.version));\n  }\n  if (semver.lt(release.version, '0.8.0')) {\n    return callback(new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version));\n  }\n\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version);\n    if (gyp.opts.nodedir) {\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir);\n      callback();\n    } else {\n      callback(new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead'));\n    }\n    return;\n  }\n\n  // flatten version into String\n  log.verbose('install', 'installing version: %s', release.versionDir);\n\n  // the directory where the dev files will be installed\n  var devDir = path.resolve(gyp.devDir, release.versionDir);\n\n  // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed');\n    fs.stat(devDir, function (err) {\n      if (err) {\n        if (err.code === 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version);\n          go();\n        } else if (err.code === 'EACCES') {\n          eaccesFallback(err);\n        } else {\n          cb(err);\n        }\n        return;\n      }\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"');\n      var installVersionFile = path.resolve(devDir, 'installVersion');\n      fs.readFile(installVersionFile, 'ascii', function (err, ver) {\n        if (err && err.code !== 'ENOENT') {\n          return cb(err);\n        }\n        var installVersion = parseInt(ver, 10) || 0;\n        log.verbose('got \"installVersion\"', installVersion);\n        log.verbose('needs \"installVersion\"', gyp.package.installVersion);\n        if (installVersion < gyp.package.installVersion) {\n          log.verbose('install', 'version is no good; reinstalling');\n          go();\n        } else {\n          log.verbose('install', 'version is good');\n          cb();\n        }\n      });\n    });\n  } else {\n    go();\n  }\n  function getContentSha(res, callback) {\n    var shasum = crypto.createHash('sha256');\n    res.on('data', function (chunk) {\n      shasum.update(chunk);\n    }).on('end', function () {\n      callback(null, shasum.digest('hex'));\n    });\n  }\n  function go() {\n    log.verbose('ensuring nodedir is created', devDir);\n\n    // first create the dir for the node dev files\n    fs.mkdir(devDir, {\n      recursive: true\n    }, function (err, created) {\n      if (err) {\n        if (err.code === 'EACCES') {\n          eaccesFallback(err);\n        } else {\n          cb(err);\n        }\n        return;\n      }\n      if (created) {\n        log.verbose('created nodedir', created);\n      }\n\n      // now download the node tarball\n      var tarPath = gyp.opts.tarball;\n      var badDownload = false;\n      var extractCount = 0;\n      var contentShasums = {};\n      var expectShasums = {};\n\n      // checks if a file to be extracted from the tarball is valid.\n      // only .h header files and the gyp files get extracted\n      function isValid(path) {\n        var isValid = valid(path);\n        if (isValid) {\n          log.verbose('extracted file from tarball', path);\n          extractCount++;\n        } else {\n          // invalid\n          log.silly('ignoring from tarball', path);\n        }\n        return isValid;\n      }\n\n      // download the tarball and extract!\n      if (tarPath) {\n        return tar.extract({\n          file: tarPath,\n          strip: 1,\n          filter: isValid,\n          cwd: devDir\n        }).then(afterTarball, cb);\n      }\n      try {\n        var req = download(gyp, process.env, release.tarballUrl);\n      } catch (e) {\n        return cb(e);\n      }\n\n      // something went wrong downloading the tarball?\n      req.on('error', function (err) {\n        if (err.code === 'ENOTFOUND') {\n          return cb(new Error('This is most likely not a problem with node-gyp or the package itself and\\n' + 'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' + 'network settings.'));\n        }\n        badDownload = true;\n        cb(err);\n      });\n      req.on('close', function () {\n        if (extractCount === 0) {\n          cb(new Error('Connection closed while downloading tarball file'));\n        }\n      });\n      req.on('response', function (res) {\n        if (res.statusCode !== 200) {\n          badDownload = true;\n          cb(new Error(res.statusCode + ' response downloading ' + release.tarballUrl));\n          return;\n        }\n        // content checksum\n        getContentSha(res, function (_, checksum) {\n          var filename = path.basename(release.tarballUrl).trim();\n          contentShasums[filename] = checksum;\n          log.verbose('content checksum', filename, checksum);\n        });\n\n        // start unzipping and untaring\n        res.pipe(tar.extract({\n          strip: 1,\n          cwd: devDir,\n          filter: isValid\n        }).on('close', afterTarball).on('error', cb));\n      });\n\n      // invoked after the tarball has finished being extracted\n      function afterTarball() {\n        if (badDownload) {\n          return;\n        }\n        if (extractCount === 0) {\n          return cb(new Error('There was a fatal problem while downloading/extracting the tarball'));\n        }\n        log.verbose('tarball', 'done parsing tarball');\n        var async = 0;\n        if (win) {\n          // need to download node.lib\n          async++;\n          downloadNodeLib(deref);\n        }\n\n        // write the \"installVersion\" file\n        async++;\n        var installVersionPath = path.resolve(devDir, 'installVersion');\n        fs.writeFile(installVersionPath, gyp.package.installVersion + '\\n', deref);\n\n        // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n        if (!tarPath || win) {\n          // download SHASUMS.txt\n          async++;\n          downloadShasums(deref);\n        }\n        if (async === 0) {\n          // no async tasks required\n          cb();\n        }\n        function deref(err) {\n          if (err) {\n            return cb(err);\n          }\n          async--;\n          if (!async) {\n            log.verbose('download contents checksum', JSON.stringify(contentShasums));\n            // check content shasums\n            for (var k in contentShasums) {\n              log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k]);\n              if (contentShasums[k] !== expectShasums[k]) {\n                cb(new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]));\n                return;\n              }\n            }\n            cb();\n          }\n        }\n      }\n      function downloadShasums(done) {\n        log.verbose('check download content checksum, need to download `SHASUMS256.txt`...');\n        log.verbose('checksum url', release.shasumsUrl);\n        try {\n          var req = download(gyp, process.env, release.shasumsUrl);\n        } catch (e) {\n          return cb(e);\n        }\n        req.on('error', done);\n        req.on('response', function (res) {\n          if (res.statusCode !== 200) {\n            done(new Error(res.statusCode + ' status code downloading checksum'));\n            return;\n          }\n          var chunks = [];\n          res.on('data', function (chunk) {\n            chunks.push(chunk);\n          });\n          res.on('end', function () {\n            var lines = Buffer.concat(chunks).toString().trim().split('\\n');\n            lines.forEach(function (line) {\n              var items = line.trim().split(/\\s+/);\n              if (items.length !== 2) {\n                return;\n              }\n\n              // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n              var name = items[1].replace(/^\\.\\//, '');\n              expectShasums[name] = items[0];\n            });\n            log.verbose('checksum data', JSON.stringify(expectShasums));\n            done();\n          });\n        });\n      }\n      function downloadNodeLib(done) {\n        log.verbose('on Windows; need to download `' + release.name + '.lib`...');\n        var archs = ['ia32', 'x64', 'arm64'];\n        var async = archs.length;\n        archs.forEach(function (arch) {\n          var dir = path.resolve(devDir, arch);\n          var targetLibPath = path.resolve(dir, release.name + '.lib');\n          var libUrl = release[arch].libUrl;\n          var libPath = release[arch].libPath;\n          var name = arch + ' ' + release.name + '.lib';\n          log.verbose(name, 'dir', dir);\n          log.verbose(name, 'url', libUrl);\n          fs.mkdir(dir, {\n            recursive: true\n          }, function (err) {\n            if (err) {\n              return done(err);\n            }\n            log.verbose('streaming', name, 'to:', targetLibPath);\n            try {\n              var req = download(gyp, process.env, libUrl, cb);\n            } catch (e) {\n              return cb(e);\n            }\n            req.on('error', done);\n            req.on('response', function (res) {\n              if (res.statusCode === 403 || res.statusCode === 404) {\n                if (arch === 'arm64') {\n                  // Arm64 is a newer platform on Windows and not all node distributions provide it.\n                  log.verbose(`${name} was not found in ${libUrl}`);\n                } else {\n                  log.warn(`${name} was not found in ${libUrl}`);\n                }\n                return;\n              } else if (res.statusCode !== 200) {\n                done(new Error(res.statusCode + ' status code downloading ' + name));\n                return;\n              }\n              getContentSha(res, function (_, checksum) {\n                contentShasums[libPath] = checksum;\n                log.verbose('content checksum', libPath, checksum);\n              });\n              var ws = fs.createWriteStream(targetLibPath);\n              ws.on('error', cb);\n              req.pipe(ws);\n            });\n            req.on('end', function () {\n              --async || done();\n            });\n          });\n        });\n      } // downloadNodeLib()\n    }); // mkdir()\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n  function valid(file) {\n    // header files\n    var extname = path.extname(file);\n    return extname === '.h' || extname === '.gypi';\n  }\n\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n  function eaccesFallback(err) {\n    var noretry = '--node_gyp_internal_noretry';\n    if (argv.indexOf(noretry) !== -1) {\n      return cb(err);\n    }\n    var tmpdir = os.tmpdir();\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp');\n    var userString = '';\n    try {\n      // os.userInfo can fail on some systems, it's not critical here\n      userString = ` (\"${os.userInfo().username}\")`;\n    } catch (e) {}\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir);\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir);\n    if (process.cwd() === tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space');\n      gyp.todo.push({\n        name: 'remove',\n        args: argv\n      });\n    }\n    gyp.commands.install([noretry].concat(argv), cb);\n  }\n}\nfunction download(gyp, env, url) {\n  log.http('GET', url);\n  var requestOpts = {\n    uri: url,\n    headers: {\n      'User-Agent': 'node-gyp v' + gyp.version + ' (node ' + process.version + ')',\n      Connection: 'keep-alive'\n    }\n  };\n  var cafile = gyp.opts.cafile;\n  if (cafile) {\n    requestOpts.ca = readCAFile(cafile);\n  }\n\n  // basic support for a proxy server\n  var proxyUrl = getProxyFromURI(gyp, env, url);\n  if (proxyUrl) {\n    if (/^https?:\\/\\//i.test(proxyUrl)) {\n      log.verbose('download', 'using proxy url: \"%s\"', proxyUrl);\n      requestOpts.proxy = proxyUrl;\n    } else {\n      log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl);\n    }\n  }\n  var req = request(requestOpts);\n  req.on('response', function (res) {\n    log.http(res.statusCode, url);\n  });\n  return req;\n}\nfunction readCAFile(filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  var ca = fs.readFileSync(filename, 'utf8');\n  var re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g;\n  return ca.match(re);\n}\nmodule.exports = function (gyp, argv, callback) {\n  return install(fs, gyp, argv, callback);\n};\nmodule.exports.test = {\n  download: download,\n  install: install,\n  readCAFile: readCAFile\n};\nmodule.exports.usage = 'Install node development files for the specified node version.';","map":{"version":3,"names":["fs","require","os","tar","path","crypto","log","semver","request","processRelease","win","process","platform","getProxyFromURI","install","gyp","argv","callback","release","version","cb","err","done","warn","commands","remove","versionDir","verbose","Error","lt","prerelease","opts","nodedir","devDir","resolve","ensure","stat","code","go","eaccesFallback","installVersionFile","readFile","ver","installVersion","parseInt","package","getContentSha","res","shasum","createHash","on","chunk","update","digest","mkdir","recursive","created","tarPath","tarball","badDownload","extractCount","contentShasums","expectShasums","isValid","valid","silly","extract","file","strip","filter","cwd","then","afterTarball","req","download","env","tarballUrl","e","statusCode","_","checksum","filename","basename","trim","pipe","async","downloadNodeLib","deref","installVersionPath","writeFile","downloadShasums","JSON","stringify","k","shasumsUrl","chunks","push","lines","Buffer","concat","toString","split","forEach","line","items","length","name","replace","archs","arch","dir","targetLibPath","libUrl","libPath","ws","createWriteStream","extname","noretry","indexOf","tmpdir","userString","userInfo","username","todo","args","url","http","requestOpts","uri","headers","Connection","cafile","ca","readCAFile","proxyUrl","test","proxy","readFileSync","re","match","module","exports","usage"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/node-gyp/lib/install.js"],"sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst os = require('os')\nconst tar = require('tar')\nconst path = require('path')\nconst crypto = require('crypto')\nconst log = require('npmlog')\nconst semver = require('semver')\nconst request = require('request')\nconst processRelease = require('./process-release')\nconst win = process.platform === 'win32'\nconst getProxyFromURI = require('./proxy')\n\nfunction install (fs, gyp, argv, callback) {\n  var release = processRelease(argv, gyp, process.version, process.release)\n\n  // ensure no double-callbacks happen\n  function cb (err) {\n    if (cb.done) {\n      return\n    }\n    cb.done = true\n    if (err) {\n      log.warn('install', 'got an error, rolling back install')\n      // roll-back the install if anything went wrong\n      gyp.commands.remove([release.versionDir], function () {\n        callback(err)\n      })\n    } else {\n      callback(null, release.version)\n    }\n  }\n\n  // Determine which node dev files version we are installing\n  log.verbose('install', 'input version string %j', release.version)\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    return callback(new Error('Invalid version number: ' + release.version))\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    return callback(new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version))\n  }\n\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version)\n    if (gyp.opts.nodedir) {\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir)\n      callback()\n    } else {\n      callback(new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead'))\n    }\n    return\n  }\n\n  // flatten version into String\n  log.verbose('install', 'installing version: %s', release.versionDir)\n\n  // the directory where the dev files will be installed\n  var devDir = path.resolve(gyp.devDir, release.versionDir)\n\n  // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed')\n    fs.stat(devDir, function (err) {\n      if (err) {\n        if (err.code === 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version)\n          go()\n        } else if (err.code === 'EACCES') {\n          eaccesFallback(err)\n        } else {\n          cb(err)\n        }\n        return\n      }\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"')\n      var installVersionFile = path.resolve(devDir, 'installVersion')\n      fs.readFile(installVersionFile, 'ascii', function (err, ver) {\n        if (err && err.code !== 'ENOENT') {\n          return cb(err)\n        }\n        var installVersion = parseInt(ver, 10) || 0\n        log.verbose('got \"installVersion\"', installVersion)\n        log.verbose('needs \"installVersion\"', gyp.package.installVersion)\n        if (installVersion < gyp.package.installVersion) {\n          log.verbose('install', 'version is no good; reinstalling')\n          go()\n        } else {\n          log.verbose('install', 'version is good')\n          cb()\n        }\n      })\n    })\n  } else {\n    go()\n  }\n\n  function getContentSha (res, callback) {\n    var shasum = crypto.createHash('sha256')\n    res.on('data', function (chunk) {\n      shasum.update(chunk)\n    }).on('end', function () {\n      callback(null, shasum.digest('hex'))\n    })\n  }\n\n  function go () {\n    log.verbose('ensuring nodedir is created', devDir)\n\n    // first create the dir for the node dev files\n    fs.mkdir(devDir, { recursive: true }, function (err, created) {\n      if (err) {\n        if (err.code === 'EACCES') {\n          eaccesFallback(err)\n        } else {\n          cb(err)\n        }\n        return\n      }\n\n      if (created) {\n        log.verbose('created nodedir', created)\n      }\n\n      // now download the node tarball\n      var tarPath = gyp.opts.tarball\n      var badDownload = false\n      var extractCount = 0\n      var contentShasums = {}\n      var expectShasums = {}\n\n      // checks if a file to be extracted from the tarball is valid.\n      // only .h header files and the gyp files get extracted\n      function isValid (path) {\n        var isValid = valid(path)\n        if (isValid) {\n          log.verbose('extracted file from tarball', path)\n          extractCount++\n        } else {\n          // invalid\n          log.silly('ignoring from tarball', path)\n        }\n        return isValid\n      }\n\n      // download the tarball and extract!\n      if (tarPath) {\n        return tar.extract({\n          file: tarPath,\n          strip: 1,\n          filter: isValid,\n          cwd: devDir\n        }).then(afterTarball, cb)\n      }\n\n      try {\n        var req = download(gyp, process.env, release.tarballUrl)\n      } catch (e) {\n        return cb(e)\n      }\n\n      // something went wrong downloading the tarball?\n      req.on('error', function (err) {\n        if (err.code === 'ENOTFOUND') {\n          return cb(new Error('This is most likely not a problem with node-gyp or the package itself and\\n' +\n            'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' +\n            'network settings.'))\n        }\n        badDownload = true\n        cb(err)\n      })\n\n      req.on('close', function () {\n        if (extractCount === 0) {\n          cb(new Error('Connection closed while downloading tarball file'))\n        }\n      })\n\n      req.on('response', function (res) {\n        if (res.statusCode !== 200) {\n          badDownload = true\n          cb(new Error(res.statusCode + ' response downloading ' + release.tarballUrl))\n          return\n        }\n        // content checksum\n        getContentSha(res, function (_, checksum) {\n          var filename = path.basename(release.tarballUrl).trim()\n          contentShasums[filename] = checksum\n          log.verbose('content checksum', filename, checksum)\n        })\n\n        // start unzipping and untaring\n        res.pipe(tar.extract({\n          strip: 1,\n          cwd: devDir,\n          filter: isValid\n        }).on('close', afterTarball).on('error', cb))\n      })\n\n      // invoked after the tarball has finished being extracted\n      function afterTarball () {\n        if (badDownload) {\n          return\n        }\n        if (extractCount === 0) {\n          return cb(new Error('There was a fatal problem while downloading/extracting the tarball'))\n        }\n        log.verbose('tarball', 'done parsing tarball')\n        var async = 0\n\n        if (win) {\n          // need to download node.lib\n          async++\n          downloadNodeLib(deref)\n        }\n\n        // write the \"installVersion\" file\n        async++\n        var installVersionPath = path.resolve(devDir, 'installVersion')\n        fs.writeFile(installVersionPath, gyp.package.installVersion + '\\n', deref)\n\n        // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n        if (!tarPath || win) {\n          // download SHASUMS.txt\n          async++\n          downloadShasums(deref)\n        }\n\n        if (async === 0) {\n          // no async tasks required\n          cb()\n        }\n\n        function deref (err) {\n          if (err) {\n            return cb(err)\n          }\n\n          async--\n          if (!async) {\n            log.verbose('download contents checksum', JSON.stringify(contentShasums))\n            // check content shasums\n            for (var k in contentShasums) {\n              log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k])\n              if (contentShasums[k] !== expectShasums[k]) {\n                cb(new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]))\n                return\n              }\n            }\n            cb()\n          }\n        }\n      }\n\n      function downloadShasums (done) {\n        log.verbose('check download content checksum, need to download `SHASUMS256.txt`...')\n        log.verbose('checksum url', release.shasumsUrl)\n        try {\n          var req = download(gyp, process.env, release.shasumsUrl)\n        } catch (e) {\n          return cb(e)\n        }\n\n        req.on('error', done)\n        req.on('response', function (res) {\n          if (res.statusCode !== 200) {\n            done(new Error(res.statusCode + ' status code downloading checksum'))\n            return\n          }\n\n          var chunks = []\n          res.on('data', function (chunk) {\n            chunks.push(chunk)\n          })\n          res.on('end', function () {\n            var lines = Buffer.concat(chunks).toString().trim().split('\\n')\n            lines.forEach(function (line) {\n              var items = line.trim().split(/\\s+/)\n              if (items.length !== 2) {\n                return\n              }\n\n              // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n              var name = items[1].replace(/^\\.\\//, '')\n              expectShasums[name] = items[0]\n            })\n\n            log.verbose('checksum data', JSON.stringify(expectShasums))\n            done()\n          })\n        })\n      }\n\n      function downloadNodeLib (done) {\n        log.verbose('on Windows; need to download `' + release.name + '.lib`...')\n        var archs = ['ia32', 'x64', 'arm64']\n        var async = archs.length\n        archs.forEach(function (arch) {\n          var dir = path.resolve(devDir, arch)\n          var targetLibPath = path.resolve(dir, release.name + '.lib')\n          var libUrl = release[arch].libUrl\n          var libPath = release[arch].libPath\n          var name = arch + ' ' + release.name + '.lib'\n          log.verbose(name, 'dir', dir)\n          log.verbose(name, 'url', libUrl)\n\n          fs.mkdir(dir, { recursive: true }, function (err) {\n            if (err) {\n              return done(err)\n            }\n            log.verbose('streaming', name, 'to:', targetLibPath)\n\n            try {\n              var req = download(gyp, process.env, libUrl, cb)\n            } catch (e) {\n              return cb(e)\n            }\n\n            req.on('error', done)\n            req.on('response', function (res) {\n              if (res.statusCode === 403 || res.statusCode === 404) {\n                if (arch === 'arm64') {\n                  // Arm64 is a newer platform on Windows and not all node distributions provide it.\n                  log.verbose(`${name} was not found in ${libUrl}`)\n                } else {\n                  log.warn(`${name} was not found in ${libUrl}`)\n                }\n                return\n              } else if (res.statusCode !== 200) {\n                done(new Error(res.statusCode + ' status code downloading ' + name))\n                return\n              }\n\n              getContentSha(res, function (_, checksum) {\n                contentShasums[libPath] = checksum\n                log.verbose('content checksum', libPath, checksum)\n              })\n\n              var ws = fs.createWriteStream(targetLibPath)\n              ws.on('error', cb)\n              req.pipe(ws)\n            })\n            req.on('end', function () { --async || done() })\n          })\n        })\n      } // downloadNodeLib()\n    }) // mkdir()\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n  function valid (file) {\n    // header files\n    var extname = path.extname(file)\n    return extname === '.h' || extname === '.gypi'\n  }\n\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n  function eaccesFallback (err) {\n    var noretry = '--node_gyp_internal_noretry'\n    if (argv.indexOf(noretry) !== -1) {\n      return cb(err)\n    }\n    var tmpdir = os.tmpdir()\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp')\n    var userString = ''\n    try {\n      // os.userInfo can fail on some systems, it's not critical here\n      userString = ` (\"${os.userInfo().username}\")`\n    } catch (e) {}\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir)\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir)\n    if (process.cwd() === tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space')\n      gyp.todo.push({ name: 'remove', args: argv })\n    }\n    gyp.commands.install([noretry].concat(argv), cb)\n  }\n}\n\nfunction download (gyp, env, url) {\n  log.http('GET', url)\n\n  var requestOpts = {\n    uri: url,\n    headers: {\n      'User-Agent': 'node-gyp v' + gyp.version + ' (node ' + process.version + ')',\n      Connection: 'keep-alive'\n    }\n  }\n\n  var cafile = gyp.opts.cafile\n  if (cafile) {\n    requestOpts.ca = readCAFile(cafile)\n  }\n\n  // basic support for a proxy server\n  var proxyUrl = getProxyFromURI(gyp, env, url)\n  if (proxyUrl) {\n    if (/^https?:\\/\\//i.test(proxyUrl)) {\n      log.verbose('download', 'using proxy url: \"%s\"', proxyUrl)\n      requestOpts.proxy = proxyUrl\n    } else {\n      log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl)\n    }\n  }\n\n  var req = request(requestOpts)\n  req.on('response', function (res) {\n    log.http(res.statusCode, url)\n  })\n\n  return req\n}\n\nfunction readCAFile (filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  var ca = fs.readFileSync(filename, 'utf8')\n  var re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g\n  return ca.match(re)\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  return install(fs, gyp, argv, callback)\n}\nmodule.exports.test = {\n  download: download,\n  install: install,\n  readCAFile: readCAFile\n}\nmodule.exports.usage = 'Install node development files for the specified node version.'\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}