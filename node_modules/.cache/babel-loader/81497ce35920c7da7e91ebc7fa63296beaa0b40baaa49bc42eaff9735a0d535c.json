{"ast":null,"code":"const archy = require('archy');\nconst Arborist = require('@npmcli/arborist');\nconst chalk = require('chalk');\nconst pacote = require('pacote');\nconst semver = require('semver');\nconst npa = require('npm-package-arg');\nconst {\n  depth\n} = require('treeverse');\nconst {\n  readTree: getFundingInfo,\n  normalizeFunding,\n  isValidFunding\n} = require('libnpmfund');\nconst completion = require('./utils/completion/installed-deep.js');\nconst openUrl = require('./utils/open-url.js');\nconst ArboristWorkspaceCmd = require('./workspaces/arborist-cmd.js');\nconst getPrintableName = ({\n  name,\n  version\n}) => {\n  const printableVersion = version ? `@${version}` : '';\n  return `${name}${printableVersion}`;\n};\nclass Fund extends ArboristWorkspaceCmd {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description() {\n    return 'Retrieve funding information';\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name() {\n    return 'fund';\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params() {\n    return ['json', 'browser', 'unicode', 'workspace', 'which'];\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage() {\n    return ['[[<@scope>/]<pkg>]'];\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  async completion(opts) {\n    return completion(this.npm, opts);\n  }\n  exec(args, cb) {\n    this.fund(args).then(() => cb()).catch(cb);\n  }\n  async fund(args) {\n    const spec = args[0];\n    const numberArg = this.npm.config.get('which');\n    const fundingSourceNumber = numberArg && parseInt(numberArg, 10);\n    const badFundingSourceNumber = numberArg !== null && (String(fundingSourceNumber) !== numberArg || fundingSourceNumber < 1);\n    if (badFundingSourceNumber) {\n      const err = new Error('`npm fund [<@scope>/]<pkg> [--which=fundingSourceNumber]` must be given a positive integer');\n      err.code = 'EFUNDNUMBER';\n      throw err;\n    }\n    if (this.npm.config.get('global')) {\n      const err = new Error('`npm fund` does not support global packages');\n      err.code = 'EFUNDGLOBAL';\n      throw err;\n    }\n    const where = this.npm.prefix;\n    const arb = new Arborist({\n      ...this.npm.flatOptions,\n      path: where\n    });\n    const tree = await arb.loadActual();\n    if (spec) {\n      await this.openFundingUrl({\n        path: where,\n        tree,\n        spec,\n        fundingSourceNumber\n      });\n      return;\n    }\n    const fundingInfo = getFundingInfo(tree, {\n      ...this.flatOptions,\n      log: this.npm.log,\n      workspaces: this.workspaceNames\n    });\n    if (this.npm.config.get('json')) this.npm.output(this.printJSON(fundingInfo));else this.npm.output(this.printHuman(fundingInfo));\n  }\n  printJSON(fundingInfo) {\n    return JSON.stringify(fundingInfo, null, 2);\n  }\n  printHuman(fundingInfo) {\n    const color = this.npm.color;\n    const unicode = this.npm.config.get('unicode');\n    const seenUrls = new Map();\n    const tree = obj => archy(obj, '', {\n      unicode\n    });\n    const result = depth({\n      tree: fundingInfo,\n      // composes human readable package name\n      // and creates a new archy item for readable output\n      visit: ({\n        name,\n        version,\n        funding\n      }) => {\n        const [fundingSource] = [].concat(normalizeFunding(funding)).filter(isValidFunding);\n        const {\n          url\n        } = fundingSource || {};\n        const pkgRef = getPrintableName({\n          name,\n          version\n        });\n        let item = {\n          label: pkgRef\n        };\n        if (url) {\n          item.label = tree({\n            label: color ? chalk.bgBlack.white(url) : url,\n            nodes: [pkgRef]\n          }).trim();\n\n          // stacks all packages together under the same item\n          if (seenUrls.has(url)) {\n            item = seenUrls.get(url);\n            item.label += `, ${pkgRef}`;\n            return null;\n          } else seenUrls.set(url, item);\n        }\n        return item;\n      },\n      // puts child nodes back into returned archy\n      // output while also filtering out missing items\n      leave: (item, children) => {\n        if (item) item.nodes = children.filter(Boolean);\n        return item;\n      },\n      // turns tree-like object return by libnpmfund\n      // into children to be properly read by treeverse\n      getChildren: node => Object.keys(node.dependencies || {}).map(key => ({\n        name: key,\n        ...node.dependencies[key]\n      }))\n    });\n    const res = tree(result);\n    return color ? chalk.reset(res) : res;\n  }\n  async openFundingUrl({\n    path,\n    tree,\n    spec,\n    fundingSourceNumber\n  }) {\n    const arg = npa(spec, path);\n    const retrievePackageMetadata = () => {\n      if (arg.type === 'directory') {\n        if (tree.path === arg.fetchSpec) {\n          // matches cwd, e.g: npm fund .\n          return tree.package;\n        } else {\n          // matches any file path within current arborist inventory\n          for (const item of tree.inventory.values()) {\n            if (item.path === arg.fetchSpec) return item.package;\n          }\n        }\n      } else {\n        // tries to retrieve a package from arborist inventory\n        // by matching resulted package name from the provided spec\n        const [item] = [...tree.inventory.query('name', arg.name)].filter(i => semver.valid(i.package.version)).sort((a, b) => semver.rcompare(a.package.version, b.package.version));\n        if (item) return item.package;\n      }\n    };\n    const {\n      funding\n    } = retrievePackageMetadata() || (await pacote.manifest(arg, this.npm.flatOptions).catch(() => ({})));\n    const validSources = [].concat(normalizeFunding(funding)).filter(isValidFunding);\n    const matchesValidSource = validSources.length === 1 || fundingSourceNumber > 0 && fundingSourceNumber <= validSources.length;\n    if (matchesValidSource) {\n      const index = fundingSourceNumber ? fundingSourceNumber - 1 : 0;\n      const {\n        type,\n        url\n      } = validSources[index];\n      const typePrefix = type ? `${type} funding` : 'Funding';\n      const msg = `${typePrefix} available at the following URL`;\n      return openUrl(this.npm, url, msg);\n    } else if (validSources.length && !(fundingSourceNumber >= 1)) {\n      validSources.forEach(({\n        type,\n        url\n      }, i) => {\n        const typePrefix = type ? `${type} funding` : 'Funding';\n        const msg = `${typePrefix} available at the following URL`;\n        this.npm.output(`${i + 1}: ${msg}: ${url}`);\n      });\n      this.npm.output('Run `npm fund [<@scope>/]<pkg> --which=1`, for example, to open the first funding URL listed in that package');\n    } else {\n      const noFundingError = new Error(`No valid funding method available for: ${spec}`);\n      noFundingError.code = 'ENOFUND';\n      throw noFundingError;\n    }\n  }\n}\nmodule.exports = Fund;","map":{"version":3,"names":["archy","require","Arborist","chalk","pacote","semver","npa","depth","readTree","getFundingInfo","normalizeFunding","isValidFunding","completion","openUrl","ArboristWorkspaceCmd","getPrintableName","name","version","printableVersion","Fund","description","params","usage","opts","npm","exec","args","cb","fund","then","catch","spec","numberArg","config","get","fundingSourceNumber","parseInt","badFundingSourceNumber","String","err","Error","code","where","prefix","arb","flatOptions","path","tree","loadActual","openFundingUrl","fundingInfo","log","workspaces","workspaceNames","output","printJSON","printHuman","JSON","stringify","color","unicode","seenUrls","Map","obj","result","visit","funding","fundingSource","concat","filter","url","pkgRef","item","label","bgBlack","white","nodes","trim","has","set","leave","children","Boolean","getChildren","node","Object","keys","dependencies","map","key","res","reset","arg","retrievePackageMetadata","type","fetchSpec","package","inventory","values","query","i","valid","sort","a","b","rcompare","manifest","validSources","matchesValidSource","length","index","typePrefix","msg","forEach","noFundingError","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/lib/fund.js"],"sourcesContent":["const archy = require('archy')\nconst Arborist = require('@npmcli/arborist')\nconst chalk = require('chalk')\nconst pacote = require('pacote')\nconst semver = require('semver')\nconst npa = require('npm-package-arg')\nconst { depth } = require('treeverse')\nconst {\n  readTree: getFundingInfo,\n  normalizeFunding,\n  isValidFunding,\n} = require('libnpmfund')\n\nconst completion = require('./utils/completion/installed-deep.js')\nconst openUrl = require('./utils/open-url.js')\nconst ArboristWorkspaceCmd = require('./workspaces/arborist-cmd.js')\n\nconst getPrintableName = ({ name, version }) => {\n  const printableVersion = version ? `@${version}` : ''\n  return `${name}${printableVersion}`\n}\n\nclass Fund extends ArboristWorkspaceCmd {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description () {\n    return 'Retrieve funding information'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'fund'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return [\n      'json',\n      'browser',\n      'unicode',\n      'workspace',\n      'which',\n    ]\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return ['[[<@scope>/]<pkg>]']\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  async completion (opts) {\n    return completion(this.npm, opts)\n  }\n\n  exec (args, cb) {\n    this.fund(args).then(() => cb()).catch(cb)\n  }\n\n  async fund (args) {\n    const spec = args[0]\n    const numberArg = this.npm.config.get('which')\n\n    const fundingSourceNumber = numberArg && parseInt(numberArg, 10)\n\n    const badFundingSourceNumber =\n      numberArg !== null &&\n      (String(fundingSourceNumber) !== numberArg || fundingSourceNumber < 1)\n\n    if (badFundingSourceNumber) {\n      const err = new Error('`npm fund [<@scope>/]<pkg> [--which=fundingSourceNumber]` must be given a positive integer')\n      err.code = 'EFUNDNUMBER'\n      throw err\n    }\n\n    if (this.npm.config.get('global')) {\n      const err = new Error('`npm fund` does not support global packages')\n      err.code = 'EFUNDGLOBAL'\n      throw err\n    }\n\n    const where = this.npm.prefix\n    const arb = new Arborist({ ...this.npm.flatOptions, path: where })\n    const tree = await arb.loadActual()\n\n    if (spec) {\n      await this.openFundingUrl({\n        path: where,\n        tree,\n        spec,\n        fundingSourceNumber,\n      })\n      return\n    }\n\n    const fundingInfo = getFundingInfo(tree, {\n      ...this.flatOptions,\n      log: this.npm.log,\n      workspaces: this.workspaceNames,\n    })\n\n    if (this.npm.config.get('json'))\n      this.npm.output(this.printJSON(fundingInfo))\n    else\n      this.npm.output(this.printHuman(fundingInfo))\n  }\n\n  printJSON (fundingInfo) {\n    return JSON.stringify(fundingInfo, null, 2)\n  }\n\n  printHuman (fundingInfo) {\n    const color = this.npm.color\n    const unicode = this.npm.config.get('unicode')\n    const seenUrls = new Map()\n\n    const tree = obj =>\n      archy(obj, '', { unicode })\n\n    const result = depth({\n      tree: fundingInfo,\n\n      // composes human readable package name\n      // and creates a new archy item for readable output\n      visit: ({ name, version, funding }) => {\n        const [fundingSource] = []\n          .concat(normalizeFunding(funding))\n          .filter(isValidFunding)\n        const { url } = fundingSource || {}\n        const pkgRef = getPrintableName({ name, version })\n        let item = {\n          label: pkgRef,\n        }\n\n        if (url) {\n          item.label = tree({\n            label: color ? chalk.bgBlack.white(url) : url,\n            nodes: [pkgRef],\n          }).trim()\n\n          // stacks all packages together under the same item\n          if (seenUrls.has(url)) {\n            item = seenUrls.get(url)\n            item.label += `, ${pkgRef}`\n            return null\n          } else\n            seenUrls.set(url, item)\n        }\n\n        return item\n      },\n\n      // puts child nodes back into returned archy\n      // output while also filtering out missing items\n      leave: (item, children) => {\n        if (item)\n          item.nodes = children.filter(Boolean)\n\n        return item\n      },\n\n      // turns tree-like object return by libnpmfund\n      // into children to be properly read by treeverse\n      getChildren: (node) =>\n        Object.keys(node.dependencies || {})\n          .map(key => ({\n            name: key,\n            ...node.dependencies[key],\n          })),\n    })\n\n    const res = tree(result)\n    return color ? chalk.reset(res) : res\n  }\n\n  async openFundingUrl ({ path, tree, spec, fundingSourceNumber }) {\n    const arg = npa(spec, path)\n    const retrievePackageMetadata = () => {\n      if (arg.type === 'directory') {\n        if (tree.path === arg.fetchSpec) {\n          // matches cwd, e.g: npm fund .\n          return tree.package\n        } else {\n          // matches any file path within current arborist inventory\n          for (const item of tree.inventory.values()) {\n            if (item.path === arg.fetchSpec)\n              return item.package\n          }\n        }\n      } else {\n        // tries to retrieve a package from arborist inventory\n        // by matching resulted package name from the provided spec\n        const [item] = [...tree.inventory.query('name', arg.name)]\n          .filter(i => semver.valid(i.package.version))\n          .sort((a, b) => semver.rcompare(a.package.version, b.package.version))\n\n        if (item)\n          return item.package\n      }\n    }\n\n    const { funding } = retrievePackageMetadata() ||\n      await pacote.manifest(arg, this.npm.flatOptions).catch(() => ({}))\n\n    const validSources = []\n      .concat(normalizeFunding(funding))\n      .filter(isValidFunding)\n\n    const matchesValidSource =\n      validSources.length === 1 ||\n      (fundingSourceNumber > 0 && fundingSourceNumber <= validSources.length)\n\n    if (matchesValidSource) {\n      const index = fundingSourceNumber ? fundingSourceNumber - 1 : 0\n      const { type, url } = validSources[index]\n      const typePrefix = type ? `${type} funding` : 'Funding'\n      const msg = `${typePrefix} available at the following URL`\n      return openUrl(this.npm, url, msg)\n    } else if (validSources.length && !(fundingSourceNumber >= 1)) {\n      validSources.forEach(({ type, url }, i) => {\n        const typePrefix = type ? `${type} funding` : 'Funding'\n        const msg = `${typePrefix} available at the following URL`\n        this.npm.output(`${i + 1}: ${msg}: ${url}`)\n      })\n      this.npm.output('Run `npm fund [<@scope>/]<pkg> --which=1`, for example, to open the first funding URL listed in that package')\n    } else {\n      const noFundingError = new Error(`No valid funding method available for: ${spec}`)\n      noFundingError.code = 'ENOFUND'\n\n      throw noFundingError\n    }\n  }\n}\nmodule.exports = Fund\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}