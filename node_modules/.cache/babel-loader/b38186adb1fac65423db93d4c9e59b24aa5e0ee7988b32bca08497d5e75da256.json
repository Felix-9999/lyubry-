{"ast":null,"code":"const Fetcher = require('./fetcher.js');\nconst FileFetcher = require('./file.js');\nconst RemoteFetcher = require('./remote.js');\nconst DirFetcher = require('./dir.js');\nconst hashre = /^[a-f0-9]{40}$/;\nconst git = require('@npmcli/git');\nconst pickManifest = require('npm-pick-manifest');\nconst npa = require('npm-package-arg');\nconst url = require('url');\nconst Minipass = require('minipass');\nconst cacache = require('cacache');\nconst {\n  promisify\n} = require('util');\nconst readPackageJson = require('read-package-json-fast');\nconst npm = require('./util/npm.js');\nconst _resolvedFromRepo = Symbol('_resolvedFromRepo');\nconst _resolvedFromHosted = Symbol('_resolvedFromHosted');\nconst _resolvedFromClone = Symbol('_resolvedFromClone');\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\nconst _addGitSha = Symbol('_addGitSha');\nconst addGitSha = require('./util/add-git-sha.js');\nconst _clone = Symbol('_clone');\nconst _cloneHosted = Symbol('_cloneHosted');\nconst _cloneRepo = Symbol('_cloneRepo');\nconst _setResolvedWithSha = Symbol('_setResolvedWithSha');\nconst _prepareDir = Symbol('_prepareDir');\n\n// get the repository url.\n// prefer https if there's auth, since ssh will drop that.\n// otherwise, prefer ssh if available (more secure).\n// We have to add the git+ back because npa suppresses it.\nconst repoUrl = (h, opts) => h.sshurl && !(h.https && h.auth) && addGitPlus(h.sshurl(opts)) || h.https && addGitPlus(h.https(opts));\n\n// add git+ to the url, but only one time.\nconst addGitPlus = url => url && `git+${url}`.replace(/^(git\\+)+/, 'git+');\nclass GitFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts);\n    this.resolvedRef = null;\n    if (this.spec.hosted) this.from = this.spec.hosted.shortcut({\n      noCommittish: false\n    });\n\n    // shortcut: avoid full clone when we can go straight to the tgz\n    // if we have the full sha and it's a hosted git platform\n    if (this.spec.gitCommittish && hashre.test(this.spec.gitCommittish)) {\n      this.resolvedSha = this.spec.gitCommittish;\n      // use hosted.tarball() when we shell to RemoteFetcher later\n      this.resolved = this.spec.hosted ? repoUrl(this.spec.hosted, {\n        noCommittish: false\n      }) : this.spec.fetchSpec + '#' + this.spec.gitCommittish;\n    } else this.resolvedSha = '';\n  }\n\n  // just exposed to make it easier to test all the combinations\n  static repoUrl(hosted, opts) {\n    return repoUrl(hosted, opts);\n  }\n  get types() {\n    return ['git'];\n  }\n  resolve() {\n    // likely a hosted git repo with a sha, so get the tarball url\n    // but in general, no reason to resolve() more than necessary!\n    if (this.resolved) return super.resolve();\n\n    // fetch the git repo and then look at the current hash\n    const h = this.spec.hosted;\n    // try to use ssh, fall back to git.\n    return h ? this[_resolvedFromHosted](h) : this[_resolvedFromRepo](this.spec.fetchSpec);\n  }\n\n  // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n  [_resolvedFromHosted](hosted) {\n    return this[_resolvedFromRepo](hosted.https && hosted.https()).catch(er => {\n      // Throw early since we know pathspec errors will fail again if retried\n      if (er instanceof git.errors.GitPathspecError) throw er;\n      const ssh = hosted.sshurl && hosted.sshurl();\n      // no fallthrough if we can't fall through or have https auth\n      if (!ssh || hosted.auth) throw er;\n      return this[_resolvedFromRepo](ssh);\n    });\n  }\n  [_resolvedFromRepo](gitRemote) {\n    // XXX make this a custom error class\n    if (!gitRemote) return Promise.reject(new Error(`No git url for ${this.spec}`));\n    const gitRange = this.spec.gitRange;\n    const name = this.spec.name;\n    return git.revs(gitRemote, this.opts).then(remoteRefs => {\n      return gitRange ? pickManifest({\n        versions: remoteRefs.versions,\n        'dist-tags': remoteRefs['dist-tags'],\n        name\n      }, gitRange, this.opts) : this.spec.gitCommittish ? remoteRefs.refs[this.spec.gitCommittish] || remoteRefs.refs[remoteRefs.shas[this.spec.gitCommittish]] : remoteRefs.refs.HEAD; // no git committish, get default head\n    }).then(revDoc => {\n      // the committish provided isn't in the rev list\n      // things like HEAD~3 or @yesterday can land here.\n      if (!revDoc || !revDoc.sha) return this[_resolvedFromClone]();\n      this.resolvedRef = revDoc;\n      this.resolvedSha = revDoc.sha;\n      this[_addGitSha](revDoc.sha);\n      return this.resolved;\n    });\n  }\n  [_setResolvedWithSha](withSha) {\n    // we haven't cloned, so a tgz download is still faster\n    // of course, if it's not a known host, we can't do that.\n    this.resolved = !this.spec.hosted ? withSha : repoUrl(npa(withSha).hosted, {\n      noCommittish: false\n    });\n  }\n\n  // when we get the git sha, we affix it to our spec to build up\n  // either a git url with a hash, or a tarball download URL\n  [_addGitSha](sha) {\n    this[_setResolvedWithSha](addGitSha(this.spec, sha));\n  }\n  [_resolvedFromClone]() {\n    // do a full or shallow clone, then look at the HEAD\n    // kind of wasteful, but no other option, really\n    return this[_clone](dir => this.resolved);\n  }\n  [_prepareDir](dir) {\n    return readPackageJson(dir + '/package.json').then(mani => {\n      // no need if we aren't going to do any preparation.\n      const scripts = mani.scripts;\n      if (!scripts || !(scripts.postinstall || scripts.build || scripts.preinstall || scripts.install || scripts.prepare)) return;\n\n      // to avoid cases where we have an cycle of git deps that depend\n      // on one another, we only ever do preparation for one instance\n      // of a given git dep along the chain of installations.\n      // Note that this does mean that a dependency MAY in theory end up\n      // trying to run its prepare script using a dependency that has not\n      // been properly prepared itself, but that edge case is smaller\n      // and less hazardous than a fork bomb of npm and git commands.\n      const noPrepare = !process.env._PACOTE_NO_PREPARE_ ? [] : process.env._PACOTE_NO_PREPARE_.split('\\n');\n      if (noPrepare.includes(this.resolved)) {\n        this.log.info('prepare', 'skip prepare, already seen', this.resolved);\n        return;\n      }\n      noPrepare.push(this.resolved);\n\n      // the DirFetcher will do its own preparation to run the prepare scripts\n      // All we have to do is put the deps in place so that it can succeed.\n      return npm(this.npmBin, [].concat(this.npmInstallCmd).concat(this.npmCliConfig), dir, {\n        ...process.env,\n        _PACOTE_NO_PREPARE_: noPrepare.join('\\n')\n      }, {\n        message: 'git dep preparation failed'\n      });\n    });\n  }\n  [_tarballFromResolved]() {\n    const stream = new Minipass();\n    stream.resolved = this.resolved;\n    stream.integrity = this.integrity;\n    stream.from = this.from;\n\n    // check it out and then shell out to the DirFetcher tarball packer\n    this[_clone](dir => this[_prepareDir](dir).then(() => new Promise((res, rej) => {\n      const df = new DirFetcher(`file:${dir}`, {\n        ...this.opts,\n        resolved: null,\n        integrity: null\n      });\n      const dirStream = df[_tarballFromResolved]();\n      dirStream.on('error', rej);\n      dirStream.on('end', res);\n      dirStream.pipe(stream);\n    }))).catch( /* istanbul ignore next: very unlikely and hard to test */\n    er => stream.emit('error', er));\n    return stream;\n  }\n\n  // clone a git repo into a temp folder (or fetch and unpack if possible)\n  // handler accepts a directory, and returns a promise that resolves\n  // when we're done with it, at which point, cacache deletes it\n  //\n  // TODO: after cloning, create a tarball of the folder, and add to the cache\n  // with cacache.put.stream(), using a key that's deterministic based on the\n  // spec and repo, so that we don't ever clone the same thing multiple times.\n  [_clone](handler, tarballOk = true) {\n    const o = {\n      tmpPrefix: 'git-clone'\n    };\n    const ref = this.resolvedSha || this.spec.gitCommittish;\n    const h = this.spec.hosted;\n    const resolved = this.resolved;\n\n    // can be set manually to false to fall back to actual git clone\n    tarballOk = tarballOk && h && resolved === repoUrl(h, {\n      noCommittish: false\n    }) && h.tarball;\n    return cacache.tmp.withTmp(this.cache, o, tmp => {\n      // if we're resolved, and have a tarball url, shell out to RemoteFetcher\n      if (tarballOk) {\n        const nameat = this.spec.name ? `${this.spec.name}@` : '';\n        return new RemoteFetcher(h.tarball({\n          noCommittish: false\n        }), {\n          ...this.opts,\n          allowGitIgnore: true,\n          pkgid: `git:${nameat}${this.resolved}`,\n          resolved: this.resolved,\n          integrity: null // it'll always be different, if we have one\n        }).extract(tmp).then(() => handler(tmp), er => {\n          // fall back to ssh download if tarball fails\n          if (er.constructor.name.match(/^Http/)) return this[_clone](handler, false);else throw er;\n        });\n      }\n      return (h ? this[_cloneHosted](ref, tmp) : this[_cloneRepo](this.spec.fetchSpec, ref, tmp)).then(sha => {\n        this.resolvedSha = sha;\n        if (!this.resolved) this[_addGitSha](sha);\n      }).then(() => handler(tmp));\n    });\n  }\n\n  // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n  [_cloneHosted](ref, tmp) {\n    const hosted = this.spec.hosted;\n    return this[_cloneRepo](hosted.https({\n      noCommittish: true\n    }), ref, tmp).catch(er => {\n      // Throw early since we know pathspec errors will fail again if retried\n      if (er instanceof git.errors.GitPathspecError) throw er;\n      const ssh = hosted.sshurl && hosted.sshurl({\n        noCommittish: true\n      });\n      // no fallthrough if we can't fall through or have https auth\n      if (!ssh || hosted.auth) throw er;\n      return this[_cloneRepo](ssh, ref, tmp);\n    });\n  }\n  [_cloneRepo](repo, ref, tmp) {\n    const {\n      opts,\n      spec\n    } = this;\n    return git.clone(repo, ref, tmp, {\n      ...opts,\n      spec\n    });\n  }\n  manifest() {\n    if (this.package) return Promise.resolve(this.package);\n    return this.spec.hosted && this.resolved ? FileFetcher.prototype.manifest.apply(this) : this[_clone](dir => readPackageJson(dir + '/package.json').then(mani => this.package = {\n      ...mani,\n      _integrity: this.integrity && String(this.integrity),\n      _resolved: this.resolved,\n      _from: this.from\n    }));\n  }\n  packument() {\n    return FileFetcher.prototype.packument.apply(this);\n  }\n}\nmodule.exports = GitFetcher;","map":{"version":3,"names":["Fetcher","require","FileFetcher","RemoteFetcher","DirFetcher","hashre","git","pickManifest","npa","url","Minipass","cacache","promisify","readPackageJson","npm","_resolvedFromRepo","Symbol","_resolvedFromHosted","_resolvedFromClone","_tarballFromResolved","for","_addGitSha","addGitSha","_clone","_cloneHosted","_cloneRepo","_setResolvedWithSha","_prepareDir","repoUrl","h","opts","sshurl","https","auth","addGitPlus","replace","GitFetcher","constructor","spec","resolvedRef","hosted","from","shortcut","noCommittish","gitCommittish","test","resolvedSha","resolved","fetchSpec","types","resolve","catch","er","errors","GitPathspecError","ssh","gitRemote","Promise","reject","Error","gitRange","name","revs","then","remoteRefs","versions","refs","shas","HEAD","revDoc","sha","withSha","dir","mani","scripts","postinstall","build","preinstall","install","prepare","noPrepare","process","env","_PACOTE_NO_PREPARE_","split","includes","log","info","push","npmBin","concat","npmInstallCmd","npmCliConfig","join","message","stream","integrity","res","rej","df","dirStream","on","pipe","emit","handler","tarballOk","o","tmpPrefix","ref","tarball","tmp","withTmp","cache","nameat","allowGitIgnore","pkgid","extract","match","repo","clone","manifest","package","prototype","apply","_integrity","String","_resolved","_from","packument","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/pacote/lib/git.js"],"sourcesContent":["const Fetcher = require('./fetcher.js')\nconst FileFetcher = require('./file.js')\nconst RemoteFetcher = require('./remote.js')\nconst DirFetcher = require('./dir.js')\nconst hashre = /^[a-f0-9]{40}$/\nconst git = require('@npmcli/git')\nconst pickManifest = require('npm-pick-manifest')\nconst npa = require('npm-package-arg')\nconst url = require('url')\nconst Minipass = require('minipass')\nconst cacache = require('cacache')\nconst { promisify } = require('util')\nconst readPackageJson = require('read-package-json-fast')\nconst npm = require('./util/npm.js')\n\nconst _resolvedFromRepo = Symbol('_resolvedFromRepo')\nconst _resolvedFromHosted = Symbol('_resolvedFromHosted')\nconst _resolvedFromClone = Symbol('_resolvedFromClone')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst _addGitSha = Symbol('_addGitSha')\nconst addGitSha = require('./util/add-git-sha.js')\nconst _clone = Symbol('_clone')\nconst _cloneHosted = Symbol('_cloneHosted')\nconst _cloneRepo = Symbol('_cloneRepo')\nconst _setResolvedWithSha = Symbol('_setResolvedWithSha')\nconst _prepareDir = Symbol('_prepareDir')\n\n// get the repository url.\n// prefer https if there's auth, since ssh will drop that.\n// otherwise, prefer ssh if available (more secure).\n// We have to add the git+ back because npa suppresses it.\nconst repoUrl = (h, opts) =>\n  h.sshurl && !(h.https && h.auth) && addGitPlus(h.sshurl(opts)) ||\n  h.https && addGitPlus(h.https(opts))\n\n// add git+ to the url, but only one time.\nconst addGitPlus = url => url && `git+${url}`.replace(/^(git\\+)+/, 'git+')\n\nclass GitFetcher extends Fetcher {\n  constructor (spec, opts) {\n    super(spec, opts)\n    this.resolvedRef = null\n    if (this.spec.hosted)\n      this.from = this.spec.hosted.shortcut({ noCommittish: false })\n\n    // shortcut: avoid full clone when we can go straight to the tgz\n    // if we have the full sha and it's a hosted git platform\n    if (this.spec.gitCommittish && hashre.test(this.spec.gitCommittish)) {\n      this.resolvedSha = this.spec.gitCommittish\n      // use hosted.tarball() when we shell to RemoteFetcher later\n      this.resolved = this.spec.hosted\n        ? repoUrl(this.spec.hosted, { noCommittish: false })\n        : this.spec.fetchSpec + '#' + this.spec.gitCommittish\n    } else\n      this.resolvedSha = ''\n  }\n\n  // just exposed to make it easier to test all the combinations\n  static repoUrl (hosted, opts) {\n    return repoUrl(hosted, opts)\n  }\n\n  get types () {\n    return ['git']\n  }\n\n  resolve () {\n    // likely a hosted git repo with a sha, so get the tarball url\n    // but in general, no reason to resolve() more than necessary!\n    if (this.resolved)\n      return super.resolve()\n\n    // fetch the git repo and then look at the current hash\n    const h = this.spec.hosted\n    // try to use ssh, fall back to git.\n    return h ? this[_resolvedFromHosted](h)\n      : this[_resolvedFromRepo](this.spec.fetchSpec)\n  }\n\n  // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n  [_resolvedFromHosted] (hosted) {\n    return this[_resolvedFromRepo](hosted.https && hosted.https())\n      .catch(er => {\n        // Throw early since we know pathspec errors will fail again if retried\n        if (er instanceof git.errors.GitPathspecError)\n          throw er\n        const ssh = hosted.sshurl && hosted.sshurl()\n        // no fallthrough if we can't fall through or have https auth\n        if (!ssh || hosted.auth)\n          throw er\n        return this[_resolvedFromRepo](ssh)\n      })\n  }\n\n  [_resolvedFromRepo] (gitRemote) {\n    // XXX make this a custom error class\n    if (!gitRemote)\n      return Promise.reject(new Error(`No git url for ${this.spec}`))\n    const gitRange = this.spec.gitRange\n    const name = this.spec.name\n    return git.revs(gitRemote, this.opts).then(remoteRefs => {\n      return gitRange ? pickManifest({\n          versions: remoteRefs.versions,\n          'dist-tags': remoteRefs['dist-tags'],\n          name,\n        }, gitRange, this.opts)\n        : this.spec.gitCommittish ?\n          remoteRefs.refs[this.spec.gitCommittish] ||\n          remoteRefs.refs[remoteRefs.shas[this.spec.gitCommittish]]\n        : remoteRefs.refs.HEAD // no git committish, get default head\n    }).then(revDoc => {\n      // the committish provided isn't in the rev list\n      // things like HEAD~3 or @yesterday can land here.\n      if (!revDoc || !revDoc.sha)\n        return this[_resolvedFromClone]()\n\n      this.resolvedRef = revDoc\n      this.resolvedSha = revDoc.sha\n      this[_addGitSha](revDoc.sha)\n      return this.resolved\n    })\n  }\n\n  [_setResolvedWithSha] (withSha) {\n    // we haven't cloned, so a tgz download is still faster\n    // of course, if it's not a known host, we can't do that.\n    this.resolved = !this.spec.hosted ? withSha\n      : repoUrl(npa(withSha).hosted, { noCommittish: false })\n  }\n\n  // when we get the git sha, we affix it to our spec to build up\n  // either a git url with a hash, or a tarball download URL\n  [_addGitSha] (sha) {\n    this[_setResolvedWithSha](addGitSha(this.spec, sha))\n  }\n\n  [_resolvedFromClone] () {\n    // do a full or shallow clone, then look at the HEAD\n    // kind of wasteful, but no other option, really\n    return this[_clone](dir => this.resolved)\n  }\n\n  [_prepareDir] (dir) {\n    return readPackageJson(dir + '/package.json').then(mani => {\n      // no need if we aren't going to do any preparation.\n      const scripts = mani.scripts\n      if (!scripts || !(\n          scripts.postinstall ||\n          scripts.build ||\n          scripts.preinstall ||\n          scripts.install ||\n          scripts.prepare))\n        return\n\n      // to avoid cases where we have an cycle of git deps that depend\n      // on one another, we only ever do preparation for one instance\n      // of a given git dep along the chain of installations.\n      // Note that this does mean that a dependency MAY in theory end up\n      // trying to run its prepare script using a dependency that has not\n      // been properly prepared itself, but that edge case is smaller\n      // and less hazardous than a fork bomb of npm and git commands.\n      const noPrepare = !process.env._PACOTE_NO_PREPARE_ ? []\n        : process.env._PACOTE_NO_PREPARE_.split('\\n')\n      if (noPrepare.includes(this.resolved)) {\n        this.log.info('prepare', 'skip prepare, already seen', this.resolved)\n        return\n      }\n      noPrepare.push(this.resolved)\n\n      // the DirFetcher will do its own preparation to run the prepare scripts\n      // All we have to do is put the deps in place so that it can succeed.\n      return npm(\n        this.npmBin,\n        [].concat(this.npmInstallCmd).concat(this.npmCliConfig),\n        dir,\n        { ...process.env, _PACOTE_NO_PREPARE_: noPrepare.join('\\n') },\n        { message: 'git dep preparation failed' }\n      )\n    })\n  }\n\n  [_tarballFromResolved] () {\n    const stream = new Minipass()\n    stream.resolved = this.resolved\n    stream.integrity = this.integrity\n    stream.from = this.from\n\n    // check it out and then shell out to the DirFetcher tarball packer\n    this[_clone](dir => this[_prepareDir](dir)\n      .then(() => new Promise((res, rej) => {\n        const df = new DirFetcher(`file:${dir}`, {\n          ...this.opts,\n          resolved: null,\n          integrity: null,\n        })\n        const dirStream = df[_tarballFromResolved]()\n        dirStream.on('error', rej)\n        dirStream.on('end', res)\n        dirStream.pipe(stream)\n      }))).catch(\n        /* istanbul ignore next: very unlikely and hard to test */\n        er => stream.emit('error', er)\n      )\n    return stream\n  }\n\n  // clone a git repo into a temp folder (or fetch and unpack if possible)\n  // handler accepts a directory, and returns a promise that resolves\n  // when we're done with it, at which point, cacache deletes it\n  //\n  // TODO: after cloning, create a tarball of the folder, and add to the cache\n  // with cacache.put.stream(), using a key that's deterministic based on the\n  // spec and repo, so that we don't ever clone the same thing multiple times.\n  [_clone] (handler, tarballOk = true) {\n    const o = { tmpPrefix: 'git-clone' }\n    const ref = this.resolvedSha || this.spec.gitCommittish\n    const h = this.spec.hosted\n    const resolved = this.resolved\n\n    // can be set manually to false to fall back to actual git clone\n    tarballOk = tarballOk &&\n      h && resolved === repoUrl(h, { noCommittish: false }) && h.tarball\n\n    return cacache.tmp.withTmp(this.cache, o, tmp => {\n      // if we're resolved, and have a tarball url, shell out to RemoteFetcher\n      if (tarballOk) {\n        const nameat = this.spec.name ? `${this.spec.name}@` : ''\n        return new RemoteFetcher(h.tarball({ noCommittish: false }), {\n          ...this.opts,\n          allowGitIgnore: true,\n          pkgid: `git:${nameat}${this.resolved}`,\n          resolved: this.resolved,\n          integrity: null, // it'll always be different, if we have one\n        }).extract(tmp).then(() => handler(tmp), er => {\n          // fall back to ssh download if tarball fails\n          if (er.constructor.name.match(/^Http/))\n            return this[_clone](handler, false)\n          else\n            throw er\n        })\n      }\n\n      return (\n        h ? this[_cloneHosted](ref, tmp)\n        : this[_cloneRepo](this.spec.fetchSpec, ref, tmp)\n      ).then(sha => {\n        this.resolvedSha = sha\n        if (!this.resolved)\n          this[_addGitSha](sha)\n      })\n      .then(() => handler(tmp))\n    })\n  }\n\n  // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n  [_cloneHosted] (ref, tmp) {\n    const hosted = this.spec.hosted\n    return this[_cloneRepo](hosted.https({ noCommittish: true }), ref, tmp)\n      .catch(er => {\n        // Throw early since we know pathspec errors will fail again if retried\n        if (er instanceof git.errors.GitPathspecError)\n          throw er\n        const ssh = hosted.sshurl && hosted.sshurl({ noCommittish: true })\n        // no fallthrough if we can't fall through or have https auth\n        if (!ssh || hosted.auth)\n          throw er\n        return this[_cloneRepo](ssh, ref, tmp)\n      })\n  }\n\n  [_cloneRepo] (repo, ref, tmp) {\n    const { opts, spec } = this\n    return git.clone(repo, ref, tmp, { ...opts, spec })\n  }\n\n  manifest () {\n    if (this.package)\n      return Promise.resolve(this.package)\n\n    return this.spec.hosted && this.resolved\n      ? FileFetcher.prototype.manifest.apply(this)\n      : this[_clone](dir =>\n          readPackageJson(dir + '/package.json')\n            .then(mani => this.package = {\n              ...mani,\n              _integrity: this.integrity && String(this.integrity),\n              _resolved: this.resolved,\n              _from: this.from,\n            }))\n  }\n\n  packument () {\n    return FileFetcher.prototype.packument.apply(this)\n  }\n}\nmodule.exports = GitFetcher\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}