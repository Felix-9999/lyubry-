{"ast":null,"code":"const fs = require('fs');\nconst promisify = require('util').promisify;\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\nconst {\n  resolve\n} = require('path');\nconst updateDeps = require('./update-dependencies.js');\nconst updateScripts = require('./update-scripts.js');\nconst updateWorkspaces = require('./update-workspaces.js');\nconst parseJSON = require('json-parse-even-better-errors');\nconst _filename = Symbol('filename');\nconst _manifest = Symbol('manifest');\nconst _readFileContent = Symbol('readFileContent');\n\n// a list of handy specialized helper functions that take\n// care of special cases that are handled by the npm cli\nconst knownSteps = new Set([updateDeps, updateScripts, updateWorkspaces]);\n\n// list of all keys that are handled by \"knownSteps\" helpers\nconst knownKeys = new Set([...updateDeps.knownKeys, 'scripts', 'workspaces']);\nclass PackageJson {\n  static async load(path) {\n    return await new PackageJson(path).load();\n  }\n  constructor(path) {\n    this[_filename] = resolve(path, 'package.json');\n    this[_manifest] = {};\n    this[_readFileContent] = '';\n  }\n  async load() {\n    try {\n      this[_readFileContent] = await readFile(this[_filename], 'utf8');\n    } catch (err) {\n      throw new Error('package.json not found');\n    }\n    try {\n      this[_manifest] = parseJSON(this[_readFileContent]);\n    } catch (err) {\n      throw new Error(`Invalid package.json: ${err}`);\n    }\n    return this;\n  }\n  get content() {\n    return this[_manifest];\n  }\n  update(content) {\n    // validates both current manifest and content param\n    const invalidContent = typeof this[_manifest] !== 'object' || typeof content !== 'object';\n    if (invalidContent) {\n      throw Object.assign(new Error(`Can't update invalid package.json data`), {\n        code: 'EPACKAGEJSONUPDATE'\n      });\n    }\n    for (const step of knownSteps) this[_manifest] = step({\n      content,\n      originalContent: this[_manifest]\n    });\n\n    // unknown properties will just be overwitten\n    for (const [key, value] of Object.entries(content)) {\n      if (!knownKeys.has(key)) this[_manifest][key] = value;\n    }\n    return this;\n  }\n  async save() {\n    const {\n      [Symbol.for('indent')]: indent,\n      [Symbol.for('newline')]: newline\n    } = this[_manifest];\n    const format = indent === undefined ? '  ' : indent;\n    const eol = newline === undefined ? '\\n' : newline;\n    const fileContent = `${JSON.stringify(this[_manifest], null, format)}\\n`.replace(/\\n/g, eol);\n    if (fileContent.trim() !== this[_readFileContent].trim()) return await writeFile(this[_filename], fileContent);\n  }\n}\nmodule.exports = PackageJson;","map":{"version":3,"names":["fs","require","promisify","readFile","writeFile","resolve","updateDeps","updateScripts","updateWorkspaces","parseJSON","_filename","Symbol","_manifest","_readFileContent","knownSteps","Set","knownKeys","PackageJson","load","path","constructor","err","Error","content","update","invalidContent","Object","assign","code","step","originalContent","key","value","entries","has","save","for","indent","newline","format","undefined","eol","fileContent","JSON","stringify","replace","trim","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/package-json/lib/index.js"],"sourcesContent":["const fs = require('fs')\nconst promisify = require('util').promisify\nconst readFile = promisify(fs.readFile)\nconst writeFile = promisify(fs.writeFile)\nconst { resolve } = require('path')\nconst updateDeps = require('./update-dependencies.js')\nconst updateScripts = require('./update-scripts.js')\nconst updateWorkspaces = require('./update-workspaces.js')\n\nconst parseJSON = require('json-parse-even-better-errors')\n\nconst _filename = Symbol('filename')\nconst _manifest = Symbol('manifest')\nconst _readFileContent = Symbol('readFileContent')\n\n// a list of handy specialized helper functions that take\n// care of special cases that are handled by the npm cli\nconst knownSteps = new Set([\n  updateDeps,\n  updateScripts,\n  updateWorkspaces,\n])\n\n// list of all keys that are handled by \"knownSteps\" helpers\nconst knownKeys = new Set([\n  ...updateDeps.knownKeys,\n  'scripts',\n  'workspaces',\n])\n\nclass PackageJson {\n  static async load (path) {\n    return await new PackageJson(path).load()\n  }\n\n  constructor (path) {\n    this[_filename] = resolve(path, 'package.json')\n    this[_manifest] = {}\n    this[_readFileContent] = ''\n  }\n\n  async load () {\n    try {\n      this[_readFileContent] =\n        await readFile(this[_filename], 'utf8')\n    } catch (err) {\n      throw new Error('package.json not found')\n    }\n\n    try {\n      this[_manifest] =\n        parseJSON(this[_readFileContent])\n    } catch (err) {\n      throw new Error(`Invalid package.json: ${err}`)\n    }\n\n    return this\n  }\n\n  get content () {\n    return this[_manifest]\n  }\n\n  update (content) {\n    // validates both current manifest and content param\n    const invalidContent =\n      typeof this[_manifest] !== 'object'\n        || typeof content !== 'object'\n    if (invalidContent) {\n      throw Object.assign(\n        new Error(`Can't update invalid package.json data`),\n        { code: 'EPACKAGEJSONUPDATE' }\n      )\n    }\n\n    for (const step of knownSteps)\n      this[_manifest] = step({ content, originalContent: this[_manifest] })\n\n    // unknown properties will just be overwitten\n    for (const [key, value] of Object.entries(content)) {\n      if (!knownKeys.has(key))\n        this[_manifest][key] = value\n    }\n\n    return this\n  }\n\n  async save () {\n    const {\n      [Symbol.for('indent')]: indent,\n      [Symbol.for('newline')]: newline,\n    } = this[_manifest]\n\n    const format = indent === undefined ? '  ' : indent\n    const eol = newline === undefined ? '\\n' : newline\n    const fileContent = `${\n      JSON.stringify(this[_manifest], null, format)\n    }\\n`\n      .replace(/\\n/g, eol)\n\n    if (fileContent.trim() !== this[_readFileContent].trim())\n      return await writeFile(this[_filename], fileContent)\n  }\n}\n\nmodule.exports = PackageJson\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}