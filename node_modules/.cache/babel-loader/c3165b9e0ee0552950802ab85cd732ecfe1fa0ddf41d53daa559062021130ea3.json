{"ast":null,"code":"const hash = require('./hash.js');\nconst semver = require('semver');\nconst semverOpt = {\n  includePrerelease: true,\n  loose: true\n};\nconst getDepSpec = require('./get-dep-spec.js');\n\n// any fields that we don't want in the cache need to be hidden\nconst _source = Symbol('source');\nconst _packument = Symbol('packument');\nconst _versionVulnMemo = Symbol('versionVulnMemo');\nconst _updated = Symbol('updated');\nconst _options = Symbol('options');\nconst _specVulnMemo = Symbol('specVulnMemo');\nconst _testVersion = Symbol('testVersion');\nconst _testVersions = Symbol('testVersions');\nconst _calculateRange = Symbol('calculateRange');\nconst _markVulnerable = Symbol('markVulnerable');\nconst _testSpec = Symbol('testSpec');\nclass Advisory {\n  constructor(name, source, options = {}) {\n    this.source = source.id;\n    this[_source] = source;\n    this[_options] = options;\n    this.name = name;\n    if (!source.name) source.name = name;\n    this.dependency = source.name;\n    if (this.type === 'advisory') {\n      this.title = source.title;\n      this.url = source.url;\n    } else {\n      this.title = `Depends on vulnerable versions of ${source.name}`;\n      this.url = null;\n    }\n    this.severity = source.severity || 'high';\n    this.versions = [];\n    this.vulnerableVersions = [];\n\n    // advisories have the range, metavulns do not\n    // if an advisory doesn't specify range, assume all are vulnerable\n    this.range = this.type === 'advisory' ? source.vulnerable_versions || '*' : null;\n    this.id = hash(this);\n    this[_packument] = null;\n    // memoized list of which versions are vulnerable\n    this[_versionVulnMemo] = new Map();\n    // memoized list of which dependency specs are vulnerable\n    this[_specVulnMemo] = new Map();\n    this[_updated] = false;\n  }\n\n  // true if we updated from what we had in cache\n  get updated() {\n    return this[_updated];\n  }\n  get type() {\n    return this.dependency === this.name ? 'advisory' : 'metavuln';\n  }\n  get packument() {\n    return this[_packument];\n  }\n\n  // load up the data from a cache entry and a fetched packument\n  load(cached, packument) {\n    // basic data integrity gutcheck\n    if (!cached || typeof cached !== 'object') throw new TypeError('invalid cached data, expected object');\n    if (!packument || typeof packument !== 'object') throw new TypeError('invalid packument data, expected object');\n    if (cached.id && cached.id !== this.id) {\n      throw Object.assign(new Error('loading from incorrect cache entry'), {\n        expected: this.id,\n        actual: cached.id\n      });\n    }\n    if (packument.name !== this.name) {\n      throw Object.assign(new Error('loading from incorrect packument'), {\n        expected: this.name,\n        actual: packument.name\n      });\n    }\n    if (this[_packument]) throw new Error('advisory object already loaded');\n\n    // if we have a range from the initialization, and the cached\n    // data has a *different* range, then we know we have to recalc.\n    // just don't use the cached data, so we will definitely not match later\n    if (!this.range || cached.range && cached.range === this.range) Object.assign(this, cached);\n    this[_packument] = packument;\n    const pakuVersions = Object.keys(packument.versions);\n    const allVersions = new Set([...pakuVersions, ...this.versions]);\n    const versionsAdded = [];\n    const versionsRemoved = [];\n    for (const v of allVersions) {\n      if (!this.versions.includes(v)) {\n        versionsAdded.push(v);\n        this.versions.push(v);\n      } else if (!pakuVersions.includes(v)) versionsRemoved.push(v);\n    }\n\n    // strip out any removed versions from our lists, and sort by semver\n    this.versions = semver.sort(this.versions.filter(v => !versionsRemoved.includes(v)), semverOpt);\n\n    // if no changes, then just return what we got from cache\n    // versions added or removed always means we changed\n    // otherwise, advisories change if the range changes, and\n    // metavulns change if the source was updated\n    const unchanged = this.type === 'advisory' ? this.range && this.range === cached.range : !this[_source].updated;\n\n    // if the underlying source changed, by an advisory updating the\n    // range, or a source advisory being updated, then we have to re-check\n    // otherwise, only recheck the new ones.\n    this.vulnerableVersions = !unchanged ? [] : semver.sort(this.vulnerableVersions.filter(v => !versionsRemoved.includes(v)), semverOpt);\n    if (unchanged && !versionsAdded.length && !versionsRemoved.length) {\n      // nothing added or removed, nothing to do here.  use the cached copy.\n      return this;\n    }\n    this[_updated] = true;\n\n    // test any versions newly added\n    if (!unchanged || versionsAdded.length) this[_testVersions](unchanged ? versionsAdded : this.versions);\n    this.vulnerableVersions = semver.sort(this.vulnerableVersions, semverOpt);\n\n    // metavulns have to calculate their range, since cache is invalidated\n    // advisories just get their range from the advisory above\n    if (this.type === 'metavuln') this[_calculateRange]();\n    return this;\n  }\n  [_calculateRange]() {\n    // calling semver.simplifyRange with a massive list of versions, and those\n    // versions all concatenated with `||` is a geometric CPU explosion!\n    // we can try to be a *little* smarter up front by doing x-y for all\n    // contiguous version sets in the list\n    const ranges = [];\n    this.versions = semver.sort(this.versions);\n    this.vulnerableVersions = semver.sort(this.vulnerableVersions);\n    for (let v = 0, vulnVer = 0; v < this.versions.length; v++) {\n      // figure out the vulnerable subrange\n      const vr = [this.versions[v]];\n      while (v < this.versions.length) {\n        if (this.versions[v] !== this.vulnerableVersions[vulnVer]) {\n          // we don't test prerelease versions, so just skip past it\n          if (/-/.test(this.versions[v])) {\n            v++;\n            continue;\n          }\n          break;\n        }\n        if (vr.length > 1) vr[1] = this.versions[v];else vr.push(this.versions[v]);\n        v++;\n        vulnVer++;\n      }\n      // it'll either be just the first version, which means no overlap,\n      // or the start and end versions, which might be the same version\n      if (vr.length > 1) {\n        const tail = this.versions[this.versions.length - 1];\n        ranges.push(vr[1] === tail ? `>=${vr[0]}` : vr[0] === vr[1] ? vr[0] : vr.join(' - '));\n      }\n    }\n    const metavuln = ranges.join(' || ').trim();\n    this.range = !metavuln ? '<0.0.0-0' : semver.simplifyRange(this.versions, metavuln, semverOpt);\n  }\n\n  // returns true if marked as vulnerable, false if ok\n  // spec is a dependency specifier, for metavuln cases\n  // where the version might not be in the packument.  if\n  // we have the packument and spec is not provided, then\n  // we use the dependency version from the manifest.\n  testVersion(version, spec = null) {\n    const sv = String(version);\n    if (this[_versionVulnMemo].has(sv)) return this[_versionVulnMemo].get(sv);\n    const result = this[_testVersion](version, spec);\n    if (result) this[_markVulnerable](version);\n    this[_versionVulnMemo].set(sv, !!result);\n    return result;\n  }\n  [_markVulnerable](version) {\n    const sv = String(version);\n    if (!this.vulnerableVersions.includes(sv)) this.vulnerableVersions.push(sv);\n  }\n  [_testVersion](version, spec) {\n    const sv = String(version);\n    if (this.vulnerableVersions.includes(sv)) return true;\n    if (this.type === 'advisory') {\n      // advisory, just test range\n      return semver.satisfies(version, this.range, semverOpt);\n    }\n\n    // check the dependency of this version on the vulnerable dep\n    // if we got a version that's not in the packument, fall back on\n    // the spec provided, if possible.\n    const mani = this[_packument].versions[version] || {\n      dependencies: {\n        [this.dependency]: spec\n      }\n    };\n    if (!spec) spec = getDepSpec(mani, this.dependency);\n\n    // no dep, no vuln\n    if (spec === null) return false;\n    if (!semver.validRange(spec, semverOpt)) {\n      // not a semver range, nothing we can hope to do about it\n      return true;\n    }\n    const bd = mani.bundleDependencies;\n    const bundled = bd && bd.includes(this[_source].name);\n    // XXX if bundled, then semver.intersects() means vulnerable\n    // else, pick a manifest and see if it can't be avoided\n    // try to pick a version of the dep that isn't vulnerable\n    const avoid = this[_source].range;\n    if (bundled) return semver.intersects(spec, avoid, semverOpt);\n    return this[_source].testSpec(spec);\n  }\n  testSpec(spec) {\n    // testing all the versions is a bit costly, and the spec tends to stay\n    // consistent across multiple versions, so memoize this as well, in case\n    // we're testing lots of versions.\n    const memo = this[_specVulnMemo];\n    if (memo.has(spec)) return memo.get(spec);\n    const res = this[_testSpec](spec);\n    memo.set(spec, res);\n    return res;\n  }\n  [_testSpec](spec) {\n    for (const v of this.versions) {\n      const satisfies = semver.satisfies(v, spec);\n      if (!satisfies) continue;\n      if (!this.testVersion(v)) return false;\n    }\n    // either vulnerable, or not installable because nothing satisfied\n    // either way, best avoided.\n    return true;\n  }\n  [_testVersions](versions) {\n    if (!versions.length) return;\n\n    // set of lists of versions\n    const versionSets = new Set();\n    versions = semver.sort(versions.map(v => semver.parse(v, semverOpt)));\n\n    // start out with the versions grouped by major and minor\n    let last = versions[0].major + '.' + versions[0].minor;\n    let list = [];\n    versionSets.add(list);\n    for (const v of versions) {\n      const k = v.major + '.' + v.minor;\n      if (k !== last) {\n        last = k;\n        list = [];\n        versionSets.add(list);\n      }\n      list.push(v);\n    }\n    for (const list of versionSets) {\n      // it's common to have version lists like:\n      // 1.0.0\n      // 1.0.1-alpha.0\n      // 1.0.1-alpha.1\n      // ...\n      // 1.0.1-alpha.999\n      // 1.0.1\n      // 1.0.2-alpha.0\n      // ...\n      // 1.0.2-alpha.99\n      // 1.0.2\n      // with a huge number of prerelease versions that are not installable\n      // anyway.\n      // If mid has a prerelease tag, and list[0] does not, then walk it\n      // back until we hit a non-prerelease version\n      // If mid has a prerelease tag, and list[list.length-1] does not,\n      // then walk it forward until we hit a version without a prerelease tag\n      // Similarly, if the head/tail is a prerelease, but there is a non-pr\n      // version in the list, then start there instead.\n      let h = 0;\n      const origHeadVuln = this.testVersion(list[h]);\n      while (h < list.length && /-/.test(String(list[h]))) h++;\n\n      // don't filter out the whole list!  they might all be pr's\n      if (h === list.length) h = 0;else if (origHeadVuln) {\n        // if the original was vulnerable, assume so are all of these\n        for (let hh = 0; hh < h; hh++) this[_markVulnerable](list[hh]);\n      }\n      let t = list.length - 1;\n      const origTailVuln = this.testVersion(list[t]);\n      while (t > h && /-/.test(String(list[t]))) t--;\n\n      // don't filter out the whole list!  might all be pr's\n      if (t === h) t = list.length - 1;else if (origTailVuln) {\n        // if original tail was vulnerable, assume these are as well\n        for (let tt = list.length - 1; tt > t; tt--) this[_markVulnerable](list[tt]);\n      }\n      const headVuln = h === 0 ? origHeadVuln : this.testVersion(list[h]);\n      const tailVuln = t === list.length - 1 ? origTailVuln : this.testVersion(list[t]);\n\n      // if head and tail both vulnerable, whole list is thrown out\n      if (headVuln && tailVuln) {\n        for (let v = h; v < t; v++) this[_markVulnerable](list[v]);\n        continue;\n      }\n\n      // if length is 2 or 1, then we marked them all already\n      if (t < h + 2) continue;\n      const mid = Math.floor(list.length / 2);\n      const pre = list.slice(0, mid);\n      const post = list.slice(mid);\n\n      // if the parent list wasn't prereleases, then drop pr tags\n      // from end of the pre list, and beginning of the post list,\n      // marking as vulnerable if the midpoint item we picked is.\n      if (!/-/.test(String(pre[0]))) {\n        const midVuln = this.testVersion(pre[pre.length - 1]);\n        while (/-/.test(String(pre[pre.length - 1]))) {\n          const v = pre.pop();\n          if (midVuln) this[_markVulnerable](v);\n        }\n      }\n      if (!/-/.test(String(post[post.length - 1]))) {\n        const midVuln = this.testVersion(post[0]);\n        while (/-/.test(String(post[0]))) {\n          const v = post.shift();\n          if (midVuln) this[_markVulnerable](v);\n        }\n      }\n      versionSets.add(pre);\n      versionSets.add(post);\n    }\n  }\n}\nmodule.exports = Advisory;","map":{"version":3,"names":["hash","require","semver","semverOpt","includePrerelease","loose","getDepSpec","_source","Symbol","_packument","_versionVulnMemo","_updated","_options","_specVulnMemo","_testVersion","_testVersions","_calculateRange","_markVulnerable","_testSpec","Advisory","constructor","name","source","options","id","dependency","type","title","url","severity","versions","vulnerableVersions","range","vulnerable_versions","Map","updated","packument","load","cached","TypeError","Object","assign","Error","expected","actual","pakuVersions","keys","allVersions","Set","versionsAdded","versionsRemoved","v","includes","push","sort","filter","unchanged","length","ranges","vulnVer","vr","test","tail","join","metavuln","trim","simplifyRange","testVersion","version","spec","sv","String","has","get","result","set","satisfies","mani","dependencies","validRange","bd","bundleDependencies","bundled","avoid","intersects","testSpec","memo","res","versionSets","map","parse","last","major","minor","list","add","k","h","origHeadVuln","hh","t","origTailVuln","tt","headVuln","tailVuln","mid","Math","floor","pre","slice","post","midVuln","pop","shift","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/metavuln-calculator/lib/advisory.js"],"sourcesContent":["const hash = require('./hash.js')\nconst semver = require('semver')\nconst semverOpt = { includePrerelease: true, loose: true }\nconst getDepSpec = require('./get-dep-spec.js')\n\n// any fields that we don't want in the cache need to be hidden\nconst _source = Symbol('source')\nconst _packument = Symbol('packument')\nconst _versionVulnMemo = Symbol('versionVulnMemo')\nconst _updated = Symbol('updated')\nconst _options = Symbol('options')\nconst _specVulnMemo = Symbol('specVulnMemo')\nconst _testVersion = Symbol('testVersion')\nconst _testVersions = Symbol('testVersions')\nconst _calculateRange = Symbol('calculateRange')\nconst _markVulnerable = Symbol('markVulnerable')\nconst _testSpec = Symbol('testSpec')\n\nclass Advisory {\n  constructor (name, source, options = {}) {\n    this.source = source.id\n    this[_source] = source\n    this[_options] = options\n    this.name = name\n    if (!source.name)\n      source.name = name\n\n    this.dependency = source.name\n\n    if (this.type === 'advisory') {\n      this.title = source.title\n      this.url = source.url\n    } else {\n      this.title = `Depends on vulnerable versions of ${source.name}`\n      this.url = null\n    }\n\n    this.severity = source.severity || 'high'\n    this.versions = []\n    this.vulnerableVersions = []\n\n    // advisories have the range, metavulns do not\n    // if an advisory doesn't specify range, assume all are vulnerable\n    this.range = this.type === 'advisory' ? source.vulnerable_versions || '*'\n      : null\n\n    this.id = hash(this)\n\n    this[_packument] = null\n    // memoized list of which versions are vulnerable\n    this[_versionVulnMemo] = new Map()\n    // memoized list of which dependency specs are vulnerable\n    this[_specVulnMemo] = new Map()\n    this[_updated] = false\n  }\n\n  // true if we updated from what we had in cache\n  get updated () {\n    return this[_updated]\n  }\n\n  get type () {\n    return this.dependency === this.name ? 'advisory' : 'metavuln'\n  }\n\n  get packument () {\n    return this[_packument]\n  }\n\n  // load up the data from a cache entry and a fetched packument\n  load (cached, packument) {\n    // basic data integrity gutcheck\n    if (!cached || typeof cached !== 'object')\n      throw new TypeError('invalid cached data, expected object')\n\n    if (!packument || typeof packument !== 'object')\n      throw new TypeError('invalid packument data, expected object')\n\n    if (cached.id && cached.id !== this.id) {\n      throw Object.assign(new Error('loading from incorrect cache entry'), {\n        expected: this.id,\n        actual: cached.id,\n      })\n    }\n    if (packument.name !== this.name) {\n      throw Object.assign(new Error('loading from incorrect packument'), {\n        expected: this.name,\n        actual: packument.name,\n      })\n    }\n    if (this[_packument])\n      throw new Error('advisory object already loaded')\n\n    // if we have a range from the initialization, and the cached\n    // data has a *different* range, then we know we have to recalc.\n    // just don't use the cached data, so we will definitely not match later\n    if (!this.range || cached.range && cached.range === this.range)\n      Object.assign(this, cached)\n\n    this[_packument] = packument\n\n    const pakuVersions = Object.keys(packument.versions)\n    const allVersions = new Set([...pakuVersions, ...this.versions])\n    const versionsAdded = []\n    const versionsRemoved = []\n    for (const v of allVersions) {\n      if (!this.versions.includes(v)) {\n        versionsAdded.push(v)\n        this.versions.push(v)\n      } else if (!pakuVersions.includes(v))\n        versionsRemoved.push(v)\n    }\n\n    // strip out any removed versions from our lists, and sort by semver\n    this.versions = semver.sort(this.versions.filter(v =>\n      !versionsRemoved.includes(v)), semverOpt)\n\n    // if no changes, then just return what we got from cache\n    // versions added or removed always means we changed\n    // otherwise, advisories change if the range changes, and\n    // metavulns change if the source was updated\n    const unchanged = this.type === 'advisory'\n      ? this.range && this.range === cached.range\n      : !this[_source].updated\n\n    // if the underlying source changed, by an advisory updating the\n    // range, or a source advisory being updated, then we have to re-check\n    // otherwise, only recheck the new ones.\n    this.vulnerableVersions = !unchanged ? []\n      : semver.sort(this.vulnerableVersions.filter(v =>\n        !versionsRemoved.includes(v)), semverOpt)\n\n    if (unchanged && !versionsAdded.length && !versionsRemoved.length) {\n      // nothing added or removed, nothing to do here.  use the cached copy.\n      return this\n    }\n\n    this[_updated] = true\n\n    // test any versions newly added\n    if (!unchanged || versionsAdded.length)\n      this[_testVersions](unchanged ? versionsAdded : this.versions)\n    this.vulnerableVersions = semver.sort(this.vulnerableVersions, semverOpt)\n\n    // metavulns have to calculate their range, since cache is invalidated\n    // advisories just get their range from the advisory above\n    if (this.type === 'metavuln')\n      this[_calculateRange]()\n\n    return this\n  }\n\n  [_calculateRange] () {\n    // calling semver.simplifyRange with a massive list of versions, and those\n    // versions all concatenated with `||` is a geometric CPU explosion!\n    // we can try to be a *little* smarter up front by doing x-y for all\n    // contiguous version sets in the list\n    const ranges = []\n    this.versions = semver.sort(this.versions)\n    this.vulnerableVersions = semver.sort(this.vulnerableVersions)\n    for (let v = 0, vulnVer = 0; v < this.versions.length; v++) {\n      // figure out the vulnerable subrange\n      const vr = [this.versions[v]]\n      while (v < this.versions.length) {\n        if (this.versions[v] !== this.vulnerableVersions[vulnVer]) {\n          // we don't test prerelease versions, so just skip past it\n          if (/-/.test(this.versions[v])) {\n            v++\n            continue\n          }\n          break\n        }\n        if (vr.length > 1)\n          vr[1] = this.versions[v]\n        else\n          vr.push(this.versions[v])\n        v++\n        vulnVer++\n      }\n      // it'll either be just the first version, which means no overlap,\n      // or the start and end versions, which might be the same version\n      if (vr.length > 1) {\n        const tail = this.versions[this.versions.length - 1]\n        ranges.push(vr[1] === tail ? `>=${vr[0]}`\n          : vr[0] === vr[1] ? vr[0]\n          : vr.join(' - '))\n      }\n    }\n    const metavuln = ranges.join(' || ').trim()\n    this.range = !metavuln ? '<0.0.0-0'\n      : semver.simplifyRange(this.versions, metavuln, semverOpt)\n  }\n\n  // returns true if marked as vulnerable, false if ok\n  // spec is a dependency specifier, for metavuln cases\n  // where the version might not be in the packument.  if\n  // we have the packument and spec is not provided, then\n  // we use the dependency version from the manifest.\n  testVersion (version, spec = null) {\n    const sv = String(version)\n    if (this[_versionVulnMemo].has(sv))\n      return this[_versionVulnMemo].get(sv)\n\n    const result = this[_testVersion](version, spec)\n    if (result)\n      this[_markVulnerable](version)\n    this[_versionVulnMemo].set(sv, !!result)\n    return result\n  }\n\n  [_markVulnerable] (version) {\n    const sv = String(version)\n    if (!this.vulnerableVersions.includes(sv))\n      this.vulnerableVersions.push(sv)\n  }\n\n  [_testVersion] (version, spec) {\n    const sv = String(version)\n    if (this.vulnerableVersions.includes(sv))\n      return true\n\n    if (this.type === 'advisory') {\n      // advisory, just test range\n      return semver.satisfies(version, this.range, semverOpt)\n    }\n\n    // check the dependency of this version on the vulnerable dep\n    // if we got a version that's not in the packument, fall back on\n    // the spec provided, if possible.\n    const mani = this[_packument].versions[version] || {\n      dependencies: {\n        [this.dependency]: spec,\n      },\n    }\n\n    if (!spec)\n      spec = getDepSpec(mani, this.dependency)\n\n    // no dep, no vuln\n    if (spec === null)\n      return false\n\n    if (!semver.validRange(spec, semverOpt)) {\n      // not a semver range, nothing we can hope to do about it\n      return true\n    }\n\n    const bd = mani.bundleDependencies\n    const bundled = bd && bd.includes(this[_source].name)\n    // XXX if bundled, then semver.intersects() means vulnerable\n    // else, pick a manifest and see if it can't be avoided\n    // try to pick a version of the dep that isn't vulnerable\n    const avoid = this[_source].range\n\n    if (bundled)\n      return semver.intersects(spec, avoid, semverOpt)\n\n    return this[_source].testSpec(spec)\n  }\n\n  testSpec (spec) {\n    // testing all the versions is a bit costly, and the spec tends to stay\n    // consistent across multiple versions, so memoize this as well, in case\n    // we're testing lots of versions.\n    const memo = this[_specVulnMemo]\n    if (memo.has(spec))\n      return memo.get(spec)\n\n    const res = this[_testSpec](spec)\n    memo.set(spec, res)\n    return res\n  }\n\n  [_testSpec] (spec) {\n    for (const v of this.versions) {\n      const satisfies = semver.satisfies(v, spec)\n      if (!satisfies)\n        continue\n      if (!this.testVersion(v))\n        return false\n    }\n    // either vulnerable, or not installable because nothing satisfied\n    // either way, best avoided.\n    return true\n  }\n\n  [_testVersions] (versions) {\n    if (!versions.length)\n      return\n\n    // set of lists of versions\n    const versionSets = new Set()\n    versions = semver.sort(versions.map(v => semver.parse(v, semverOpt)))\n\n    // start out with the versions grouped by major and minor\n    let last = versions[0].major + '.' + versions[0].minor\n    let list = []\n    versionSets.add(list)\n    for (const v of versions) {\n      const k = v.major + '.' + v.minor\n      if (k !== last) {\n        last = k\n        list = []\n        versionSets.add(list)\n      }\n      list.push(v)\n    }\n\n    for (const list of versionSets) {\n      // it's common to have version lists like:\n      // 1.0.0\n      // 1.0.1-alpha.0\n      // 1.0.1-alpha.1\n      // ...\n      // 1.0.1-alpha.999\n      // 1.0.1\n      // 1.0.2-alpha.0\n      // ...\n      // 1.0.2-alpha.99\n      // 1.0.2\n      // with a huge number of prerelease versions that are not installable\n      // anyway.\n      // If mid has a prerelease tag, and list[0] does not, then walk it\n      // back until we hit a non-prerelease version\n      // If mid has a prerelease tag, and list[list.length-1] does not,\n      // then walk it forward until we hit a version without a prerelease tag\n      // Similarly, if the head/tail is a prerelease, but there is a non-pr\n      // version in the list, then start there instead.\n      let h = 0\n      const origHeadVuln = this.testVersion(list[h])\n      while (h < list.length && /-/.test(String(list[h])))\n        h++\n\n      // don't filter out the whole list!  they might all be pr's\n      if (h === list.length)\n        h = 0\n      else if (origHeadVuln) {\n        // if the original was vulnerable, assume so are all of these\n        for (let hh = 0; hh < h; hh++)\n          this[_markVulnerable](list[hh])\n      }\n\n      let t = list.length - 1\n      const origTailVuln = this.testVersion(list[t])\n      while (t > h && /-/.test(String(list[t])))\n        t--\n\n      // don't filter out the whole list!  might all be pr's\n      if (t === h)\n        t = list.length - 1\n      else if (origTailVuln) {\n        // if original tail was vulnerable, assume these are as well\n        for (let tt = list.length - 1; tt > t; tt--)\n          this[_markVulnerable](list[tt])\n      }\n\n      const headVuln = h === 0 ? origHeadVuln\n        : this.testVersion(list[h])\n\n      const tailVuln = t === list.length - 1 ? origTailVuln\n        : this.testVersion(list[t])\n\n      // if head and tail both vulnerable, whole list is thrown out\n      if (headVuln && tailVuln) {\n        for (let v = h; v < t; v++)\n          this[_markVulnerable](list[v])\n        continue\n      }\n\n      // if length is 2 or 1, then we marked them all already\n      if (t < h + 2)\n        continue\n\n      const mid = Math.floor(list.length / 2)\n      const pre = list.slice(0, mid)\n      const post = list.slice(mid)\n\n      // if the parent list wasn't prereleases, then drop pr tags\n      // from end of the pre list, and beginning of the post list,\n      // marking as vulnerable if the midpoint item we picked is.\n      if (!/-/.test(String(pre[0]))) {\n        const midVuln = this.testVersion(pre[pre.length - 1])\n        while (/-/.test(String(pre[pre.length - 1]))) {\n          const v = pre.pop()\n          if (midVuln)\n            this[_markVulnerable](v)\n        }\n      }\n\n      if (!/-/.test(String(post[post.length - 1]))) {\n        const midVuln = this.testVersion(post[0])\n        while (/-/.test(String(post[0]))) {\n          const v = post.shift()\n          if (midVuln)\n            this[_markVulnerable](v)\n        }\n      }\n\n      versionSets.add(pre)\n      versionSets.add(post)\n    }\n  }\n}\n\nmodule.exports = Advisory\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}