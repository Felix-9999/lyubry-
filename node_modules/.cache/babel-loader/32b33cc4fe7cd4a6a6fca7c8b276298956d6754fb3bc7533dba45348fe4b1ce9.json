{"ast":null,"code":"// mixin implementing the reify method\n\nconst onExit = require('../signal-handling.js');\nconst pacote = require('pacote');\nconst AuditReport = require('../audit-report.js');\nconst {\n  subset,\n  intersects\n} = require('semver');\nconst npa = require('npm-package-arg');\nconst debug = require('../debug.js');\nconst walkUp = require('walk-up-path');\nconst {\n  dirname,\n  resolve,\n  relative\n} = require('path');\nconst {\n  depth: dfwalk\n} = require('treeverse');\nconst fs = require('fs');\nconst {\n  promisify\n} = require('util');\nconst lstat = promisify(fs.lstat);\nconst symlink = promisify(fs.symlink);\nconst mkdirp = require('mkdirp-infer-owner');\nconst justMkdirp = require('mkdirp');\nconst moveFile = require('@npmcli/move-file');\nconst rimraf = promisify(require('rimraf'));\nconst PackageJson = require('@npmcli/package-json');\nconst packageContents = require('@npmcli/installed-package-contents');\nconst {\n  checkEngine,\n  checkPlatform\n} = require('npm-install-checks');\nconst _force = Symbol.for('force');\nconst treeCheck = require('../tree-check.js');\nconst relpath = require('../relpath.js');\nconst Diff = require('../diff.js');\nconst retirePath = require('../retire-path.js');\nconst promiseAllRejectLate = require('promise-all-reject-late');\nconst optionalSet = require('../optional-set.js');\nconst calcDepFlags = require('../calc-dep-flags.js');\nconst {\n  saveTypeMap,\n  hasSubKey\n} = require('../add-rm-pkg-deps.js');\nconst _retiredPaths = Symbol('retiredPaths');\nconst _retiredUnchanged = Symbol('retiredUnchanged');\nconst _sparseTreeDirs = Symbol('sparseTreeDirs');\nconst _sparseTreeRoots = Symbol('sparseTreeRoots');\nconst _savePrefix = Symbol('savePrefix');\nconst _retireShallowNodes = Symbol.for('retireShallowNodes');\nconst _getBundlesByDepth = Symbol('getBundlesByDepth');\nconst _registryResolved = Symbol('registryResolved');\nconst _addNodeToTrashList = Symbol('addNodeToTrashList');\nconst _workspaces = Symbol.for('workspaces');\n\n// shared by rebuild mixin\nconst _trashList = Symbol.for('trashList');\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure');\nconst _loadTrees = Symbol.for('loadTrees');\n\n// shared symbols for swapping out when testing\nconst _diffTrees = Symbol.for('diffTrees');\nconst _createSparseTree = Symbol.for('createSparseTree');\nconst _loadShrinkwrapsAndUpdateTrees = Symbol.for('loadShrinkwrapsAndUpdateTrees');\nconst _shrinkwrapInflated = Symbol('shrinkwrapInflated');\nconst _bundleUnpacked = Symbol('bundleUnpacked');\nconst _bundleMissing = Symbol('bundleMissing');\nconst _reifyNode = Symbol.for('reifyNode');\nconst _extractOrLink = Symbol('extractOrLink');\n// defined by rebuild mixin\nconst _checkBins = Symbol.for('checkBins');\nconst _symlink = Symbol('symlink');\nconst _warnDeprecated = Symbol('warnDeprecated');\nconst _loadBundlesAndUpdateTrees = Symbol.for('loadBundlesAndUpdateTrees');\nconst _submitQuickAudit = Symbol('submitQuickAudit');\nconst _awaitQuickAudit = Symbol('awaitQuickAudit');\nconst _unpackNewModules = Symbol.for('unpackNewModules');\nconst _moveContents = Symbol.for('moveContents');\nconst _moveBackRetiredUnchanged = Symbol.for('moveBackRetiredUnchanged');\nconst _build = Symbol.for('build');\nconst _removeTrash = Symbol.for('removeTrash');\nconst _renamePath = Symbol.for('renamePath');\nconst _rollbackRetireShallowNodes = Symbol.for('rollbackRetireShallowNodes');\nconst _rollbackCreateSparseTree = Symbol.for('rollbackCreateSparseTree');\nconst _rollbackMoveBackRetiredUnchanged = Symbol.for('rollbackMoveBackRetiredUnchanged');\nconst _saveIdealTree = Symbol.for('saveIdealTree');\nconst _saveLockFile = Symbol('saveLockFile');\nconst _copyIdealToActual = Symbol('copyIdealToActual');\nconst _addOmitsToTrashList = Symbol('addOmitsToTrashList');\nconst _packageLockOnly = Symbol('packageLockOnly');\nconst _dryRun = Symbol('dryRun');\nconst _validateNodeModules = Symbol('validateNodeModules');\nconst _nmValidated = Symbol('nmValidated');\nconst _validatePath = Symbol('validatePath');\nconst _reifyPackages = Symbol.for('reifyPackages');\nconst _omitDev = Symbol('omitDev');\nconst _omitOptional = Symbol('omitOptional');\nconst _omitPeer = Symbol('omitPeer');\nconst _global = Symbol.for('global');\nconst _pruneBundledMetadeps = Symbol('pruneBundledMetadeps');\n\n// defined by Ideal mixin\nconst _resolvedAdd = Symbol.for('resolvedAdd');\nconst _usePackageLock = Symbol.for('usePackageLock');\nconst _formatPackageLock = Symbol.for('formatPackageLock');\nmodule.exports = cls => class Reifier extends cls {\n  constructor(options) {\n    super(options);\n    const {\n      savePrefix = '^',\n      packageLockOnly = false,\n      dryRun = false,\n      formatPackageLock = true\n    } = options;\n    this[_dryRun] = !!dryRun;\n    this[_packageLockOnly] = !!packageLockOnly;\n    this[_savePrefix] = savePrefix;\n    this[_formatPackageLock] = !!formatPackageLock;\n    this.diff = null;\n    this[_retiredPaths] = {};\n    this[_shrinkwrapInflated] = new Set();\n    this[_retiredUnchanged] = {};\n    this[_sparseTreeDirs] = new Set();\n    this[_sparseTreeRoots] = new Set();\n    this[_trashList] = new Set();\n    // the nodes we unpack to read their bundles\n    this[_bundleUnpacked] = new Set();\n    // child nodes we'd EXPECT to be included in a bundle, but aren't\n    this[_bundleMissing] = new Set();\n    this[_nmValidated] = new Set();\n  }\n\n  // public method\n  async reify(options = {}) {\n    if (this[_packageLockOnly] && this[_global]) {\n      const er = new Error('cannot generate lockfile for global packages');\n      er.code = 'ESHRINKWRAPGLOBAL';\n      throw er;\n    }\n    const omit = new Set(options.omit || []);\n    this[_omitDev] = omit.has('dev');\n    this[_omitOptional] = omit.has('optional');\n    this[_omitPeer] = omit.has('peer');\n\n    // start tracker block\n    this.addTracker('reify');\n    process.emit('time', 'reify');\n    await this[_validatePath]();\n    await this[_loadTrees](options);\n    await this[_diffTrees]();\n    await this[_reifyPackages]();\n    await this[_saveIdealTree](options);\n    await this[_copyIdealToActual]();\n    await this[_awaitQuickAudit]();\n    this.finishTracker('reify');\n    process.emit('timeEnd', 'reify');\n    return treeCheck(this.actualTree);\n  }\n  async [_validatePath]() {\n    // don't create missing dirs on dry runs\n    if (this[_packageLockOnly] || this[_dryRun]) {\n      return;\n    }\n\n    // we do NOT want to set ownership on this folder, especially\n    // recursively, because it can have other side effects to do that\n    // in a project directory.  We just want to make it if it's missing.\n    await justMkdirp(resolve(this.path));\n\n    // do not allow the top-level node_modules to be a symlink\n    await this[_validateNodeModules](resolve(this.path, 'node_modules'));\n  }\n  async [_reifyPackages]() {\n    // we don't submit the audit report or write to disk on dry runs\n    if (this[_dryRun]) {\n      return;\n    }\n    if (this[_packageLockOnly]) {\n      // we already have the complete tree, so just audit it now,\n      // and that's all we have to do here.\n      return this[_submitQuickAudit]();\n    }\n\n    // ok, we're about to start touching the fs.  need to roll back\n    // if we get an early termination.\n    let reifyTerminated = null;\n    const removeHandler = onExit(({\n      signal\n    }) => {\n      // only call once.  if signal hits twice, we just terminate\n      removeHandler();\n      reifyTerminated = Object.assign(new Error('process terminated'), {\n        signal\n      });\n      return false;\n    });\n\n    // [rollbackfn, [...actions]]\n    // after each step, if the process was terminated, execute the rollback\n    // note that each rollback *also* calls the previous one when it's\n    // finished, and then the first one throws the error, so we only need\n    // a new rollback step when we have a new thing that must be done to\n    // revert the install.\n    const steps = [[_rollbackRetireShallowNodes, [_retireShallowNodes]], [_rollbackCreateSparseTree, [_createSparseTree, _addOmitsToTrashList, _loadShrinkwrapsAndUpdateTrees, _loadBundlesAndUpdateTrees, _submitQuickAudit, _unpackNewModules]], [_rollbackMoveBackRetiredUnchanged, [_moveBackRetiredUnchanged, _build]]];\n    for (const [rollback, actions] of steps) {\n      for (const action of actions) {\n        try {\n          await this[action]();\n          if (reifyTerminated) {\n            throw reifyTerminated;\n          }\n        } catch (er) {\n          await this[rollback](er);\n          /* istanbul ignore next - rollback throws, should never hit this */\n          throw er;\n        }\n      }\n    }\n\n    // no rollback for this one, just exit with the error, since the\n    // install completed and can't be safely recovered at this point.\n    await this[_removeTrash]();\n    if (reifyTerminated) {\n      throw reifyTerminated;\n    }\n\n    // done modifying the file system, no need to keep listening for sigs\n    removeHandler();\n  }\n\n  // when doing a local install, we load everything and figure it all out.\n  // when doing a global install, we *only* care about the explicit requests.\n  [_loadTrees](options) {\n    process.emit('time', 'reify:loadTrees');\n    const bitOpt = {\n      ...options,\n      complete: this[_packageLockOnly] || this[_dryRun]\n    };\n\n    // if we're only writing a package lock, then it doesn't matter what's here\n    if (this[_packageLockOnly]) {\n      return this.buildIdealTree(bitOpt).then(() => process.emit('timeEnd', 'reify:loadTrees'));\n    }\n    const actualOpt = this[_global] ? {\n      ignoreMissing: true,\n      global: true,\n      filter: (node, kid) => {\n        // if it's not the project root, and we have no explicit requests,\n        // then we're already into a nested dep, so we keep it\n        if (this.explicitRequests.size === 0 || !node.isProjectRoot) {\n          return true;\n        }\n\n        // if we added it as an edgeOut, then we want it\n        if (this.idealTree.edgesOut.has(kid)) {\n          return true;\n        }\n\n        // if it's an explicit request, then we want it\n        const hasExplicit = [...this.explicitRequests].some(edge => edge.name === kid);\n        if (hasExplicit) {\n          return true;\n        }\n\n        // ignore the rest of the global install folder\n        return false;\n      }\n    } : {\n      ignoreMissing: true\n    };\n    if (!this[_global]) {\n      return Promise.all([this.loadActual(actualOpt), this.buildIdealTree(bitOpt)]).then(() => process.emit('timeEnd', 'reify:loadTrees'));\n    }\n\n    // the global install space tends to have a lot of stuff in it.  don't\n    // load all of it, just what we care about.  we won't be saving a\n    // hidden lockfile in there anyway.  Note that we have to load ideal\n    // BEFORE loading actual, so that the actualOpt can use the\n    // explicitRequests which is set during buildIdealTree\n    return this.buildIdealTree(bitOpt).then(() => this.loadActual(actualOpt)).then(() => process.emit('timeEnd', 'reify:loadTrees'));\n  }\n  [_diffTrees]() {\n    if (this[_packageLockOnly]) {\n      return;\n    }\n    process.emit('time', 'reify:diffTrees');\n    // XXX if we have an existing diff already, there should be a way\n    // to just invalidate the parts that changed, but avoid walking the\n    // whole tree again.\n\n    const filterNodes = [];\n    if (this[_global] && this.explicitRequests.size) {\n      const idealTree = this.idealTree.target;\n      const actualTree = this.actualTree.target;\n      // we ONLY are allowed to make changes in the global top-level\n      // children where there's an explicit request.\n      for (const {\n        name\n      } of this.explicitRequests) {\n        const ideal = idealTree.children.get(name);\n        if (ideal) {\n          filterNodes.push(ideal);\n        }\n        const actual = actualTree.children.get(name);\n        if (actual) {\n          filterNodes.push(actual);\n        }\n      }\n    } else {\n      for (const ws of this[_workspaces]) {\n        const ideal = this.idealTree.children.get(ws);\n        if (ideal) {\n          filterNodes.push(ideal);\n        }\n        const actual = this.actualTree.children.get(ws);\n        if (actual) {\n          filterNodes.push(actual);\n        }\n      }\n    }\n\n    // find all the nodes that need to change between the actual\n    // and ideal trees.\n    this.diff = Diff.calculate({\n      shrinkwrapInflated: this[_shrinkwrapInflated],\n      filterNodes,\n      actual: this.actualTree,\n      ideal: this.idealTree\n    });\n\n    // we don't have to add 'removed' folders to the trashlist, because\n    // they'll be moved aside to a retirement folder, and then the retired\n    // folder will be deleted at the end.  This is important when we have\n    // a folder like FOO being \"removed\" in favor of a folder like \"foo\",\n    // because if we remove node_modules/FOO on case-insensitive systems,\n    // it will remove the dep that we *want* at node_modules/foo.\n\n    process.emit('timeEnd', 'reify:diffTrees');\n  }\n\n  // add the node and all its bins to the list of things to be\n  // removed later on in the process.  optionally, also mark them\n  // as a retired paths, so that we move them out of the way and\n  // replace them when rolling back on failure.\n  [_addNodeToTrashList](node, retire = false) {\n    const paths = [node.path, ...node.binPaths];\n    const moves = this[_retiredPaths];\n    this.log.silly('reify', 'mark', retire ? 'retired' : 'deleted', paths);\n    for (const path of paths) {\n      if (retire) {\n        const retired = retirePath(path);\n        moves[path] = retired;\n        this[_trashList].add(retired);\n      } else {\n        this[_trashList].add(path);\n      }\n    }\n  }\n\n  // move aside the shallowest nodes in the tree that have to be\n  // changed or removed, so that we can rollback if necessary.\n  [_retireShallowNodes]() {\n    process.emit('time', 'reify:retireShallow');\n    const moves = this[_retiredPaths] = {};\n    for (const diff of this.diff.children) {\n      if (diff.action === 'CHANGE' || diff.action === 'REMOVE') {\n        // we'll have to clean these up at the end, so add them to the list\n        this[_addNodeToTrashList](diff.actual, true);\n      }\n    }\n    this.log.silly('reify', 'moves', moves);\n    const movePromises = Object.entries(moves).map(([from, to]) => this[_renamePath](from, to));\n    return promiseAllRejectLate(movePromises).then(() => process.emit('timeEnd', 'reify:retireShallow'));\n  }\n  [_renamePath](from, to, didMkdirp = false) {\n    return moveFile(from, to).catch(er => {\n      // Occasionally an expected bin file might not exist in the package,\n      // or a shim/symlink might have been moved aside.  If we've already\n      // handled the most common cause of ENOENT (dir doesn't exist yet),\n      // then just ignore any ENOENT.\n      if (er.code === 'ENOENT') {\n        return didMkdirp ? null : mkdirp(dirname(to)).then(() => this[_renamePath](from, to, true));\n      } else if (er.code === 'EEXIST') {\n        return rimraf(to).then(() => moveFile(from, to));\n      } else {\n        throw er;\n      }\n    });\n  }\n  [_rollbackRetireShallowNodes](er) {\n    process.emit('time', 'reify:rollback:retireShallow');\n    const moves = this[_retiredPaths];\n    const movePromises = Object.entries(moves).map(([from, to]) => this[_renamePath](to, from));\n    return promiseAllRejectLate(movePromises)\n    // ignore subsequent rollback errors\n    .catch(er => {}).then(() => process.emit('timeEnd', 'reify:rollback:retireShallow')).then(() => {\n      throw er;\n    });\n  }\n\n  // adding to the trash list will skip reifying, and delete them\n  // if they are currently in the tree and otherwise untouched.\n  [_addOmitsToTrashList]() {\n    if (!this[_omitDev] && !this[_omitOptional] && !this[_omitPeer]) {\n      return;\n    }\n    process.emit('time', 'reify:trashOmits');\n    const filter = node => node.top.isProjectRoot && (node.peer && this[_omitPeer] || node.dev && this[_omitDev] || node.optional && this[_omitOptional] || node.devOptional && this[_omitOptional] && this[_omitDev]);\n    for (const node of this.idealTree.inventory.filter(filter)) {\n      this[_addNodeToTrashList](node);\n    }\n    process.emit('timeEnd', 'reify:trashOmits');\n  }\n  [_createSparseTree]() {\n    process.emit('time', 'reify:createSparse');\n    // if we call this fn again, we look for the previous list\n    // so that we can avoid making the same directory multiple times\n    const leaves = this.diff.leaves.filter(diff => {\n      return (diff.action === 'ADD' || diff.action === 'CHANGE') && !this[_sparseTreeDirs].has(diff.ideal.path) && !diff.ideal.isLink;\n    }).map(diff => diff.ideal);\n\n    // we check this in parallel, so guard against multiple attempts to\n    // retire the same path at the same time.\n    const dirsChecked = new Set();\n    return promiseAllRejectLate(leaves.map(async node => {\n      for (const d of walkUp(node.path)) {\n        if (d === node.top.path) {\n          break;\n        }\n        if (dirsChecked.has(d)) {\n          continue;\n        }\n        dirsChecked.add(d);\n        const st = await lstat(d).catch(er => null);\n        // this can happen if we have a link to a package with a name\n        // that the filesystem treats as if it is the same thing.\n        // would be nice to have conditional istanbul ignores here...\n        /* istanbul ignore next - defense in depth */\n        if (st && !st.isDirectory()) {\n          const retired = retirePath(d);\n          this[_retiredPaths][d] = retired;\n          this[_trashList].add(retired);\n          await this[_renamePath](d, retired);\n        }\n      }\n      const made = await mkdirp(node.path);\n      this[_sparseTreeDirs].add(node.path);\n      this[_sparseTreeRoots].add(made);\n    })).then(() => process.emit('timeEnd', 'reify:createSparse'));\n  }\n  [_rollbackCreateSparseTree](er) {\n    process.emit('time', 'reify:rollback:createSparse');\n    // cut the roots of the sparse tree that were created, not the leaves\n    const roots = this[_sparseTreeRoots];\n    // also delete the moves that we retired, so that we can move them back\n    const failures = [];\n    const targets = [...roots, ...Object.keys(this[_retiredPaths])];\n    const unlinks = targets.map(path => rimraf(path).catch(er => failures.push([path, er])));\n    return promiseAllRejectLate(unlinks).then(() => {\n      if (failures.length) {\n        this.log.warn('cleanup', 'Failed to remove some directories', failures);\n      }\n    }).then(() => process.emit('timeEnd', 'reify:rollback:createSparse')).then(() => this[_rollbackRetireShallowNodes](er));\n  }\n\n  // shrinkwrap nodes define their dependency branches with a file, so\n  // we need to unpack them, read that shrinkwrap file, and then update\n  // the tree by calling loadVirtual with the node as the root.\n  [_loadShrinkwrapsAndUpdateTrees]() {\n    const seen = this[_shrinkwrapInflated];\n    const shrinkwraps = this.diff.leaves.filter(d => (d.action === 'CHANGE' || d.action === 'ADD' || !d.action) && d.ideal.hasShrinkwrap && !seen.has(d.ideal) && !this[_trashList].has(d.ideal.path));\n    if (!shrinkwraps.length) {\n      return;\n    }\n    process.emit('time', 'reify:loadShrinkwraps');\n    const Arborist = this.constructor;\n    return promiseAllRejectLate(shrinkwraps.map(diff => {\n      const node = diff.ideal;\n      seen.add(node);\n      return diff.action ? this[_reifyNode](node) : node;\n    })).then(nodes => promiseAllRejectLate(nodes.map(node => new Arborist({\n      ...this.options,\n      path: node.path\n    }).loadVirtual({\n      root: node\n    }))))\n    // reload the diff and sparse tree because the ideal tree changed\n    .then(() => this[_diffTrees]()).then(() => this[_createSparseTree]()).then(() => this[_addOmitsToTrashList]()).then(() => this[_loadShrinkwrapsAndUpdateTrees]()).then(() => process.emit('timeEnd', 'reify:loadShrinkwraps'));\n  }\n\n  // create a symlink for Links, extract for Nodes\n  // return the node object, since we usually want that\n  // handle optional dep failures here\n  // If node is in trash list, skip it\n  // If reifying fails, and the node is optional, add it and its optionalSet\n  // to the trash list\n  // Always return the node.\n  [_reifyNode](node) {\n    if (this[_trashList].has(node.path)) {\n      return node;\n    }\n    const timer = `reifyNode:${node.location}`;\n    process.emit('time', timer);\n    this.addTracker('reify', node.name, node.location);\n    const {\n      npmVersion,\n      nodeVersion\n    } = this.options;\n    const p = Promise.resolve().then(async () => {\n      // when we reify an optional node, check the engine and platform\n      // first. be sure to ignore the --force and --engine-strict flags,\n      // since we always want to skip any optional packages we can't install.\n      // these checks throwing will result in a rollback and removal\n      // of the mismatches\n      if (node.optional) {\n        checkEngine(node.package, npmVersion, nodeVersion, false);\n        checkPlatform(node.package, false);\n      }\n      await this[_checkBins](node);\n      await this[_extractOrLink](node);\n      await this[_warnDeprecated](node);\n    });\n    return this[_handleOptionalFailure](node, p).then(() => {\n      this.finishTracker('reify', node.name, node.location);\n      process.emit('timeEnd', timer);\n      return node;\n    });\n  }\n\n  // do not allow node_modules to be a symlink\n  async [_validateNodeModules](nm) {\n    if (this[_force] || this[_nmValidated].has(nm)) {\n      return;\n    }\n    const st = await lstat(nm).catch(() => null);\n    if (!st || st.isDirectory()) {\n      this[_nmValidated].add(nm);\n      return;\n    }\n    this.log.warn('reify', 'Removing non-directory', nm);\n    await rimraf(nm);\n  }\n  async [_extractOrLink](node) {\n    // in normal cases, node.resolved should *always* be set by now.\n    // however, it is possible when a lockfile is damaged, or very old,\n    // or in some other race condition bugs in npm v6, that a previously\n    // bundled dependency will have just a version, but no resolved value,\n    // and no 'bundled: true' setting.\n    // Do the best with what we have, or else remove it from the tree\n    // entirely, since we can't possibly reify it.\n    const res = node.resolved ? `${node.name}@${this[_registryResolved](node.resolved)}` : node.packageName && node.version ? `${node.packageName}@${node.version}` : null;\n\n    // no idea what this thing is.  remove it from the tree.\n    if (!res) {\n      const warning = 'invalid or damaged lockfile detected\\n' + 'please re-try this operation once it completes\\n' + 'so that the damage can be corrected, or perform\\n' + 'a fresh install with no lockfile if the problem persists.';\n      this.log.warn('reify', warning);\n      this.log.verbose('reify', 'unrecognized node in tree', node.path);\n      node.parent = null;\n      node.fsParent = null;\n      this[_addNodeToTrashList](node);\n      return;\n    }\n    const nm = resolve(node.parent.path, 'node_modules');\n    await this[_validateNodeModules](nm);\n    if (node.isLink) {\n      await rimraf(node.path);\n      await this[_symlink](node);\n    } else {\n      await debug(async () => {\n        const st = await lstat(node.path).catch(e => null);\n        if (st && !st.isDirectory()) {\n          debug.log('unpacking into a non-directory', node);\n          throw Object.assign(new Error('ENOTDIR: not a directory'), {\n            code: 'ENOTDIR',\n            path: node.path\n          });\n        }\n      });\n      await pacote.extract(res, node.path, {\n        ...this.options,\n        resolved: node.resolved,\n        integrity: node.integrity\n      });\n    }\n  }\n  async [_symlink](node) {\n    const dir = dirname(node.path);\n    const target = node.realpath;\n    const rel = relative(dir, target);\n    await mkdirp(dir);\n    return symlink(rel, node.path, 'junction');\n  }\n  [_warnDeprecated](node) {\n    const {\n      _id,\n      deprecated\n    } = node.package;\n    if (deprecated) {\n      this.log.warn('deprecated', `${_id}: ${deprecated}`);\n    }\n  }\n\n  // if the node is optional, then the failure of the promise is nonfatal\n  // just add it and its optional set to the trash list.\n  [_handleOptionalFailure](node, p) {\n    return (node.optional ? p.catch(er => {\n      const set = optionalSet(node);\n      for (node of set) {\n        this.log.verbose('reify', 'failed optional dependency', node.path);\n        this[_addNodeToTrashList](node);\n      }\n    }) : p).then(() => node);\n  }\n  [_registryResolved](resolved) {\n    // the default registry url is a magic value meaning \"the currently\n    // configured registry\".\n    //\n    // XXX: use a magic string that isn't also a valid value, like\n    // ${REGISTRY} or something.  This has to be threaded through the\n    // Shrinkwrap and Node classes carefully, so for now, just treat\n    // the default reg as the magical animal that it has been.\n    return resolved && resolved.replace(/^https?:\\/\\/registry.npmjs.org\\//, this.registry);\n  }\n\n  // bundles are *sort of* like shrinkwraps, in that the branch is defined\n  // by the contents of the package.  however, in their case, rather than\n  // shipping a virtual tree that must be reified, they ship an entire\n  // reified actual tree that must be unpacked and not modified.\n  [_loadBundlesAndUpdateTrees](depth = 0, bundlesByDepth = this[_getBundlesByDepth]()) {\n    if (depth === 0) {\n      process.emit('time', 'reify:loadBundles');\n    }\n    const maxBundleDepth = bundlesByDepth.get('maxBundleDepth');\n    if (depth > maxBundleDepth) {\n      // if we did something, then prune the tree and update the diffs\n      if (maxBundleDepth !== -1) {\n        this[_pruneBundledMetadeps](bundlesByDepth);\n        this[_diffTrees]();\n      }\n      process.emit('timeEnd', 'reify:loadBundles');\n      return;\n    }\n\n    // skip any that have since been removed from the tree, eg by a\n    // shallower bundle overwriting them with a bundled meta-dep.\n    const set = (bundlesByDepth.get(depth) || []).filter(node => node.root === this.idealTree && node.target !== node.root && !this[_trashList].has(node.path));\n    if (!set.length) {\n      return this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth);\n    }\n\n    // extract all the nodes with bundles\n    return promiseAllRejectLate(set.map(node => {\n      this[_bundleUnpacked].add(node);\n      return this[_reifyNode](node);\n    }))\n    // then load their unpacked children and move into the ideal tree\n    .then(nodes => promiseAllRejectLate(nodes.map(async node => {\n      const arb = new this.constructor({\n        ...this.options,\n        path: node.path\n      });\n      const notTransplanted = new Set(node.children.keys());\n      await arb.loadActual({\n        root: node,\n        // don't transplant any sparse folders we created\n        // loadActual will set node.package to {} for empty directories\n        // if by chance there are some empty folders in the node_modules\n        // tree for some other reason, then ok, ignore those too.\n        transplantFilter: node => {\n          if (node.package._id) {\n            // it's actually in the bundle if it gets transplanted\n            notTransplanted.delete(node.name);\n            return true;\n          } else {\n            return false;\n          }\n        }\n      });\n      for (const name of notTransplanted) {\n        this[_bundleMissing].add(node.children.get(name));\n      }\n    })))\n    // move onto the next level of bundled items\n    .then(() => this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth));\n  }\n  [_getBundlesByDepth]() {\n    const bundlesByDepth = new Map();\n    let maxBundleDepth = -1;\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        const node = diff.ideal;\n        if (!node) {\n          return;\n        }\n        if (node.isProjectRoot) {\n          return;\n        }\n        const {\n          bundleDependencies\n        } = node.package;\n        if (bundleDependencies && bundleDependencies.length) {\n          maxBundleDepth = Math.max(maxBundleDepth, node.depth);\n          if (!bundlesByDepth.has(node.depth)) {\n            bundlesByDepth.set(node.depth, [node]);\n          } else {\n            bundlesByDepth.get(node.depth).push(node);\n          }\n        }\n      },\n      getChildren: diff => diff.children\n    });\n    bundlesByDepth.set('maxBundleDepth', maxBundleDepth);\n    return bundlesByDepth;\n  }\n\n  // https://github.com/npm/cli/issues/1597#issuecomment-667639545\n  [_pruneBundledMetadeps](bundlesByDepth) {\n    const bundleShadowed = new Set();\n\n    // Example dep graph:\n    // root -> (a, c)\n    // a -> BUNDLE(b)\n    // b -> c\n    // c -> b\n    //\n    // package tree:\n    // root\n    // +-- a\n    // |   +-- b(1)\n    // |   +-- c(1)\n    // +-- b(2)\n    // +-- c(2)\n    // 1. mark everything that's shadowed by anything in the bundle.  This\n    //    marks b(2) and c(2).\n    // 2. anything with edgesIn from outside the set, mark not-extraneous,\n    //    remove from set.  This unmarks c(2).\n    // 3. continue until no change\n    // 4. remove everything in the set from the tree.  b(2) is pruned\n\n    // create the list of nodes shadowed by children of bundlers\n    for (const bundles of bundlesByDepth.values()) {\n      // skip the 'maxBundleDepth' item\n      if (!Array.isArray(bundles)) {\n        continue;\n      }\n      for (const node of bundles) {\n        for (const name of node.children.keys()) {\n          const shadow = node.parent.resolve(name);\n          if (!shadow) {\n            continue;\n          }\n          bundleShadowed.add(shadow);\n          shadow.extraneous = true;\n        }\n      }\n    }\n\n    // lib -> (a@1.x) BUNDLE(a@1.2.3 (b@1.2.3))\n    // a@1.2.3 -> (b@1.2.3)\n    // a@1.3.0 -> (b@2)\n    // b@1.2.3 -> ()\n    // b@2 -> (c@2)\n    //\n    // root\n    // +-- lib\n    // |   +-- a@1.2.3\n    // |   +-- b@1.2.3\n    // +-- b@2 <-- shadowed, now extraneous\n    // +-- c@2 <-- also shadowed, because only dependent is shadowed\n    for (const shadow of bundleShadowed) {\n      for (const shadDep of shadow.edgesOut.values()) {\n        /* istanbul ignore else - pretty unusual situation, just being\n         * defensive here. Would mean that a bundled dep has a dependency\n         * that is unmet. which, weird, but if you bundle it, we take\n         * whatever you put there and assume the publisher knows best. */\n        if (shadDep.to) {\n          bundleShadowed.add(shadDep.to);\n          shadDep.to.extraneous = true;\n        }\n      }\n    }\n    let changed;\n    do {\n      changed = false;\n      for (const shadow of bundleShadowed) {\n        for (const edge of shadow.edgesIn) {\n          if (!bundleShadowed.has(edge.from)) {\n            shadow.extraneous = false;\n            bundleShadowed.delete(shadow);\n            changed = true;\n            break;\n          }\n        }\n      }\n    } while (changed);\n    for (const shadow of bundleShadowed) {\n      this[_addNodeToTrashList](shadow);\n      shadow.root = null;\n    }\n  }\n  [_submitQuickAudit]() {\n    if (this.options.audit === false) {\n      return this.auditReport = null;\n    }\n\n    // we submit the quick audit at this point in the process, as soon as\n    // we have all the deps resolved, so that it can overlap with the other\n    // actions as much as possible.  Stash the promise, which we resolve\n    // before finishing the reify() and returning the tree.  Thus, we do\n    // NOT return the promise, as the intent is for this to run in parallel\n    // with the reification, and be resolved at a later time.\n    process.emit('time', 'reify:audit');\n    const options = {\n      ...this.options\n    };\n    const tree = this.idealTree;\n\n    // if we're operating on a workspace, only audit the workspace deps\n    if (this[_workspaces] && this[_workspaces].length) {\n      options.filterSet = this.workspaceDependencySet(tree, this[_workspaces]);\n    }\n    this.auditReport = AuditReport.load(tree, options).then(res => {\n      process.emit('timeEnd', 'reify:audit');\n      this.auditReport = res;\n    });\n  }\n\n  // return the promise if we're waiting for it, or the replaced result\n  [_awaitQuickAudit]() {\n    return this.auditReport;\n  }\n\n  // ok!  actually unpack stuff into their target locations!\n  // The sparse tree has already been created, so we walk the diff\n  // kicking off each unpack job.  If any fail, we rimraf the sparse\n  // tree entirely and try to put everything back where it was.\n  [_unpackNewModules]() {\n    process.emit('time', 'reify:unpack');\n    const unpacks = [];\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        // no unpacking if we don't want to change this thing\n        if (diff.action !== 'CHANGE' && diff.action !== 'ADD') {\n          return;\n        }\n        const node = diff.ideal;\n        const bd = this[_bundleUnpacked].has(node);\n        const sw = this[_shrinkwrapInflated].has(node);\n        const bundleMissing = this[_bundleMissing].has(node);\n\n        // check whether we still need to unpack this one.\n        // test the inDepBundle last, since that's potentially a tree walk.\n        const doUnpack = node &&\n        // can't unpack if removed!\n        // root node already exists\n        !node.isRoot &&\n        // already unpacked to read bundle\n        !bd &&\n        // already unpacked to read sw\n        !sw && (\n        // already unpacked by another dep's bundle\n        bundleMissing || !node.inDepBundle);\n        if (doUnpack) {\n          unpacks.push(this[_reifyNode](node));\n        }\n      },\n      getChildren: diff => diff.children\n    });\n    return promiseAllRejectLate(unpacks).then(() => process.emit('timeEnd', 'reify:unpack'));\n  }\n\n  // This is the part where we move back the unchanging nodes that were\n  // the children of a node that did change.  If this fails, the rollback\n  // is a three-step process.  First, we try to move the retired unchanged\n  // nodes BACK to their retirement folders, then delete the sparse tree,\n  // then move everything out of retirement.\n  [_moveBackRetiredUnchanged]() {\n    // get a list of all unchanging children of any shallow retired nodes\n    // if they are not the ancestor of any node in the diff set, then the\n    // directory won't already exist, so just rename it over.\n    // This is sort of an inverse diff tree, of all the nodes where\n    // the actualTree and idealTree _don't_ differ, starting from the\n    // shallowest nodes that we moved aside in the first place.\n    process.emit('time', 'reify:unretire');\n    const moves = this[_retiredPaths];\n    this[_retiredUnchanged] = {};\n    return promiseAllRejectLate(this.diff.children.map(diff => {\n      // skip if nothing was retired\n      if (diff.action !== 'CHANGE' && diff.action !== 'REMOVE') {\n        return;\n      }\n      const {\n        path: realFolder\n      } = diff.actual;\n      const retireFolder = moves[realFolder];\n      /* istanbul ignore next - should be impossible */\n      debug(() => {\n        if (!retireFolder) {\n          const er = new Error('trying to un-retire but not retired');\n          throw Object.assign(er, {\n            realFolder,\n            retireFolder,\n            actual: diff.actual,\n            ideal: diff.ideal,\n            action: diff.action\n          });\n        }\n      });\n      this[_retiredUnchanged][retireFolder] = [];\n      return promiseAllRejectLate(diff.unchanged.map(node => {\n        // no need to roll back links, since we'll just delete them anyway\n        if (node.isLink) {\n          return mkdirp(dirname(node.path)).then(() => this[_reifyNode](node));\n        }\n\n        // will have been moved/unpacked along with bundler\n        if (node.inDepBundle && !this[_bundleMissing].has(node)) {\n          return;\n        }\n        this[_retiredUnchanged][retireFolder].push(node);\n        const rel = relative(realFolder, node.path);\n        const fromPath = resolve(retireFolder, rel);\n        // if it has bundleDependencies, then make node_modules.  otherwise\n        // skip it.\n        const bd = node.package.bundleDependencies;\n        const dir = bd && bd.length ? node.path + '/node_modules' : node.path;\n        return mkdirp(dir).then(() => this[_moveContents](node, fromPath));\n      }));\n    })).then(() => process.emit('timeEnd', 'reify:unretire'));\n  }\n\n  // move the contents from the fromPath to the node.path\n  [_moveContents](node, fromPath) {\n    return packageContents({\n      path: fromPath,\n      depth: 1,\n      packageJsonCache: new Map([[fromPath + '/package.json', node.package]])\n    }).then(res => promiseAllRejectLate(res.map(path => {\n      const rel = relative(fromPath, path);\n      const to = resolve(node.path, rel);\n      return this[_renamePath](path, to);\n    })));\n  }\n  [_rollbackMoveBackRetiredUnchanged](er) {\n    const moves = this[_retiredPaths];\n    // flip the mapping around to go back\n    const realFolders = new Map(Object.entries(moves).map(([k, v]) => [v, k]));\n    const promises = Object.entries(this[_retiredUnchanged]).map(([retireFolder, nodes]) => promiseAllRejectLate(nodes.map(node => {\n      const realFolder = realFolders.get(retireFolder);\n      const rel = relative(realFolder, node.path);\n      const fromPath = resolve(retireFolder, rel);\n      return this[_moveContents]({\n        ...node,\n        path: fromPath\n      }, node.path);\n    })));\n    return promiseAllRejectLate(promises).then(() => this[_rollbackCreateSparseTree](er));\n  }\n  [_build]() {\n    process.emit('time', 'reify:build');\n\n    // for all the things being installed, run their appropriate scripts\n    // run in tip->root order, so as to be more likely to build a node's\n    // deps before attempting to build it itself\n    const nodes = [];\n    dfwalk({\n      tree: this.diff,\n      leave: diff => {\n        if (!diff.ideal.isProjectRoot) {\n          nodes.push(diff.ideal);\n        }\n      },\n      // process adds before changes, ignore removals\n      getChildren: diff => diff && diff.children,\n      filter: diff => diff.action === 'ADD' || diff.action === 'CHANGE'\n    });\n\n    // pick up link nodes from the unchanged list as we want to run their\n    // scripts in every install despite of having a diff status change\n    for (const node of this.diff.unchanged) {\n      const tree = node.root.target;\n\n      // skip links that only live within node_modules as they are most\n      // likely managed by packages we installed, we only want to rebuild\n      // unchanged links we directly manage\n      if (node.isLink && node.target.fsTop === tree) {\n        nodes.push(node);\n      }\n    }\n    return this.rebuild({\n      nodes,\n      handleOptionalFailure: true\n    }).then(() => process.emit('timeEnd', 'reify:build'));\n  }\n\n  // the tree is pretty much built now, so it's cleanup time.\n  // remove the retired folders, and any deleted nodes\n  // If this fails, there isn't much we can do but tell the user about it.\n  // Thankfully, it's pretty unlikely that it'll fail, since rimraf is a tank.\n  [_removeTrash]() {\n    process.emit('time', 'reify:trash');\n    const promises = [];\n    const failures = [];\n    const rm = path => rimraf(path).catch(er => failures.push([path, er]));\n    for (const path of this[_trashList]) {\n      promises.push(rm(path));\n    }\n    return promiseAllRejectLate(promises).then(() => {\n      if (failures.length) {\n        this.log.warn('cleanup', 'Failed to remove some directories', failures);\n      }\n    }).then(() => process.emit('timeEnd', 'reify:trash'));\n  }\n\n  // last but not least, we save the ideal tree metadata to the package-lock\n  // or shrinkwrap file, and any additions or removals to package.json\n  async [_saveIdealTree](options) {\n    // the ideal tree is actualized now, hooray!\n    // it still contains all the references to optional nodes that were removed\n    // for install failures.  Those still end up in the shrinkwrap, so we\n    // save it first, then prune out the optional trash, and then return it.\n\n    // support save=false option\n    if (options.save === false || this[_global] || this[_dryRun]) {\n      return false;\n    }\n    process.emit('time', 'reify:save');\n    const updatedTrees = new Set();\n\n    // resolvedAdd is the list of user add requests, but with names added\n    // to things like git repos and tarball file/urls.  However, if the\n    // user requested 'foo@', and we have a foo@file:../foo, then we should\n    // end up saving the spec we actually used, not whatever they gave us.\n    if (this[_resolvedAdd].length) {\n      for (const {\n        name,\n        tree: addTree\n      } of this[_resolvedAdd]) {\n        // addTree either the root, or a workspace\n        const edge = addTree.edgesOut.get(name);\n        const pkg = addTree.package;\n        const req = npa.resolve(name, edge.spec, addTree.realpath);\n        const {\n          rawSpec,\n          subSpec\n        } = req;\n        const spec = subSpec ? subSpec.rawSpec : rawSpec;\n        const child = edge.to;\n\n        // if we tried to install an optional dep, but it was a version\n        // that we couldn't resolve, this MAY be missing.  if we haven't\n        // blown up by now, it's because it was not a problem, though, so\n        // just move on.\n        if (!child) {\n          continue;\n        }\n        let newSpec;\n        if (req.registry) {\n          const version = child.version;\n          const prefixRange = version ? this[_savePrefix] + version : '*';\n          // if we installed a range, then we save the range specified\n          // if it is not a subset of the ^x.y.z.  eg, installing a range\n          // of `1.x <1.2.3` will not be saved as `^1.2.0`, because that\n          // would allow versions outside the requested range.  Tags and\n          // specific versions save with the save-prefix.\n          const isRange = (subSpec || req).type === 'range';\n          let range = spec;\n          if (!isRange || spec === '*' || subset(prefixRange, spec, {\n            loose: true\n          })) {\n            range = prefixRange;\n          }\n          const pname = child.packageName;\n          const alias = name !== pname;\n          newSpec = alias ? `npm:${pname}@${range}` : range;\n        } else if (req.hosted) {\n          // save the git+https url if it has auth, otherwise shortcut\n          const h = req.hosted;\n          const opt = {\n            noCommittish: false\n          };\n          if (h.https && h.auth) {\n            newSpec = `git+${h.https(opt)}`;\n          } else {\n            newSpec = h.shortcut(opt);\n          }\n        } else if (req.type === 'directory' || req.type === 'file') {\n          // save the relative path in package.json\n          // Normally saveSpec is updated with the proper relative\n          // path already, but it's possible to specify a full absolute\n          // path initially, in which case we can end up with the wrong\n          // thing, so just get the ultimate fetchSpec and relativize it.\n          const p = req.fetchSpec.replace(/^file:/, '');\n          const rel = relpath(addTree.realpath, p);\n          newSpec = `file:${rel}`;\n        } else {\n          newSpec = req.saveSpec;\n        }\n        if (options.saveType) {\n          const depType = saveTypeMap.get(options.saveType);\n          pkg[depType][name] = newSpec;\n          // rpj will have moved it here if it was in both\n          // if it is empty it will be deleted later\n          if (options.saveType === 'prod' && pkg.optionalDependencies) {\n            delete pkg.optionalDependencies[name];\n          }\n        } else {\n          if (hasSubKey(pkg, 'dependencies', name)) {\n            pkg.dependencies[name] = newSpec;\n          }\n          if (hasSubKey(pkg, 'devDependencies', name)) {\n            pkg.devDependencies[name] = newSpec;\n            // don't update peer or optional if we don't have to\n            if (hasSubKey(pkg, 'peerDependencies', name) && !intersects(newSpec, pkg.peerDependencies[name])) {\n              pkg.peerDependencies[name] = newSpec;\n            }\n            if (hasSubKey(pkg, 'optionalDependencies', name) && !intersects(newSpec, pkg.optionalDependencies[name])) {\n              pkg.optionalDependencies[name] = newSpec;\n            }\n          } else {\n            if (hasSubKey(pkg, 'peerDependencies', name)) {\n              pkg.peerDependencies[name] = newSpec;\n            }\n            if (hasSubKey(pkg, 'optionalDependencies', name)) {\n              pkg.optionalDependencies[name] = newSpec;\n            }\n          }\n        }\n        updatedTrees.add(addTree);\n      }\n    }\n\n    // preserve indentation, if possible\n    const {\n      [Symbol.for('indent')]: indent\n    } = this.idealTree.package;\n    const format = indent === undefined ? '  ' : indent;\n    const saveOpt = {\n      format: this[_formatPackageLock] && format ? format : this[_formatPackageLock]\n    };\n    const promises = [this[_saveLockFile](saveOpt)];\n    const updatePackageJson = async tree => {\n      const pkgJson = await PackageJson.load(tree.path).catch(() => new PackageJson(tree.path));\n      const {\n        dependencies = {},\n        devDependencies = {},\n        optionalDependencies = {},\n        peerDependencies = {}\n      } = tree.package;\n      pkgJson.update({\n        dependencies,\n        devDependencies,\n        optionalDependencies,\n        peerDependencies\n      });\n      await pkgJson.save();\n    };\n\n    // grab any from explicitRequests that had deps removed\n    for (const {\n      from: tree\n    } of this.explicitRequests) {\n      updatedTrees.add(tree);\n    }\n    for (const tree of updatedTrees) {\n      // refresh the edges so they have the correct specs\n      tree.package = tree.package;\n      promises.push(updatePackageJson(tree));\n    }\n    await Promise.all(promises);\n    process.emit('timeEnd', 'reify:save');\n    return true;\n  }\n  async [_saveLockFile](saveOpt) {\n    if (!this[_usePackageLock]) {\n      return;\n    }\n    const {\n      meta\n    } = this.idealTree;\n    return meta.save(saveOpt);\n  }\n  async [_copyIdealToActual]() {\n    // clean up any trash that is still in the tree\n    for (const path of this[_trashList]) {\n      const loc = relpath(this.idealTree.realpath, path);\n      const node = this.idealTree.inventory.get(loc);\n      if (node && node.root === this.idealTree) {\n        node.parent = null;\n      }\n    }\n\n    // if we filtered to only certain nodes, then anything ELSE needs\n    // to be untouched in the resulting actual tree, even if it differs\n    // in the idealTree.  Copy over anything that was in the actual and\n    // was not changed, delete anything in the ideal and not actual.\n    // Then we move the entire idealTree over to this.actualTree, and\n    // save the hidden lockfile.\n    if (this.diff && this.diff.filterSet.size) {\n      const reroot = new Set();\n      const {\n        filterSet\n      } = this.diff;\n      const seen = new Set();\n      for (const [loc, ideal] of this.idealTree.inventory.entries()) {\n        seen.add(loc);\n\n        // if it's an ideal node from the filter set, then skip it\n        // because we already made whatever changes were necessary\n        if (filterSet.has(ideal)) {\n          continue;\n        }\n\n        // otherwise, if it's not in the actualTree, then it's not a thing\n        // that we actually added.  And if it IS in the actualTree, then\n        // it's something that we left untouched, so we need to record\n        // that.\n        const actual = this.actualTree.inventory.get(loc);\n        if (!actual) {\n          ideal.root = null;\n        } else {\n          if ([...actual.linksIn].some(link => filterSet.has(link))) {\n            seen.add(actual.location);\n            continue;\n          }\n          const {\n            realpath,\n            isLink\n          } = actual;\n          if (isLink && ideal.isLink && ideal.realpath === realpath) {\n            continue;\n          } else {\n            reroot.add(actual);\n          }\n        }\n      }\n\n      // now find any actual nodes that may not be present in the ideal\n      // tree, but were left behind by virtue of not being in the filter\n      for (const [loc, actual] of this.actualTree.inventory.entries()) {\n        if (seen.has(loc)) {\n          continue;\n        }\n        seen.add(loc);\n\n        // we know that this is something that ISN'T in the idealTree,\n        // or else we will have addressed it in the previous loop.\n        // If it's in the filterSet, that means we intentionally removed\n        // it, so nothing to do here.\n        if (filterSet.has(actual)) {\n          continue;\n        }\n        reroot.add(actual);\n      }\n\n      // go through the rerooted actual nodes, and move them over.\n      for (const actual of reroot) {\n        actual.root = this.idealTree;\n      }\n\n      // prune out any tops that lack a linkIn, they are no longer relevant.\n      for (const top of this.idealTree.tops) {\n        if (top.linksIn.size === 0) {\n          top.root = null;\n        }\n      }\n\n      // need to calculate dep flags, since nodes may have been marked\n      // as extraneous or otherwise incorrect during transit.\n      calcDepFlags(this.idealTree);\n    }\n\n    // save the ideal's meta as a hidden lockfile after we actualize it\n    this.idealTree.meta.filename = this.idealTree.realpath + '/node_modules/.package-lock.json';\n    this.idealTree.meta.hiddenLockfile = true;\n    this.actualTree = this.idealTree;\n    this.idealTree = null;\n    if (!this[_global]) {\n      await this.actualTree.meta.save();\n    }\n  }\n};","map":{"version":3,"names":["onExit","require","pacote","AuditReport","subset","intersects","npa","debug","walkUp","dirname","resolve","relative","depth","dfwalk","fs","promisify","lstat","symlink","mkdirp","justMkdirp","moveFile","rimraf","PackageJson","packageContents","checkEngine","checkPlatform","_force","Symbol","for","treeCheck","relpath","Diff","retirePath","promiseAllRejectLate","optionalSet","calcDepFlags","saveTypeMap","hasSubKey","_retiredPaths","_retiredUnchanged","_sparseTreeDirs","_sparseTreeRoots","_savePrefix","_retireShallowNodes","_getBundlesByDepth","_registryResolved","_addNodeToTrashList","_workspaces","_trashList","_handleOptionalFailure","_loadTrees","_diffTrees","_createSparseTree","_loadShrinkwrapsAndUpdateTrees","_shrinkwrapInflated","_bundleUnpacked","_bundleMissing","_reifyNode","_extractOrLink","_checkBins","_symlink","_warnDeprecated","_loadBundlesAndUpdateTrees","_submitQuickAudit","_awaitQuickAudit","_unpackNewModules","_moveContents","_moveBackRetiredUnchanged","_build","_removeTrash","_renamePath","_rollbackRetireShallowNodes","_rollbackCreateSparseTree","_rollbackMoveBackRetiredUnchanged","_saveIdealTree","_saveLockFile","_copyIdealToActual","_addOmitsToTrashList","_packageLockOnly","_dryRun","_validateNodeModules","_nmValidated","_validatePath","_reifyPackages","_omitDev","_omitOptional","_omitPeer","_global","_pruneBundledMetadeps","_resolvedAdd","_usePackageLock","_formatPackageLock","module","exports","cls","Reifier","constructor","options","savePrefix","packageLockOnly","dryRun","formatPackageLock","diff","Set","reify","er","Error","code","omit","has","addTracker","process","emit","finishTracker","actualTree","path","reifyTerminated","removeHandler","signal","Object","assign","steps","rollback","actions","action","bitOpt","complete","buildIdealTree","then","actualOpt","ignoreMissing","global","filter","node","kid","explicitRequests","size","isProjectRoot","idealTree","edgesOut","hasExplicit","some","edge","name","Promise","all","loadActual","filterNodes","target","ideal","children","get","push","actual","ws","calculate","shrinkwrapInflated","retire","paths","binPaths","moves","log","silly","retired","add","movePromises","entries","map","from","to","didMkdirp","catch","top","peer","dev","optional","devOptional","inventory","leaves","isLink","dirsChecked","d","st","isDirectory","made","roots","failures","targets","keys","unlinks","length","warn","seen","shrinkwraps","hasShrinkwrap","Arborist","nodes","loadVirtual","root","timer","location","npmVersion","nodeVersion","p","package","nm","res","resolved","packageName","version","warning","verbose","parent","fsParent","e","extract","integrity","dir","realpath","rel","_id","deprecated","set","replace","registry","bundlesByDepth","maxBundleDepth","arb","notTransplanted","transplantFilter","delete","Map","tree","visit","bundleDependencies","Math","max","getChildren","bundleShadowed","bundles","values","Array","isArray","shadow","extraneous","shadDep","changed","edgesIn","audit","auditReport","filterSet","workspaceDependencySet","load","unpacks","bd","sw","bundleMissing","doUnpack","isRoot","inDepBundle","realFolder","retireFolder","unchanged","fromPath","packageJsonCache","realFolders","k","v","promises","leave","fsTop","rebuild","handleOptionalFailure","rm","save","updatedTrees","addTree","pkg","req","spec","rawSpec","subSpec","child","newSpec","prefixRange","isRange","type","range","loose","pname","alias","hosted","h","opt","noCommittish","https","auth","shortcut","fetchSpec","saveSpec","saveType","depType","optionalDependencies","dependencies","devDependencies","peerDependencies","indent","format","undefined","saveOpt","updatePackageJson","pkgJson","update","meta","loc","reroot","linksIn","link","tops","filename","hiddenLockfile"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/reify.js"],"sourcesContent":["// mixin implementing the reify method\n\nconst onExit = require('../signal-handling.js')\nconst pacote = require('pacote')\nconst AuditReport = require('../audit-report.js')\nconst {subset, intersects} = require('semver')\nconst npa = require('npm-package-arg')\nconst debug = require('../debug.js')\nconst walkUp = require('walk-up-path')\n\nconst {dirname, resolve, relative} = require('path')\nconst {depth: dfwalk} = require('treeverse')\nconst fs = require('fs')\nconst {promisify} = require('util')\nconst lstat = promisify(fs.lstat)\nconst symlink = promisify(fs.symlink)\nconst mkdirp = require('mkdirp-infer-owner')\nconst justMkdirp = require('mkdirp')\nconst moveFile = require('@npmcli/move-file')\nconst rimraf = promisify(require('rimraf'))\nconst PackageJson = require('@npmcli/package-json')\nconst packageContents = require('@npmcli/installed-package-contents')\nconst { checkEngine, checkPlatform } = require('npm-install-checks')\nconst _force = Symbol.for('force')\n\nconst treeCheck = require('../tree-check.js')\nconst relpath = require('../relpath.js')\nconst Diff = require('../diff.js')\nconst retirePath = require('../retire-path.js')\nconst promiseAllRejectLate = require('promise-all-reject-late')\nconst optionalSet = require('../optional-set.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst { saveTypeMap, hasSubKey } = require('../add-rm-pkg-deps.js')\n\nconst _retiredPaths = Symbol('retiredPaths')\nconst _retiredUnchanged = Symbol('retiredUnchanged')\nconst _sparseTreeDirs = Symbol('sparseTreeDirs')\nconst _sparseTreeRoots = Symbol('sparseTreeRoots')\nconst _savePrefix = Symbol('savePrefix')\nconst _retireShallowNodes = Symbol.for('retireShallowNodes')\nconst _getBundlesByDepth = Symbol('getBundlesByDepth')\nconst _registryResolved = Symbol('registryResolved')\nconst _addNodeToTrashList = Symbol('addNodeToTrashList')\nconst _workspaces = Symbol.for('workspaces')\n\n// shared by rebuild mixin\nconst _trashList = Symbol.for('trashList')\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure')\nconst _loadTrees = Symbol.for('loadTrees')\n\n// shared symbols for swapping out when testing\nconst _diffTrees = Symbol.for('diffTrees')\nconst _createSparseTree = Symbol.for('createSparseTree')\nconst _loadShrinkwrapsAndUpdateTrees = Symbol.for('loadShrinkwrapsAndUpdateTrees')\nconst _shrinkwrapInflated = Symbol('shrinkwrapInflated')\nconst _bundleUnpacked = Symbol('bundleUnpacked')\nconst _bundleMissing = Symbol('bundleMissing')\nconst _reifyNode = Symbol.for('reifyNode')\nconst _extractOrLink = Symbol('extractOrLink')\n// defined by rebuild mixin\nconst _checkBins = Symbol.for('checkBins')\nconst _symlink = Symbol('symlink')\nconst _warnDeprecated = Symbol('warnDeprecated')\nconst _loadBundlesAndUpdateTrees = Symbol.for('loadBundlesAndUpdateTrees')\nconst _submitQuickAudit = Symbol('submitQuickAudit')\nconst _awaitQuickAudit = Symbol('awaitQuickAudit')\nconst _unpackNewModules = Symbol.for('unpackNewModules')\nconst _moveContents = Symbol.for('moveContents')\nconst _moveBackRetiredUnchanged = Symbol.for('moveBackRetiredUnchanged')\nconst _build = Symbol.for('build')\nconst _removeTrash = Symbol.for('removeTrash')\nconst _renamePath = Symbol.for('renamePath')\nconst _rollbackRetireShallowNodes = Symbol.for('rollbackRetireShallowNodes')\nconst _rollbackCreateSparseTree = Symbol.for('rollbackCreateSparseTree')\nconst _rollbackMoveBackRetiredUnchanged = Symbol.for('rollbackMoveBackRetiredUnchanged')\nconst _saveIdealTree = Symbol.for('saveIdealTree')\nconst _saveLockFile = Symbol('saveLockFile')\nconst _copyIdealToActual = Symbol('copyIdealToActual')\nconst _addOmitsToTrashList = Symbol('addOmitsToTrashList')\nconst _packageLockOnly = Symbol('packageLockOnly')\nconst _dryRun = Symbol('dryRun')\nconst _validateNodeModules = Symbol('validateNodeModules')\nconst _nmValidated = Symbol('nmValidated')\nconst _validatePath = Symbol('validatePath')\nconst _reifyPackages = Symbol.for('reifyPackages')\n\nconst _omitDev = Symbol('omitDev')\nconst _omitOptional = Symbol('omitOptional')\nconst _omitPeer = Symbol('omitPeer')\n\nconst _global = Symbol.for('global')\n\nconst _pruneBundledMetadeps = Symbol('pruneBundledMetadeps')\n\n// defined by Ideal mixin\nconst _resolvedAdd = Symbol.for('resolvedAdd')\nconst _usePackageLock = Symbol.for('usePackageLock')\nconst _formatPackageLock = Symbol.for('formatPackageLock')\n\nmodule.exports = cls => class Reifier extends cls {\n  constructor (options) {\n    super(options)\n\n    const {\n      savePrefix = '^',\n      packageLockOnly = false,\n      dryRun = false,\n      formatPackageLock = true,\n    } = options\n\n    this[_dryRun] = !!dryRun\n    this[_packageLockOnly] = !!packageLockOnly\n    this[_savePrefix] = savePrefix\n    this[_formatPackageLock] = !!formatPackageLock\n\n    this.diff = null\n    this[_retiredPaths] = {}\n    this[_shrinkwrapInflated] = new Set()\n    this[_retiredUnchanged] = {}\n    this[_sparseTreeDirs] = new Set()\n    this[_sparseTreeRoots] = new Set()\n    this[_trashList] = new Set()\n    // the nodes we unpack to read their bundles\n    this[_bundleUnpacked] = new Set()\n    // child nodes we'd EXPECT to be included in a bundle, but aren't\n    this[_bundleMissing] = new Set()\n    this[_nmValidated] = new Set()\n  }\n\n  // public method\n  async reify (options = {}) {\n    if (this[_packageLockOnly] && this[_global]) {\n      const er = new Error('cannot generate lockfile for global packages')\n      er.code = 'ESHRINKWRAPGLOBAL'\n      throw er\n    }\n\n    const omit = new Set(options.omit || [])\n    this[_omitDev] = omit.has('dev')\n    this[_omitOptional] = omit.has('optional')\n    this[_omitPeer] = omit.has('peer')\n\n    // start tracker block\n    this.addTracker('reify')\n    process.emit('time', 'reify')\n    await this[_validatePath]()\n    await this[_loadTrees](options)\n    await this[_diffTrees]()\n    await this[_reifyPackages]()\n    await this[_saveIdealTree](options)\n    await this[_copyIdealToActual]()\n    await this[_awaitQuickAudit]()\n\n    this.finishTracker('reify')\n    process.emit('timeEnd', 'reify')\n    return treeCheck(this.actualTree)\n  }\n\n  async [_validatePath] () {\n    // don't create missing dirs on dry runs\n    if (this[_packageLockOnly] || this[_dryRun]) {\n      return\n    }\n\n    // we do NOT want to set ownership on this folder, especially\n    // recursively, because it can have other side effects to do that\n    // in a project directory.  We just want to make it if it's missing.\n    await justMkdirp(resolve(this.path))\n\n    // do not allow the top-level node_modules to be a symlink\n    await this[_validateNodeModules](resolve(this.path, 'node_modules'))\n  }\n\n  async [_reifyPackages] () {\n    // we don't submit the audit report or write to disk on dry runs\n    if (this[_dryRun]) {\n      return\n    }\n\n    if (this[_packageLockOnly]) {\n      // we already have the complete tree, so just audit it now,\n      // and that's all we have to do here.\n      return this[_submitQuickAudit]()\n    }\n\n    // ok, we're about to start touching the fs.  need to roll back\n    // if we get an early termination.\n    let reifyTerminated = null\n    const removeHandler = onExit(({signal}) => {\n      // only call once.  if signal hits twice, we just terminate\n      removeHandler()\n      reifyTerminated = Object.assign(new Error('process terminated'), {\n        signal,\n      })\n      return false\n    })\n\n    // [rollbackfn, [...actions]]\n    // after each step, if the process was terminated, execute the rollback\n    // note that each rollback *also* calls the previous one when it's\n    // finished, and then the first one throws the error, so we only need\n    // a new rollback step when we have a new thing that must be done to\n    // revert the install.\n    const steps = [\n      [_rollbackRetireShallowNodes, [\n        _retireShallowNodes,\n      ]],\n      [_rollbackCreateSparseTree, [\n        _createSparseTree,\n        _addOmitsToTrashList,\n        _loadShrinkwrapsAndUpdateTrees,\n        _loadBundlesAndUpdateTrees,\n        _submitQuickAudit,\n        _unpackNewModules,\n      ]],\n      [_rollbackMoveBackRetiredUnchanged, [\n        _moveBackRetiredUnchanged,\n        _build,\n      ]],\n    ]\n    for (const [rollback, actions] of steps) {\n      for (const action of actions) {\n        try {\n          await this[action]()\n          if (reifyTerminated) {\n            throw reifyTerminated\n          }\n        } catch (er) {\n          await this[rollback](er)\n          /* istanbul ignore next - rollback throws, should never hit this */\n          throw er\n        }\n      }\n    }\n\n    // no rollback for this one, just exit with the error, since the\n    // install completed and can't be safely recovered at this point.\n    await this[_removeTrash]()\n    if (reifyTerminated) {\n      throw reifyTerminated\n    }\n\n    // done modifying the file system, no need to keep listening for sigs\n    removeHandler()\n  }\n\n  // when doing a local install, we load everything and figure it all out.\n  // when doing a global install, we *only* care about the explicit requests.\n  [_loadTrees] (options) {\n    process.emit('time', 'reify:loadTrees')\n    const bitOpt = {\n      ...options,\n      complete: this[_packageLockOnly] || this[_dryRun],\n    }\n\n    // if we're only writing a package lock, then it doesn't matter what's here\n    if (this[_packageLockOnly]) {\n      return this.buildIdealTree(bitOpt)\n        .then(() => process.emit('timeEnd', 'reify:loadTrees'))\n    }\n\n    const actualOpt = this[_global] ? {\n      ignoreMissing: true,\n      global: true,\n      filter: (node, kid) => {\n        // if it's not the project root, and we have no explicit requests,\n        // then we're already into a nested dep, so we keep it\n        if (this.explicitRequests.size === 0 || !node.isProjectRoot) {\n          return true\n        }\n\n        // if we added it as an edgeOut, then we want it\n        if (this.idealTree.edgesOut.has(kid)) {\n          return true\n        }\n\n        // if it's an explicit request, then we want it\n        const hasExplicit = [...this.explicitRequests]\n          .some(edge => edge.name === kid)\n        if (hasExplicit) {\n          return true\n        }\n\n        // ignore the rest of the global install folder\n        return false\n      },\n    } : { ignoreMissing: true }\n\n    if (!this[_global]) {\n      return Promise.all([\n        this.loadActual(actualOpt),\n        this.buildIdealTree(bitOpt),\n      ]).then(() => process.emit('timeEnd', 'reify:loadTrees'))\n    }\n\n    // the global install space tends to have a lot of stuff in it.  don't\n    // load all of it, just what we care about.  we won't be saving a\n    // hidden lockfile in there anyway.  Note that we have to load ideal\n    // BEFORE loading actual, so that the actualOpt can use the\n    // explicitRequests which is set during buildIdealTree\n    return this.buildIdealTree(bitOpt)\n      .then(() => this.loadActual(actualOpt))\n      .then(() => process.emit('timeEnd', 'reify:loadTrees'))\n  }\n\n  [_diffTrees] () {\n    if (this[_packageLockOnly]) {\n      return\n    }\n\n    process.emit('time', 'reify:diffTrees')\n    // XXX if we have an existing diff already, there should be a way\n    // to just invalidate the parts that changed, but avoid walking the\n    // whole tree again.\n\n    const filterNodes = []\n    if (this[_global] && this.explicitRequests.size) {\n      const idealTree = this.idealTree.target\n      const actualTree = this.actualTree.target\n      // we ONLY are allowed to make changes in the global top-level\n      // children where there's an explicit request.\n      for (const { name } of this.explicitRequests) {\n        const ideal = idealTree.children.get(name)\n        if (ideal) {\n          filterNodes.push(ideal)\n        }\n        const actual = actualTree.children.get(name)\n        if (actual) {\n          filterNodes.push(actual)\n        }\n      }\n    } else {\n      for (const ws of this[_workspaces]) {\n        const ideal = this.idealTree.children.get(ws)\n        if (ideal) {\n          filterNodes.push(ideal)\n        }\n        const actual = this.actualTree.children.get(ws)\n        if (actual) {\n          filterNodes.push(actual)\n        }\n      }\n    }\n\n    // find all the nodes that need to change between the actual\n    // and ideal trees.\n    this.diff = Diff.calculate({\n      shrinkwrapInflated: this[_shrinkwrapInflated],\n      filterNodes,\n      actual: this.actualTree,\n      ideal: this.idealTree,\n    })\n\n    // we don't have to add 'removed' folders to the trashlist, because\n    // they'll be moved aside to a retirement folder, and then the retired\n    // folder will be deleted at the end.  This is important when we have\n    // a folder like FOO being \"removed\" in favor of a folder like \"foo\",\n    // because if we remove node_modules/FOO on case-insensitive systems,\n    // it will remove the dep that we *want* at node_modules/foo.\n\n    process.emit('timeEnd', 'reify:diffTrees')\n  }\n\n  // add the node and all its bins to the list of things to be\n  // removed later on in the process.  optionally, also mark them\n  // as a retired paths, so that we move them out of the way and\n  // replace them when rolling back on failure.\n  [_addNodeToTrashList] (node, retire = false) {\n    const paths = [node.path, ...node.binPaths]\n    const moves = this[_retiredPaths]\n    this.log.silly('reify', 'mark', retire ? 'retired' : 'deleted', paths)\n    for (const path of paths) {\n      if (retire) {\n        const retired = retirePath(path)\n        moves[path] = retired\n        this[_trashList].add(retired)\n      } else {\n        this[_trashList].add(path)\n      }\n    }\n  }\n\n  // move aside the shallowest nodes in the tree that have to be\n  // changed or removed, so that we can rollback if necessary.\n  [_retireShallowNodes] () {\n    process.emit('time', 'reify:retireShallow')\n    const moves = this[_retiredPaths] = {}\n    for (const diff of this.diff.children) {\n      if (diff.action === 'CHANGE' || diff.action === 'REMOVE') {\n        // we'll have to clean these up at the end, so add them to the list\n        this[_addNodeToTrashList](diff.actual, true)\n      }\n    }\n    this.log.silly('reify', 'moves', moves)\n    const movePromises = Object.entries(moves)\n      .map(([from, to]) => this[_renamePath](from, to))\n    return promiseAllRejectLate(movePromises)\n      .then(() => process.emit('timeEnd', 'reify:retireShallow'))\n  }\n\n  [_renamePath] (from, to, didMkdirp = false) {\n    return moveFile(from, to)\n      .catch(er => {\n        // Occasionally an expected bin file might not exist in the package,\n        // or a shim/symlink might have been moved aside.  If we've already\n        // handled the most common cause of ENOENT (dir doesn't exist yet),\n        // then just ignore any ENOENT.\n        if (er.code === 'ENOENT') {\n          return didMkdirp ? null : mkdirp(dirname(to)).then(() =>\n            this[_renamePath](from, to, true))\n        } else if (er.code === 'EEXIST') {\n          return rimraf(to).then(() => moveFile(from, to))\n        } else {\n          throw er\n        }\n      })\n  }\n\n  [_rollbackRetireShallowNodes] (er) {\n    process.emit('time', 'reify:rollback:retireShallow')\n    const moves = this[_retiredPaths]\n    const movePromises = Object.entries(moves)\n      .map(([from, to]) => this[_renamePath](to, from))\n    return promiseAllRejectLate(movePromises)\n      // ignore subsequent rollback errors\n      .catch(er => {})\n      .then(() => process.emit('timeEnd', 'reify:rollback:retireShallow'))\n      .then(() => {\n        throw er\n      })\n  }\n\n  // adding to the trash list will skip reifying, and delete them\n  // if they are currently in the tree and otherwise untouched.\n  [_addOmitsToTrashList] () {\n    if (!this[_omitDev] && !this[_omitOptional] && !this[_omitPeer]) {\n      return\n    }\n\n    process.emit('time', 'reify:trashOmits')\n\n    const filter = node =>\n      node.top.isProjectRoot &&\n        (node.peer && this[_omitPeer] ||\n          node.dev && this[_omitDev] ||\n          node.optional && this[_omitOptional] ||\n          node.devOptional && this[_omitOptional] && this[_omitDev])\n\n    for (const node of this.idealTree.inventory.filter(filter)) {\n      this[_addNodeToTrashList](node)\n    }\n\n    process.emit('timeEnd', 'reify:trashOmits')\n  }\n\n  [_createSparseTree] () {\n    process.emit('time', 'reify:createSparse')\n    // if we call this fn again, we look for the previous list\n    // so that we can avoid making the same directory multiple times\n    const leaves = this.diff.leaves\n      .filter(diff => {\n        return (diff.action === 'ADD' || diff.action === 'CHANGE') &&\n          !this[_sparseTreeDirs].has(diff.ideal.path) &&\n          !diff.ideal.isLink\n      })\n      .map(diff => diff.ideal)\n\n    // we check this in parallel, so guard against multiple attempts to\n    // retire the same path at the same time.\n    const dirsChecked = new Set()\n    return promiseAllRejectLate(leaves.map(async node => {\n      for (const d of walkUp(node.path)) {\n        if (d === node.top.path) {\n          break\n        }\n        if (dirsChecked.has(d)) {\n          continue\n        }\n        dirsChecked.add(d)\n        const st = await lstat(d).catch(er => null)\n        // this can happen if we have a link to a package with a name\n        // that the filesystem treats as if it is the same thing.\n        // would be nice to have conditional istanbul ignores here...\n        /* istanbul ignore next - defense in depth */\n        if (st && !st.isDirectory()) {\n          const retired = retirePath(d)\n          this[_retiredPaths][d] = retired\n          this[_trashList].add(retired)\n          await this[_renamePath](d, retired)\n        }\n      }\n      const made = await mkdirp(node.path)\n      this[_sparseTreeDirs].add(node.path)\n      this[_sparseTreeRoots].add(made)\n    }))\n      .then(() => process.emit('timeEnd', 'reify:createSparse'))\n  }\n\n  [_rollbackCreateSparseTree] (er) {\n    process.emit('time', 'reify:rollback:createSparse')\n    // cut the roots of the sparse tree that were created, not the leaves\n    const roots = this[_sparseTreeRoots]\n    // also delete the moves that we retired, so that we can move them back\n    const failures = []\n    const targets = [...roots, ...Object.keys(this[_retiredPaths])]\n    const unlinks = targets\n      .map(path => rimraf(path).catch(er => failures.push([path, er])))\n    return promiseAllRejectLate(unlinks)\n      .then(() => {\n        if (failures.length) {\n          this.log.warn('cleanup', 'Failed to remove some directories', failures)\n        }\n      })\n      .then(() => process.emit('timeEnd', 'reify:rollback:createSparse'))\n      .then(() => this[_rollbackRetireShallowNodes](er))\n  }\n\n  // shrinkwrap nodes define their dependency branches with a file, so\n  // we need to unpack them, read that shrinkwrap file, and then update\n  // the tree by calling loadVirtual with the node as the root.\n  [_loadShrinkwrapsAndUpdateTrees] () {\n    const seen = this[_shrinkwrapInflated]\n    const shrinkwraps = this.diff.leaves\n      .filter(d => (d.action === 'CHANGE' || d.action === 'ADD' || !d.action) &&\n        d.ideal.hasShrinkwrap && !seen.has(d.ideal) &&\n        !this[_trashList].has(d.ideal.path))\n\n    if (!shrinkwraps.length) {\n      return\n    }\n\n    process.emit('time', 'reify:loadShrinkwraps')\n\n    const Arborist = this.constructor\n    return promiseAllRejectLate(shrinkwraps.map(diff => {\n      const node = diff.ideal\n      seen.add(node)\n      return diff.action ? this[_reifyNode](node) : node\n    }))\n      .then(nodes => promiseAllRejectLate(nodes.map(node => new Arborist({\n        ...this.options,\n        path: node.path,\n      }).loadVirtual({ root: node }))))\n      // reload the diff and sparse tree because the ideal tree changed\n      .then(() => this[_diffTrees]())\n      .then(() => this[_createSparseTree]())\n      .then(() => this[_addOmitsToTrashList]())\n      .then(() => this[_loadShrinkwrapsAndUpdateTrees]())\n      .then(() => process.emit('timeEnd', 'reify:loadShrinkwraps'))\n  }\n\n  // create a symlink for Links, extract for Nodes\n  // return the node object, since we usually want that\n  // handle optional dep failures here\n  // If node is in trash list, skip it\n  // If reifying fails, and the node is optional, add it and its optionalSet\n  // to the trash list\n  // Always return the node.\n  [_reifyNode] (node) {\n    if (this[_trashList].has(node.path)) {\n      return node\n    }\n\n    const timer = `reifyNode:${node.location}`\n    process.emit('time', timer)\n    this.addTracker('reify', node.name, node.location)\n\n    const { npmVersion, nodeVersion } = this.options\n    const p = Promise.resolve()\n      .then(async () => {\n        // when we reify an optional node, check the engine and platform\n        // first. be sure to ignore the --force and --engine-strict flags,\n        // since we always want to skip any optional packages we can't install.\n        // these checks throwing will result in a rollback and removal\n        // of the mismatches\n        if (node.optional) {\n          checkEngine(node.package, npmVersion, nodeVersion, false)\n          checkPlatform(node.package, false)\n        }\n        await this[_checkBins](node)\n        await this[_extractOrLink](node)\n        await this[_warnDeprecated](node)\n      })\n\n    return this[_handleOptionalFailure](node, p)\n      .then(() => {\n        this.finishTracker('reify', node.name, node.location)\n        process.emit('timeEnd', timer)\n        return node\n      })\n  }\n\n  // do not allow node_modules to be a symlink\n  async [_validateNodeModules] (nm) {\n    if (this[_force] || this[_nmValidated].has(nm)) {\n      return\n    }\n    const st = await lstat(nm).catch(() => null)\n    if (!st || st.isDirectory()) {\n      this[_nmValidated].add(nm)\n      return\n    }\n    this.log.warn('reify', 'Removing non-directory', nm)\n    await rimraf(nm)\n  }\n\n  async [_extractOrLink] (node) {\n    // in normal cases, node.resolved should *always* be set by now.\n    // however, it is possible when a lockfile is damaged, or very old,\n    // or in some other race condition bugs in npm v6, that a previously\n    // bundled dependency will have just a version, but no resolved value,\n    // and no 'bundled: true' setting.\n    // Do the best with what we have, or else remove it from the tree\n    // entirely, since we can't possibly reify it.\n    const res = node.resolved ? `${node.name}@${this[_registryResolved](node.resolved)}`\n      : node.packageName && node.version\n        ? `${node.packageName}@${node.version}`\n        : null\n\n    // no idea what this thing is.  remove it from the tree.\n    if (!res) {\n      const warning = 'invalid or damaged lockfile detected\\n' +\n        'please re-try this operation once it completes\\n' +\n        'so that the damage can be corrected, or perform\\n' +\n        'a fresh install with no lockfile if the problem persists.'\n      this.log.warn('reify', warning)\n      this.log.verbose('reify', 'unrecognized node in tree', node.path)\n      node.parent = null\n      node.fsParent = null\n      this[_addNodeToTrashList](node)\n      return\n    }\n\n    const nm = resolve(node.parent.path, 'node_modules')\n    await this[_validateNodeModules](nm)\n\n    if (node.isLink) {\n      await rimraf(node.path)\n      await this[_symlink](node)\n    } else {\n      await debug(async () => {\n        const st = await lstat(node.path).catch(e => null)\n        if (st && !st.isDirectory()) {\n          debug.log('unpacking into a non-directory', node)\n          throw Object.assign(new Error('ENOTDIR: not a directory'), {\n            code: 'ENOTDIR',\n            path: node.path,\n          })\n        }\n      })\n      await pacote.extract(res, node.path, {\n        ...this.options,\n        resolved: node.resolved,\n        integrity: node.integrity,\n      })\n    }\n  }\n\n  async [_symlink] (node) {\n    const dir = dirname(node.path)\n    const target = node.realpath\n    const rel = relative(dir, target)\n    await mkdirp(dir)\n    return symlink(rel, node.path, 'junction')\n  }\n\n  [_warnDeprecated] (node) {\n    const {_id, deprecated} = node.package\n    if (deprecated) {\n      this.log.warn('deprecated', `${_id}: ${deprecated}`)\n    }\n  }\n\n  // if the node is optional, then the failure of the promise is nonfatal\n  // just add it and its optional set to the trash list.\n  [_handleOptionalFailure] (node, p) {\n    return (node.optional ? p.catch(er => {\n      const set = optionalSet(node)\n      for (node of set) {\n        this.log.verbose('reify', 'failed optional dependency', node.path)\n        this[_addNodeToTrashList](node)\n      }\n    }) : p).then(() => node)\n  }\n\n  [_registryResolved] (resolved) {\n    // the default registry url is a magic value meaning \"the currently\n    // configured registry\".\n    //\n    // XXX: use a magic string that isn't also a valid value, like\n    // ${REGISTRY} or something.  This has to be threaded through the\n    // Shrinkwrap and Node classes carefully, so for now, just treat\n    // the default reg as the magical animal that it has been.\n    return resolved && resolved\n      .replace(/^https?:\\/\\/registry.npmjs.org\\//, this.registry)\n  }\n\n  // bundles are *sort of* like shrinkwraps, in that the branch is defined\n  // by the contents of the package.  however, in their case, rather than\n  // shipping a virtual tree that must be reified, they ship an entire\n  // reified actual tree that must be unpacked and not modified.\n  [_loadBundlesAndUpdateTrees] (\n    depth = 0, bundlesByDepth = this[_getBundlesByDepth]()\n  ) {\n    if (depth === 0) {\n      process.emit('time', 'reify:loadBundles')\n    }\n\n    const maxBundleDepth = bundlesByDepth.get('maxBundleDepth')\n    if (depth > maxBundleDepth) {\n      // if we did something, then prune the tree and update the diffs\n      if (maxBundleDepth !== -1) {\n        this[_pruneBundledMetadeps](bundlesByDepth)\n        this[_diffTrees]()\n      }\n      process.emit('timeEnd', 'reify:loadBundles')\n      return\n    }\n\n    // skip any that have since been removed from the tree, eg by a\n    // shallower bundle overwriting them with a bundled meta-dep.\n    const set = (bundlesByDepth.get(depth) || [])\n      .filter(node => node.root === this.idealTree &&\n        node.target !== node.root &&\n        !this[_trashList].has(node.path))\n\n    if (!set.length) {\n      return this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth)\n    }\n\n    // extract all the nodes with bundles\n    return promiseAllRejectLate(set.map(node => {\n      this[_bundleUnpacked].add(node)\n      return this[_reifyNode](node)\n    }))\n    // then load their unpacked children and move into the ideal tree\n      .then(nodes =>\n        promiseAllRejectLate(nodes.map(async node => {\n          const arb = new this.constructor({\n            ...this.options,\n            path: node.path,\n          })\n          const notTransplanted = new Set(node.children.keys())\n          await arb.loadActual({\n            root: node,\n            // don't transplant any sparse folders we created\n            // loadActual will set node.package to {} for empty directories\n            // if by chance there are some empty folders in the node_modules\n            // tree for some other reason, then ok, ignore those too.\n            transplantFilter: node => {\n              if (node.package._id) {\n                // it's actually in the bundle if it gets transplanted\n                notTransplanted.delete(node.name)\n                return true\n              } else {\n                return false\n              }\n            },\n          })\n          for (const name of notTransplanted) {\n            this[_bundleMissing].add(node.children.get(name))\n          }\n        })))\n    // move onto the next level of bundled items\n      .then(() => this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth))\n  }\n\n  [_getBundlesByDepth] () {\n    const bundlesByDepth = new Map()\n    let maxBundleDepth = -1\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        const node = diff.ideal\n        if (!node) {\n          return\n        }\n        if (node.isProjectRoot) {\n          return\n        }\n\n        const { bundleDependencies } = node.package\n        if (bundleDependencies && bundleDependencies.length) {\n          maxBundleDepth = Math.max(maxBundleDepth, node.depth)\n          if (!bundlesByDepth.has(node.depth)) {\n            bundlesByDepth.set(node.depth, [node])\n          } else {\n            bundlesByDepth.get(node.depth).push(node)\n          }\n        }\n      },\n      getChildren: diff => diff.children,\n    })\n\n    bundlesByDepth.set('maxBundleDepth', maxBundleDepth)\n    return bundlesByDepth\n  }\n\n  // https://github.com/npm/cli/issues/1597#issuecomment-667639545\n  [_pruneBundledMetadeps] (bundlesByDepth) {\n    const bundleShadowed = new Set()\n\n    // Example dep graph:\n    // root -> (a, c)\n    // a -> BUNDLE(b)\n    // b -> c\n    // c -> b\n    //\n    // package tree:\n    // root\n    // +-- a\n    // |   +-- b(1)\n    // |   +-- c(1)\n    // +-- b(2)\n    // +-- c(2)\n    // 1. mark everything that's shadowed by anything in the bundle.  This\n    //    marks b(2) and c(2).\n    // 2. anything with edgesIn from outside the set, mark not-extraneous,\n    //    remove from set.  This unmarks c(2).\n    // 3. continue until no change\n    // 4. remove everything in the set from the tree.  b(2) is pruned\n\n    // create the list of nodes shadowed by children of bundlers\n    for (const bundles of bundlesByDepth.values()) {\n      // skip the 'maxBundleDepth' item\n      if (!Array.isArray(bundles)) {\n        continue\n      }\n      for (const node of bundles) {\n        for (const name of node.children.keys()) {\n          const shadow = node.parent.resolve(name)\n          if (!shadow) {\n            continue\n          }\n          bundleShadowed.add(shadow)\n          shadow.extraneous = true\n        }\n      }\n    }\n\n    // lib -> (a@1.x) BUNDLE(a@1.2.3 (b@1.2.3))\n    // a@1.2.3 -> (b@1.2.3)\n    // a@1.3.0 -> (b@2)\n    // b@1.2.3 -> ()\n    // b@2 -> (c@2)\n    //\n    // root\n    // +-- lib\n    // |   +-- a@1.2.3\n    // |   +-- b@1.2.3\n    // +-- b@2 <-- shadowed, now extraneous\n    // +-- c@2 <-- also shadowed, because only dependent is shadowed\n    for (const shadow of bundleShadowed) {\n      for (const shadDep of shadow.edgesOut.values()) {\n        /* istanbul ignore else - pretty unusual situation, just being\n         * defensive here. Would mean that a bundled dep has a dependency\n         * that is unmet. which, weird, but if you bundle it, we take\n         * whatever you put there and assume the publisher knows best. */\n        if (shadDep.to) {\n          bundleShadowed.add(shadDep.to)\n          shadDep.to.extraneous = true\n        }\n      }\n    }\n\n    let changed\n    do {\n      changed = false\n      for (const shadow of bundleShadowed) {\n        for (const edge of shadow.edgesIn) {\n          if (!bundleShadowed.has(edge.from)) {\n            shadow.extraneous = false\n            bundleShadowed.delete(shadow)\n            changed = true\n            break\n          }\n        }\n      }\n    } while (changed)\n\n    for (const shadow of bundleShadowed) {\n      this[_addNodeToTrashList](shadow)\n      shadow.root = null\n    }\n  }\n\n  [_submitQuickAudit] () {\n    if (this.options.audit === false) {\n      return this.auditReport = null\n    }\n\n    // we submit the quick audit at this point in the process, as soon as\n    // we have all the deps resolved, so that it can overlap with the other\n    // actions as much as possible.  Stash the promise, which we resolve\n    // before finishing the reify() and returning the tree.  Thus, we do\n    // NOT return the promise, as the intent is for this to run in parallel\n    // with the reification, and be resolved at a later time.\n    process.emit('time', 'reify:audit')\n    const options = { ...this.options }\n    const tree = this.idealTree\n\n    // if we're operating on a workspace, only audit the workspace deps\n    if (this[_workspaces] && this[_workspaces].length) {\n      options.filterSet = this.workspaceDependencySet(tree, this[_workspaces])\n    }\n\n    this.auditReport = AuditReport.load(tree, options)\n      .then(res => {\n        process.emit('timeEnd', 'reify:audit')\n        this.auditReport = res\n      })\n  }\n\n  // return the promise if we're waiting for it, or the replaced result\n  [_awaitQuickAudit] () {\n    return this.auditReport\n  }\n\n  // ok!  actually unpack stuff into their target locations!\n  // The sparse tree has already been created, so we walk the diff\n  // kicking off each unpack job.  If any fail, we rimraf the sparse\n  // tree entirely and try to put everything back where it was.\n  [_unpackNewModules] () {\n    process.emit('time', 'reify:unpack')\n    const unpacks = []\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        // no unpacking if we don't want to change this thing\n        if (diff.action !== 'CHANGE' && diff.action !== 'ADD') {\n          return\n        }\n\n        const node = diff.ideal\n        const bd = this[_bundleUnpacked].has(node)\n        const sw = this[_shrinkwrapInflated].has(node)\n        const bundleMissing = this[_bundleMissing].has(node)\n\n        // check whether we still need to unpack this one.\n        // test the inDepBundle last, since that's potentially a tree walk.\n        const doUnpack = node && // can't unpack if removed!\n          // root node already exists\n          !node.isRoot &&\n          // already unpacked to read bundle\n          !bd &&\n          // already unpacked to read sw\n          !sw &&\n          // already unpacked by another dep's bundle\n          (bundleMissing || !node.inDepBundle)\n\n        if (doUnpack) {\n          unpacks.push(this[_reifyNode](node))\n        }\n      },\n      getChildren: diff => diff.children,\n    })\n    return promiseAllRejectLate(unpacks)\n      .then(() => process.emit('timeEnd', 'reify:unpack'))\n  }\n\n  // This is the part where we move back the unchanging nodes that were\n  // the children of a node that did change.  If this fails, the rollback\n  // is a three-step process.  First, we try to move the retired unchanged\n  // nodes BACK to their retirement folders, then delete the sparse tree,\n  // then move everything out of retirement.\n  [_moveBackRetiredUnchanged] () {\n    // get a list of all unchanging children of any shallow retired nodes\n    // if they are not the ancestor of any node in the diff set, then the\n    // directory won't already exist, so just rename it over.\n    // This is sort of an inverse diff tree, of all the nodes where\n    // the actualTree and idealTree _don't_ differ, starting from the\n    // shallowest nodes that we moved aside in the first place.\n    process.emit('time', 'reify:unretire')\n    const moves = this[_retiredPaths]\n    this[_retiredUnchanged] = {}\n    return promiseAllRejectLate(this.diff.children.map(diff => {\n      // skip if nothing was retired\n      if (diff.action !== 'CHANGE' && diff.action !== 'REMOVE') {\n        return\n      }\n\n      const { path: realFolder } = diff.actual\n      const retireFolder = moves[realFolder]\n      /* istanbul ignore next - should be impossible */\n      debug(() => {\n        if (!retireFolder) {\n          const er = new Error('trying to un-retire but not retired')\n          throw Object.assign(er, {\n            realFolder,\n            retireFolder,\n            actual: diff.actual,\n            ideal: diff.ideal,\n            action: diff.action,\n          })\n        }\n      })\n\n      this[_retiredUnchanged][retireFolder] = []\n      return promiseAllRejectLate(diff.unchanged.map(node => {\n        // no need to roll back links, since we'll just delete them anyway\n        if (node.isLink) {\n          return mkdirp(dirname(node.path)).then(() => this[_reifyNode](node))\n        }\n\n        // will have been moved/unpacked along with bundler\n        if (node.inDepBundle && !this[_bundleMissing].has(node)) {\n          return\n        }\n\n        this[_retiredUnchanged][retireFolder].push(node)\n\n        const rel = relative(realFolder, node.path)\n        const fromPath = resolve(retireFolder, rel)\n        // if it has bundleDependencies, then make node_modules.  otherwise\n        // skip it.\n        const bd = node.package.bundleDependencies\n        const dir = bd && bd.length ? node.path + '/node_modules' : node.path\n        return mkdirp(dir).then(() => this[_moveContents](node, fromPath))\n      }))\n    }))\n      .then(() => process.emit('timeEnd', 'reify:unretire'))\n  }\n\n  // move the contents from the fromPath to the node.path\n  [_moveContents] (node, fromPath) {\n    return packageContents({\n      path: fromPath,\n      depth: 1,\n      packageJsonCache: new Map([[fromPath + '/package.json', node.package]]),\n    }).then(res => promiseAllRejectLate(res.map(path => {\n      const rel = relative(fromPath, path)\n      const to = resolve(node.path, rel)\n      return this[_renamePath](path, to)\n    })))\n  }\n\n  [_rollbackMoveBackRetiredUnchanged] (er) {\n    const moves = this[_retiredPaths]\n    // flip the mapping around to go back\n    const realFolders = new Map(Object.entries(moves).map(([k, v]) => [v, k]))\n    const promises = Object.entries(this[_retiredUnchanged])\n      .map(([retireFolder, nodes]) => promiseAllRejectLate(nodes.map(node => {\n        const realFolder = realFolders.get(retireFolder)\n        const rel = relative(realFolder, node.path)\n        const fromPath = resolve(retireFolder, rel)\n        return this[_moveContents]({ ...node, path: fromPath }, node.path)\n      })))\n    return promiseAllRejectLate(promises)\n      .then(() => this[_rollbackCreateSparseTree](er))\n  }\n\n  [_build] () {\n    process.emit('time', 'reify:build')\n\n    // for all the things being installed, run their appropriate scripts\n    // run in tip->root order, so as to be more likely to build a node's\n    // deps before attempting to build it itself\n    const nodes = []\n    dfwalk({\n      tree: this.diff,\n      leave: diff => {\n        if (!diff.ideal.isProjectRoot) {\n          nodes.push(diff.ideal)\n        }\n      },\n      // process adds before changes, ignore removals\n      getChildren: diff => diff && diff.children,\n      filter: diff => diff.action === 'ADD' || diff.action === 'CHANGE',\n    })\n\n    // pick up link nodes from the unchanged list as we want to run their\n    // scripts in every install despite of having a diff status change\n    for (const node of this.diff.unchanged) {\n      const tree = node.root.target\n\n      // skip links that only live within node_modules as they are most\n      // likely managed by packages we installed, we only want to rebuild\n      // unchanged links we directly manage\n      if (node.isLink && node.target.fsTop === tree) {\n        nodes.push(node)\n      }\n    }\n\n    return this.rebuild({ nodes, handleOptionalFailure: true })\n      .then(() => process.emit('timeEnd', 'reify:build'))\n  }\n\n  // the tree is pretty much built now, so it's cleanup time.\n  // remove the retired folders, and any deleted nodes\n  // If this fails, there isn't much we can do but tell the user about it.\n  // Thankfully, it's pretty unlikely that it'll fail, since rimraf is a tank.\n  [_removeTrash] () {\n    process.emit('time', 'reify:trash')\n    const promises = []\n    const failures = []\n    const rm = path => rimraf(path).catch(er => failures.push([path, er]))\n\n    for (const path of this[_trashList]) {\n      promises.push(rm(path))\n    }\n\n    return promiseAllRejectLate(promises).then(() => {\n      if (failures.length) {\n        this.log.warn('cleanup', 'Failed to remove some directories', failures)\n      }\n    })\n      .then(() => process.emit('timeEnd', 'reify:trash'))\n  }\n\n  // last but not least, we save the ideal tree metadata to the package-lock\n  // or shrinkwrap file, and any additions or removals to package.json\n  async [_saveIdealTree] (options) {\n    // the ideal tree is actualized now, hooray!\n    // it still contains all the references to optional nodes that were removed\n    // for install failures.  Those still end up in the shrinkwrap, so we\n    // save it first, then prune out the optional trash, and then return it.\n\n    // support save=false option\n    if (options.save === false || this[_global] || this[_dryRun]) {\n      return false\n    }\n\n    process.emit('time', 'reify:save')\n\n    const updatedTrees = new Set()\n\n    // resolvedAdd is the list of user add requests, but with names added\n    // to things like git repos and tarball file/urls.  However, if the\n    // user requested 'foo@', and we have a foo@file:../foo, then we should\n    // end up saving the spec we actually used, not whatever they gave us.\n    if (this[_resolvedAdd].length) {\n      for (const { name, tree: addTree } of this[_resolvedAdd]) {\n        // addTree either the root, or a workspace\n        const edge = addTree.edgesOut.get(name)\n        const pkg = addTree.package\n        const req = npa.resolve(name, edge.spec, addTree.realpath)\n        const {rawSpec, subSpec} = req\n\n        const spec = subSpec ? subSpec.rawSpec : rawSpec\n        const child = edge.to\n\n        // if we tried to install an optional dep, but it was a version\n        // that we couldn't resolve, this MAY be missing.  if we haven't\n        // blown up by now, it's because it was not a problem, though, so\n        // just move on.\n        if (!child) {\n          continue\n        }\n\n        let newSpec\n        if (req.registry) {\n          const version = child.version\n          const prefixRange = version ? this[_savePrefix] + version : '*'\n          // if we installed a range, then we save the range specified\n          // if it is not a subset of the ^x.y.z.  eg, installing a range\n          // of `1.x <1.2.3` will not be saved as `^1.2.0`, because that\n          // would allow versions outside the requested range.  Tags and\n          // specific versions save with the save-prefix.\n          const isRange = (subSpec || req).type === 'range'\n\n          let range = spec\n          if (\n            !isRange ||\n            spec === '*' ||\n            subset(prefixRange, spec, { loose: true })\n          ) {\n            range = prefixRange\n          }\n\n          const pname = child.packageName\n          const alias = name !== pname\n          newSpec = alias ? `npm:${pname}@${range}` : range\n        } else if (req.hosted) {\n          // save the git+https url if it has auth, otherwise shortcut\n          const h = req.hosted\n          const opt = { noCommittish: false }\n          if (h.https && h.auth) {\n            newSpec = `git+${h.https(opt)}`\n          } else {\n            newSpec = h.shortcut(opt)\n          }\n        } else if (req.type === 'directory' || req.type === 'file') {\n          // save the relative path in package.json\n          // Normally saveSpec is updated with the proper relative\n          // path already, but it's possible to specify a full absolute\n          // path initially, in which case we can end up with the wrong\n          // thing, so just get the ultimate fetchSpec and relativize it.\n          const p = req.fetchSpec.replace(/^file:/, '')\n          const rel = relpath(addTree.realpath, p)\n          newSpec = `file:${rel}`\n        } else {\n          newSpec = req.saveSpec\n        }\n\n        if (options.saveType) {\n          const depType = saveTypeMap.get(options.saveType)\n          pkg[depType][name] = newSpec\n          // rpj will have moved it here if it was in both\n          // if it is empty it will be deleted later\n          if (options.saveType === 'prod' && pkg.optionalDependencies) {\n            delete pkg.optionalDependencies[name]\n          }\n        } else {\n          if (hasSubKey(pkg, 'dependencies', name)) {\n            pkg.dependencies[name] = newSpec\n          }\n\n          if (hasSubKey(pkg, 'devDependencies', name)) {\n            pkg.devDependencies[name] = newSpec\n            // don't update peer or optional if we don't have to\n            if (hasSubKey(pkg, 'peerDependencies', name) && !intersects(newSpec, pkg.peerDependencies[name])) {\n              pkg.peerDependencies[name] = newSpec\n            }\n\n            if (hasSubKey(pkg, 'optionalDependencies', name) && !intersects(newSpec, pkg.optionalDependencies[name])) {\n              pkg.optionalDependencies[name] = newSpec\n            }\n          } else {\n            if (hasSubKey(pkg, 'peerDependencies', name)) {\n              pkg.peerDependencies[name] = newSpec\n            }\n\n            if (hasSubKey(pkg, 'optionalDependencies', name)) {\n              pkg.optionalDependencies[name] = newSpec\n            }\n          }\n        }\n\n        updatedTrees.add(addTree)\n      }\n    }\n\n    // preserve indentation, if possible\n    const {\n      [Symbol.for('indent')]: indent,\n    } = this.idealTree.package\n    const format = indent === undefined ? '  ' : indent\n\n    const saveOpt = {\n      format: (this[_formatPackageLock] && format) ? format\n      : this[_formatPackageLock],\n    }\n\n    const promises = [this[_saveLockFile](saveOpt)]\n\n    const updatePackageJson = async (tree) => {\n      const pkgJson = await PackageJson.load(tree.path)\n        .catch(() => new PackageJson(tree.path))\n      const {\n        dependencies = {},\n        devDependencies = {},\n        optionalDependencies = {},\n        peerDependencies = {},\n      } = tree.package\n\n      pkgJson.update({\n        dependencies,\n        devDependencies,\n        optionalDependencies,\n        peerDependencies,\n      })\n      await pkgJson.save()\n    }\n\n    // grab any from explicitRequests that had deps removed\n    for (const { from: tree } of this.explicitRequests) {\n      updatedTrees.add(tree)\n    }\n\n    for (const tree of updatedTrees) {\n      // refresh the edges so they have the correct specs\n      tree.package = tree.package\n      promises.push(updatePackageJson(tree))\n    }\n\n    await Promise.all(promises)\n    process.emit('timeEnd', 'reify:save')\n    return true\n  }\n\n  async [_saveLockFile] (saveOpt) {\n    if (!this[_usePackageLock]) {\n      return\n    }\n\n    const { meta } = this.idealTree\n\n    return meta.save(saveOpt)\n  }\n\n  async [_copyIdealToActual] () {\n    // clean up any trash that is still in the tree\n    for (const path of this[_trashList]) {\n      const loc = relpath(this.idealTree.realpath, path)\n      const node = this.idealTree.inventory.get(loc)\n      if (node && node.root === this.idealTree) {\n        node.parent = null\n      }\n    }\n\n    // if we filtered to only certain nodes, then anything ELSE needs\n    // to be untouched in the resulting actual tree, even if it differs\n    // in the idealTree.  Copy over anything that was in the actual and\n    // was not changed, delete anything in the ideal and not actual.\n    // Then we move the entire idealTree over to this.actualTree, and\n    // save the hidden lockfile.\n    if (this.diff && this.diff.filterSet.size) {\n      const reroot = new Set()\n\n      const { filterSet } = this.diff\n      const seen = new Set()\n      for (const [loc, ideal] of this.idealTree.inventory.entries()) {\n        seen.add(loc)\n\n        // if it's an ideal node from the filter set, then skip it\n        // because we already made whatever changes were necessary\n        if (filterSet.has(ideal)) {\n          continue\n        }\n\n        // otherwise, if it's not in the actualTree, then it's not a thing\n        // that we actually added.  And if it IS in the actualTree, then\n        // it's something that we left untouched, so we need to record\n        // that.\n        const actual = this.actualTree.inventory.get(loc)\n        if (!actual) {\n          ideal.root = null\n        } else {\n          if ([...actual.linksIn].some(link => filterSet.has(link))) {\n            seen.add(actual.location)\n            continue\n          }\n          const { realpath, isLink } = actual\n          if (isLink && ideal.isLink && ideal.realpath === realpath) {\n            continue\n          } else {\n            reroot.add(actual)\n          }\n        }\n      }\n\n      // now find any actual nodes that may not be present in the ideal\n      // tree, but were left behind by virtue of not being in the filter\n      for (const [loc, actual] of this.actualTree.inventory.entries()) {\n        if (seen.has(loc)) {\n          continue\n        }\n        seen.add(loc)\n\n        // we know that this is something that ISN'T in the idealTree,\n        // or else we will have addressed it in the previous loop.\n        // If it's in the filterSet, that means we intentionally removed\n        // it, so nothing to do here.\n        if (filterSet.has(actual)) {\n          continue\n        }\n\n        reroot.add(actual)\n      }\n\n      // go through the rerooted actual nodes, and move them over.\n      for (const actual of reroot) {\n        actual.root = this.idealTree\n      }\n\n      // prune out any tops that lack a linkIn, they are no longer relevant.\n      for (const top of this.idealTree.tops) {\n        if (top.linksIn.size === 0) {\n          top.root = null\n        }\n      }\n\n      // need to calculate dep flags, since nodes may have been marked\n      // as extraneous or otherwise incorrect during transit.\n      calcDepFlags(this.idealTree)\n    }\n\n    // save the ideal's meta as a hidden lockfile after we actualize it\n    this.idealTree.meta.filename =\n      this.idealTree.realpath + '/node_modules/.package-lock.json'\n    this.idealTree.meta.hiddenLockfile = true\n\n    this.actualTree = this.idealTree\n    this.idealTree = null\n\n    if (!this[_global]) {\n      await this.actualTree.meta.save()\n    }\n  }\n}\n"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,uBAAuB,CAAC;AAC/C,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAME,WAAW,GAAGF,OAAO,CAAC,oBAAoB,CAAC;AACjD,MAAM;EAACG,MAAM;EAAEC;AAAU,CAAC,GAAGJ,OAAO,CAAC,QAAQ,CAAC;AAC9C,MAAMK,GAAG,GAAGL,OAAO,CAAC,iBAAiB,CAAC;AACtC,MAAMM,KAAK,GAAGN,OAAO,CAAC,aAAa,CAAC;AACpC,MAAMO,MAAM,GAAGP,OAAO,CAAC,cAAc,CAAC;AAEtC,MAAM;EAACQ,OAAO;EAAEC,OAAO;EAAEC;AAAQ,CAAC,GAAGV,OAAO,CAAC,MAAM,CAAC;AACpD,MAAM;EAACW,KAAK,EAAEC;AAAM,CAAC,GAAGZ,OAAO,CAAC,WAAW,CAAC;AAC5C,MAAMa,EAAE,GAAGb,OAAO,CAAC,IAAI,CAAC;AACxB,MAAM;EAACc;AAAS,CAAC,GAAGd,OAAO,CAAC,MAAM,CAAC;AACnC,MAAMe,KAAK,GAAGD,SAAS,CAACD,EAAE,CAACE,KAAK,CAAC;AACjC,MAAMC,OAAO,GAAGF,SAAS,CAACD,EAAE,CAACG,OAAO,CAAC;AACrC,MAAMC,MAAM,GAAGjB,OAAO,CAAC,oBAAoB,CAAC;AAC5C,MAAMkB,UAAU,GAAGlB,OAAO,CAAC,QAAQ,CAAC;AACpC,MAAMmB,QAAQ,GAAGnB,OAAO,CAAC,mBAAmB,CAAC;AAC7C,MAAMoB,MAAM,GAAGN,SAAS,CAACd,OAAO,CAAC,QAAQ,CAAC,CAAC;AAC3C,MAAMqB,WAAW,GAAGrB,OAAO,CAAC,sBAAsB,CAAC;AACnD,MAAMsB,eAAe,GAAGtB,OAAO,CAAC,oCAAoC,CAAC;AACrE,MAAM;EAAEuB,WAAW;EAAEC;AAAc,CAAC,GAAGxB,OAAO,CAAC,oBAAoB,CAAC;AACpE,MAAMyB,MAAM,GAAGC,MAAM,CAACC,GAAG,CAAC,OAAO,CAAC;AAElC,MAAMC,SAAS,GAAG5B,OAAO,CAAC,kBAAkB,CAAC;AAC7C,MAAM6B,OAAO,GAAG7B,OAAO,CAAC,eAAe,CAAC;AACxC,MAAM8B,IAAI,GAAG9B,OAAO,CAAC,YAAY,CAAC;AAClC,MAAM+B,UAAU,GAAG/B,OAAO,CAAC,mBAAmB,CAAC;AAC/C,MAAMgC,oBAAoB,GAAGhC,OAAO,CAAC,yBAAyB,CAAC;AAC/D,MAAMiC,WAAW,GAAGjC,OAAO,CAAC,oBAAoB,CAAC;AACjD,MAAMkC,YAAY,GAAGlC,OAAO,CAAC,sBAAsB,CAAC;AACpD,MAAM;EAAEmC,WAAW;EAAEC;AAAU,CAAC,GAAGpC,OAAO,CAAC,uBAAuB,CAAC;AAEnE,MAAMqC,aAAa,GAAGX,MAAM,CAAC,cAAc,CAAC;AAC5C,MAAMY,iBAAiB,GAAGZ,MAAM,CAAC,kBAAkB,CAAC;AACpD,MAAMa,eAAe,GAAGb,MAAM,CAAC,gBAAgB,CAAC;AAChD,MAAMc,gBAAgB,GAAGd,MAAM,CAAC,iBAAiB,CAAC;AAClD,MAAMe,WAAW,GAAGf,MAAM,CAAC,YAAY,CAAC;AACxC,MAAMgB,mBAAmB,GAAGhB,MAAM,CAACC,GAAG,CAAC,oBAAoB,CAAC;AAC5D,MAAMgB,kBAAkB,GAAGjB,MAAM,CAAC,mBAAmB,CAAC;AACtD,MAAMkB,iBAAiB,GAAGlB,MAAM,CAAC,kBAAkB,CAAC;AACpD,MAAMmB,mBAAmB,GAAGnB,MAAM,CAAC,oBAAoB,CAAC;AACxD,MAAMoB,WAAW,GAAGpB,MAAM,CAACC,GAAG,CAAC,YAAY,CAAC;;AAE5C;AACA,MAAMoB,UAAU,GAAGrB,MAAM,CAACC,GAAG,CAAC,WAAW,CAAC;AAC1C,MAAMqB,sBAAsB,GAAGtB,MAAM,CAACC,GAAG,CAAC,uBAAuB,CAAC;AAClE,MAAMsB,UAAU,GAAGvB,MAAM,CAACC,GAAG,CAAC,WAAW,CAAC;;AAE1C;AACA,MAAMuB,UAAU,GAAGxB,MAAM,CAACC,GAAG,CAAC,WAAW,CAAC;AAC1C,MAAMwB,iBAAiB,GAAGzB,MAAM,CAACC,GAAG,CAAC,kBAAkB,CAAC;AACxD,MAAMyB,8BAA8B,GAAG1B,MAAM,CAACC,GAAG,CAAC,+BAA+B,CAAC;AAClF,MAAM0B,mBAAmB,GAAG3B,MAAM,CAAC,oBAAoB,CAAC;AACxD,MAAM4B,eAAe,GAAG5B,MAAM,CAAC,gBAAgB,CAAC;AAChD,MAAM6B,cAAc,GAAG7B,MAAM,CAAC,eAAe,CAAC;AAC9C,MAAM8B,UAAU,GAAG9B,MAAM,CAACC,GAAG,CAAC,WAAW,CAAC;AAC1C,MAAM8B,cAAc,GAAG/B,MAAM,CAAC,eAAe,CAAC;AAC9C;AACA,MAAMgC,UAAU,GAAGhC,MAAM,CAACC,GAAG,CAAC,WAAW,CAAC;AAC1C,MAAMgC,QAAQ,GAAGjC,MAAM,CAAC,SAAS,CAAC;AAClC,MAAMkC,eAAe,GAAGlC,MAAM,CAAC,gBAAgB,CAAC;AAChD,MAAMmC,0BAA0B,GAAGnC,MAAM,CAACC,GAAG,CAAC,2BAA2B,CAAC;AAC1E,MAAMmC,iBAAiB,GAAGpC,MAAM,CAAC,kBAAkB,CAAC;AACpD,MAAMqC,gBAAgB,GAAGrC,MAAM,CAAC,iBAAiB,CAAC;AAClD,MAAMsC,iBAAiB,GAAGtC,MAAM,CAACC,GAAG,CAAC,kBAAkB,CAAC;AACxD,MAAMsC,aAAa,GAAGvC,MAAM,CAACC,GAAG,CAAC,cAAc,CAAC;AAChD,MAAMuC,yBAAyB,GAAGxC,MAAM,CAACC,GAAG,CAAC,0BAA0B,CAAC;AACxE,MAAMwC,MAAM,GAAGzC,MAAM,CAACC,GAAG,CAAC,OAAO,CAAC;AAClC,MAAMyC,YAAY,GAAG1C,MAAM,CAACC,GAAG,CAAC,aAAa,CAAC;AAC9C,MAAM0C,WAAW,GAAG3C,MAAM,CAACC,GAAG,CAAC,YAAY,CAAC;AAC5C,MAAM2C,2BAA2B,GAAG5C,MAAM,CAACC,GAAG,CAAC,4BAA4B,CAAC;AAC5E,MAAM4C,yBAAyB,GAAG7C,MAAM,CAACC,GAAG,CAAC,0BAA0B,CAAC;AACxE,MAAM6C,iCAAiC,GAAG9C,MAAM,CAACC,GAAG,CAAC,kCAAkC,CAAC;AACxF,MAAM8C,cAAc,GAAG/C,MAAM,CAACC,GAAG,CAAC,eAAe,CAAC;AAClD,MAAM+C,aAAa,GAAGhD,MAAM,CAAC,cAAc,CAAC;AAC5C,MAAMiD,kBAAkB,GAAGjD,MAAM,CAAC,mBAAmB,CAAC;AACtD,MAAMkD,oBAAoB,GAAGlD,MAAM,CAAC,qBAAqB,CAAC;AAC1D,MAAMmD,gBAAgB,GAAGnD,MAAM,CAAC,iBAAiB,CAAC;AAClD,MAAMoD,OAAO,GAAGpD,MAAM,CAAC,QAAQ,CAAC;AAChC,MAAMqD,oBAAoB,GAAGrD,MAAM,CAAC,qBAAqB,CAAC;AAC1D,MAAMsD,YAAY,GAAGtD,MAAM,CAAC,aAAa,CAAC;AAC1C,MAAMuD,aAAa,GAAGvD,MAAM,CAAC,cAAc,CAAC;AAC5C,MAAMwD,cAAc,GAAGxD,MAAM,CAACC,GAAG,CAAC,eAAe,CAAC;AAElD,MAAMwD,QAAQ,GAAGzD,MAAM,CAAC,SAAS,CAAC;AAClC,MAAM0D,aAAa,GAAG1D,MAAM,CAAC,cAAc,CAAC;AAC5C,MAAM2D,SAAS,GAAG3D,MAAM,CAAC,UAAU,CAAC;AAEpC,MAAM4D,OAAO,GAAG5D,MAAM,CAACC,GAAG,CAAC,QAAQ,CAAC;AAEpC,MAAM4D,qBAAqB,GAAG7D,MAAM,CAAC,sBAAsB,CAAC;;AAE5D;AACA,MAAM8D,YAAY,GAAG9D,MAAM,CAACC,GAAG,CAAC,aAAa,CAAC;AAC9C,MAAM8D,eAAe,GAAG/D,MAAM,CAACC,GAAG,CAAC,gBAAgB,CAAC;AACpD,MAAM+D,kBAAkB,GAAGhE,MAAM,CAACC,GAAG,CAAC,mBAAmB,CAAC;AAE1DgE,MAAM,CAACC,OAAO,GAAGC,GAAG,IAAI,MAAMC,OAAO,SAASD,GAAG,CAAC;EAChDE,WAAWA,CAAEC,OAAO,EAAE;IACpB,KAAK,CAACA,OAAO,CAAC;IAEd,MAAM;MACJC,UAAU,GAAG,GAAG;MAChBC,eAAe,GAAG,KAAK;MACvBC,MAAM,GAAG,KAAK;MACdC,iBAAiB,GAAG;IACtB,CAAC,GAAGJ,OAAO;IAEX,IAAI,CAAClB,OAAO,CAAC,GAAG,CAAC,CAACqB,MAAM;IACxB,IAAI,CAACtB,gBAAgB,CAAC,GAAG,CAAC,CAACqB,eAAe;IAC1C,IAAI,CAACzD,WAAW,CAAC,GAAGwD,UAAU;IAC9B,IAAI,CAACP,kBAAkB,CAAC,GAAG,CAAC,CAACU,iBAAiB;IAE9C,IAAI,CAACC,IAAI,GAAG,IAAI;IAChB,IAAI,CAAChE,aAAa,CAAC,GAAG,CAAC,CAAC;IACxB,IAAI,CAACgB,mBAAmB,CAAC,GAAG,IAAIiD,GAAG,CAAC,CAAC;IACrC,IAAI,CAAChE,iBAAiB,CAAC,GAAG,CAAC,CAAC;IAC5B,IAAI,CAACC,eAAe,CAAC,GAAG,IAAI+D,GAAG,CAAC,CAAC;IACjC,IAAI,CAAC9D,gBAAgB,CAAC,GAAG,IAAI8D,GAAG,CAAC,CAAC;IAClC,IAAI,CAACvD,UAAU,CAAC,GAAG,IAAIuD,GAAG,CAAC,CAAC;IAC5B;IACA,IAAI,CAAChD,eAAe,CAAC,GAAG,IAAIgD,GAAG,CAAC,CAAC;IACjC;IACA,IAAI,CAAC/C,cAAc,CAAC,GAAG,IAAI+C,GAAG,CAAC,CAAC;IAChC,IAAI,CAACtB,YAAY,CAAC,GAAG,IAAIsB,GAAG,CAAC,CAAC;EAChC;;EAEA;EACA,MAAMC,KAAKA,CAAEP,OAAO,GAAG,CAAC,CAAC,EAAE;IACzB,IAAI,IAAI,CAACnB,gBAAgB,CAAC,IAAI,IAAI,CAACS,OAAO,CAAC,EAAE;MAC3C,MAAMkB,EAAE,GAAG,IAAIC,KAAK,CAAC,8CAA8C,CAAC;MACpED,EAAE,CAACE,IAAI,GAAG,mBAAmB;MAC7B,MAAMF,EAAE;IACV;IAEA,MAAMG,IAAI,GAAG,IAAIL,GAAG,CAACN,OAAO,CAACW,IAAI,IAAI,EAAE,CAAC;IACxC,IAAI,CAACxB,QAAQ,CAAC,GAAGwB,IAAI,CAACC,GAAG,CAAC,KAAK,CAAC;IAChC,IAAI,CAACxB,aAAa,CAAC,GAAGuB,IAAI,CAACC,GAAG,CAAC,UAAU,CAAC;IAC1C,IAAI,CAACvB,SAAS,CAAC,GAAGsB,IAAI,CAACC,GAAG,CAAC,MAAM,CAAC;;IAElC;IACA,IAAI,CAACC,UAAU,CAAC,OAAO,CAAC;IACxBC,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC;IAC7B,MAAM,IAAI,CAAC9B,aAAa,CAAC,CAAC,CAAC;IAC3B,MAAM,IAAI,CAAChC,UAAU,CAAC,CAAC+C,OAAO,CAAC;IAC/B,MAAM,IAAI,CAAC9C,UAAU,CAAC,CAAC,CAAC;IACxB,MAAM,IAAI,CAACgC,cAAc,CAAC,CAAC,CAAC;IAC5B,MAAM,IAAI,CAACT,cAAc,CAAC,CAACuB,OAAO,CAAC;IACnC,MAAM,IAAI,CAACrB,kBAAkB,CAAC,CAAC,CAAC;IAChC,MAAM,IAAI,CAACZ,gBAAgB,CAAC,CAAC,CAAC;IAE9B,IAAI,CAACiD,aAAa,CAAC,OAAO,CAAC;IAC3BF,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,OAAO,CAAC;IAChC,OAAOnF,SAAS,CAAC,IAAI,CAACqF,UAAU,CAAC;EACnC;EAEA,OAAOhC,aAAa,IAAK;IACvB;IACA,IAAI,IAAI,CAACJ,gBAAgB,CAAC,IAAI,IAAI,CAACC,OAAO,CAAC,EAAE;MAC3C;IACF;;IAEA;IACA;IACA;IACA,MAAM5D,UAAU,CAACT,OAAO,CAAC,IAAI,CAACyG,IAAI,CAAC,CAAC;;IAEpC;IACA,MAAM,IAAI,CAACnC,oBAAoB,CAAC,CAACtE,OAAO,CAAC,IAAI,CAACyG,IAAI,EAAE,cAAc,CAAC,CAAC;EACtE;EAEA,OAAOhC,cAAc,IAAK;IACxB;IACA,IAAI,IAAI,CAACJ,OAAO,CAAC,EAAE;MACjB;IACF;IAEA,IAAI,IAAI,CAACD,gBAAgB,CAAC,EAAE;MAC1B;MACA;MACA,OAAO,IAAI,CAACf,iBAAiB,CAAC,CAAC,CAAC;IAClC;;IAEA;IACA;IACA,IAAIqD,eAAe,GAAG,IAAI;IAC1B,MAAMC,aAAa,GAAGrH,MAAM,CAAC,CAAC;MAACsH;IAAM,CAAC,KAAK;MACzC;MACAD,aAAa,CAAC,CAAC;MACfD,eAAe,GAAGG,MAAM,CAACC,MAAM,CAAC,IAAId,KAAK,CAAC,oBAAoB,CAAC,EAAE;QAC/DY;MACF,CAAC,CAAC;MACF,OAAO,KAAK;IACd,CAAC,CAAC;;IAEF;IACA;IACA;IACA;IACA;IACA;IACA,MAAMG,KAAK,GAAG,CACZ,CAAClD,2BAA2B,EAAE,CAC5B5B,mBAAmB,CACpB,CAAC,EACF,CAAC6B,yBAAyB,EAAE,CAC1BpB,iBAAiB,EACjByB,oBAAoB,EACpBxB,8BAA8B,EAC9BS,0BAA0B,EAC1BC,iBAAiB,EACjBE,iBAAiB,CAClB,CAAC,EACF,CAACQ,iCAAiC,EAAE,CAClCN,yBAAyB,EACzBC,MAAM,CACP,CAAC,CACH;IACD,KAAK,MAAM,CAACsD,QAAQ,EAAEC,OAAO,CAAC,IAAIF,KAAK,EAAE;MACvC,KAAK,MAAMG,MAAM,IAAID,OAAO,EAAE;QAC5B,IAAI;UACF,MAAM,IAAI,CAACC,MAAM,CAAC,CAAC,CAAC;UACpB,IAAIR,eAAe,EAAE;YACnB,MAAMA,eAAe;UACvB;QACF,CAAC,CAAC,OAAOX,EAAE,EAAE;UACX,MAAM,IAAI,CAACiB,QAAQ,CAAC,CAACjB,EAAE,CAAC;UACxB;UACA,MAAMA,EAAE;QACV;MACF;IACF;;IAEA;IACA;IACA,MAAM,IAAI,CAACpC,YAAY,CAAC,CAAC,CAAC;IAC1B,IAAI+C,eAAe,EAAE;MACnB,MAAMA,eAAe;IACvB;;IAEA;IACAC,aAAa,CAAC,CAAC;EACjB;;EAEA;EACA;EACA,CAACnE,UAAU,EAAG+C,OAAO,EAAE;IACrBc,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,iBAAiB,CAAC;IACvC,MAAMa,MAAM,GAAG;MACb,GAAG5B,OAAO;MACV6B,QAAQ,EAAE,IAAI,CAAChD,gBAAgB,CAAC,IAAI,IAAI,CAACC,OAAO;IAClD,CAAC;;IAED;IACA,IAAI,IAAI,CAACD,gBAAgB,CAAC,EAAE;MAC1B,OAAO,IAAI,CAACiD,cAAc,CAACF,MAAM,CAAC,CAC/BG,IAAI,CAAC,MAAMjB,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,iBAAiB,CAAC,CAAC;IAC3D;IAEA,MAAMiB,SAAS,GAAG,IAAI,CAAC1C,OAAO,CAAC,GAAG;MAChC2C,aAAa,EAAE,IAAI;MACnBC,MAAM,EAAE,IAAI;MACZC,MAAM,EAAEA,CAACC,IAAI,EAAEC,GAAG,KAAK;QACrB;QACA;QACA,IAAI,IAAI,CAACC,gBAAgB,CAACC,IAAI,KAAK,CAAC,IAAI,CAACH,IAAI,CAACI,aAAa,EAAE;UAC3D,OAAO,IAAI;QACb;;QAEA;QACA,IAAI,IAAI,CAACC,SAAS,CAACC,QAAQ,CAAC9B,GAAG,CAACyB,GAAG,CAAC,EAAE;UACpC,OAAO,IAAI;QACb;;QAEA;QACA,MAAMM,WAAW,GAAG,CAAC,GAAG,IAAI,CAACL,gBAAgB,CAAC,CAC3CM,IAAI,CAACC,IAAI,IAAIA,IAAI,CAACC,IAAI,KAAKT,GAAG,CAAC;QAClC,IAAIM,WAAW,EAAE;UACf,OAAO,IAAI;QACb;;QAEA;QACA,OAAO,KAAK;MACd;IACF,CAAC,GAAG;MAAEV,aAAa,EAAE;IAAK,CAAC;IAE3B,IAAI,CAAC,IAAI,CAAC3C,OAAO,CAAC,EAAE;MAClB,OAAOyD,OAAO,CAACC,GAAG,CAAC,CACjB,IAAI,CAACC,UAAU,CAACjB,SAAS,CAAC,EAC1B,IAAI,CAACF,cAAc,CAACF,MAAM,CAAC,CAC5B,CAAC,CAACG,IAAI,CAAC,MAAMjB,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,iBAAiB,CAAC,CAAC;IAC3D;;IAEA;IACA;IACA;IACA;IACA;IACA,OAAO,IAAI,CAACe,cAAc,CAACF,MAAM,CAAC,CAC/BG,IAAI,CAAC,MAAM,IAAI,CAACkB,UAAU,CAACjB,SAAS,CAAC,CAAC,CACtCD,IAAI,CAAC,MAAMjB,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,iBAAiB,CAAC,CAAC;EAC3D;EAEA,CAAC7D,UAAU,IAAK;IACd,IAAI,IAAI,CAAC2B,gBAAgB,CAAC,EAAE;MAC1B;IACF;IAEAiC,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,iBAAiB,CAAC;IACvC;IACA;IACA;;IAEA,MAAMmC,WAAW,GAAG,EAAE;IACtB,IAAI,IAAI,CAAC5D,OAAO,CAAC,IAAI,IAAI,CAACgD,gBAAgB,CAACC,IAAI,EAAE;MAC/C,MAAME,SAAS,GAAG,IAAI,CAACA,SAAS,CAACU,MAAM;MACvC,MAAMlC,UAAU,GAAG,IAAI,CAACA,UAAU,CAACkC,MAAM;MACzC;MACA;MACA,KAAK,MAAM;QAAEL;MAAK,CAAC,IAAI,IAAI,CAACR,gBAAgB,EAAE;QAC5C,MAAMc,KAAK,GAAGX,SAAS,CAACY,QAAQ,CAACC,GAAG,CAACR,IAAI,CAAC;QAC1C,IAAIM,KAAK,EAAE;UACTF,WAAW,CAACK,IAAI,CAACH,KAAK,CAAC;QACzB;QACA,MAAMI,MAAM,GAAGvC,UAAU,CAACoC,QAAQ,CAACC,GAAG,CAACR,IAAI,CAAC;QAC5C,IAAIU,MAAM,EAAE;UACVN,WAAW,CAACK,IAAI,CAACC,MAAM,CAAC;QAC1B;MACF;IACF,CAAC,MAAM;MACL,KAAK,MAAMC,EAAE,IAAI,IAAI,CAAC3G,WAAW,CAAC,EAAE;QAClC,MAAMsG,KAAK,GAAG,IAAI,CAACX,SAAS,CAACY,QAAQ,CAACC,GAAG,CAACG,EAAE,CAAC;QAC7C,IAAIL,KAAK,EAAE;UACTF,WAAW,CAACK,IAAI,CAACH,KAAK,CAAC;QACzB;QACA,MAAMI,MAAM,GAAG,IAAI,CAACvC,UAAU,CAACoC,QAAQ,CAACC,GAAG,CAACG,EAAE,CAAC;QAC/C,IAAID,MAAM,EAAE;UACVN,WAAW,CAACK,IAAI,CAACC,MAAM,CAAC;QAC1B;MACF;IACF;;IAEA;IACA;IACA,IAAI,CAACnD,IAAI,GAAGvE,IAAI,CAAC4H,SAAS,CAAC;MACzBC,kBAAkB,EAAE,IAAI,CAACtG,mBAAmB,CAAC;MAC7C6F,WAAW;MACXM,MAAM,EAAE,IAAI,CAACvC,UAAU;MACvBmC,KAAK,EAAE,IAAI,CAACX;IACd,CAAC,CAAC;;IAEF;IACA;IACA;IACA;IACA;IACA;;IAEA3B,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,iBAAiB,CAAC;EAC5C;;EAEA;EACA;EACA;EACA;EACA,CAAClE,mBAAmB,EAAGuF,IAAI,EAAEwB,MAAM,GAAG,KAAK,EAAE;IAC3C,MAAMC,KAAK,GAAG,CAACzB,IAAI,CAAClB,IAAI,EAAE,GAAGkB,IAAI,CAAC0B,QAAQ,CAAC;IAC3C,MAAMC,KAAK,GAAG,IAAI,CAAC1H,aAAa,CAAC;IACjC,IAAI,CAAC2H,GAAG,CAACC,KAAK,CAAC,OAAO,EAAE,MAAM,EAAEL,MAAM,GAAG,SAAS,GAAG,SAAS,EAAEC,KAAK,CAAC;IACtE,KAAK,MAAM3C,IAAI,IAAI2C,KAAK,EAAE;MACxB,IAAID,MAAM,EAAE;QACV,MAAMM,OAAO,GAAGnI,UAAU,CAACmF,IAAI,CAAC;QAChC6C,KAAK,CAAC7C,IAAI,CAAC,GAAGgD,OAAO;QACrB,IAAI,CAACnH,UAAU,CAAC,CAACoH,GAAG,CAACD,OAAO,CAAC;MAC/B,CAAC,MAAM;QACL,IAAI,CAACnH,UAAU,CAAC,CAACoH,GAAG,CAACjD,IAAI,CAAC;MAC5B;IACF;EACF;;EAEA;EACA;EACA,CAACxE,mBAAmB,IAAK;IACvBoE,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,qBAAqB,CAAC;IAC3C,MAAMgD,KAAK,GAAG,IAAI,CAAC1H,aAAa,CAAC,GAAG,CAAC,CAAC;IACtC,KAAK,MAAMgE,IAAI,IAAI,IAAI,CAACA,IAAI,CAACgD,QAAQ,EAAE;MACrC,IAAIhD,IAAI,CAACsB,MAAM,KAAK,QAAQ,IAAItB,IAAI,CAACsB,MAAM,KAAK,QAAQ,EAAE;QACxD;QACA,IAAI,CAAC9E,mBAAmB,CAAC,CAACwD,IAAI,CAACmD,MAAM,EAAE,IAAI,CAAC;MAC9C;IACF;IACA,IAAI,CAACQ,GAAG,CAACC,KAAK,CAAC,OAAO,EAAE,OAAO,EAAEF,KAAK,CAAC;IACvC,MAAMK,YAAY,GAAG9C,MAAM,CAAC+C,OAAO,CAACN,KAAK,CAAC,CACvCO,GAAG,CAAC,CAAC,CAACC,IAAI,EAAEC,EAAE,CAAC,KAAK,IAAI,CAACnG,WAAW,CAAC,CAACkG,IAAI,EAAEC,EAAE,CAAC,CAAC;IACnD,OAAOxI,oBAAoB,CAACoI,YAAY,CAAC,CACtCrC,IAAI,CAAC,MAAMjB,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,qBAAqB,CAAC,CAAC;EAC/D;EAEA,CAAC1C,WAAW,EAAGkG,IAAI,EAAEC,EAAE,EAAEC,SAAS,GAAG,KAAK,EAAE;IAC1C,OAAOtJ,QAAQ,CAACoJ,IAAI,EAAEC,EAAE,CAAC,CACtBE,KAAK,CAAClE,EAAE,IAAI;MACX;MACA;MACA;MACA;MACA,IAAIA,EAAE,CAACE,IAAI,KAAK,QAAQ,EAAE;QACxB,OAAO+D,SAAS,GAAG,IAAI,GAAGxJ,MAAM,CAACT,OAAO,CAACgK,EAAE,CAAC,CAAC,CAACzC,IAAI,CAAC,MACjD,IAAI,CAAC1D,WAAW,CAAC,CAACkG,IAAI,EAAEC,EAAE,EAAE,IAAI,CAAC,CAAC;MACtC,CAAC,MAAM,IAAIhE,EAAE,CAACE,IAAI,KAAK,QAAQ,EAAE;QAC/B,OAAOtF,MAAM,CAACoJ,EAAE,CAAC,CAACzC,IAAI,CAAC,MAAM5G,QAAQ,CAACoJ,IAAI,EAAEC,EAAE,CAAC,CAAC;MAClD,CAAC,MAAM;QACL,MAAMhE,EAAE;MACV;IACF,CAAC,CAAC;EACN;EAEA,CAAClC,2BAA2B,EAAGkC,EAAE,EAAE;IACjCM,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,8BAA8B,CAAC;IACpD,MAAMgD,KAAK,GAAG,IAAI,CAAC1H,aAAa,CAAC;IACjC,MAAM+H,YAAY,GAAG9C,MAAM,CAAC+C,OAAO,CAACN,KAAK,CAAC,CACvCO,GAAG,CAAC,CAAC,CAACC,IAAI,EAAEC,EAAE,CAAC,KAAK,IAAI,CAACnG,WAAW,CAAC,CAACmG,EAAE,EAAED,IAAI,CAAC,CAAC;IACnD,OAAOvI,oBAAoB,CAACoI,YAAY;IACtC;IAAA,CACCM,KAAK,CAAClE,EAAE,IAAI,CAAC,CAAC,CAAC,CACfuB,IAAI,CAAC,MAAMjB,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,8BAA8B,CAAC,CAAC,CACnEgB,IAAI,CAAC,MAAM;MACV,MAAMvB,EAAE;IACV,CAAC,CAAC;EACN;;EAEA;EACA;EACA,CAAC5B,oBAAoB,IAAK;IACxB,IAAI,CAAC,IAAI,CAACO,QAAQ,CAAC,IAAI,CAAC,IAAI,CAACC,aAAa,CAAC,IAAI,CAAC,IAAI,CAACC,SAAS,CAAC,EAAE;MAC/D;IACF;IAEAyB,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,kBAAkB,CAAC;IAExC,MAAMoB,MAAM,GAAGC,IAAI,IACjBA,IAAI,CAACuC,GAAG,CAACnC,aAAa,KACnBJ,IAAI,CAACwC,IAAI,IAAI,IAAI,CAACvF,SAAS,CAAC,IAC3B+C,IAAI,CAACyC,GAAG,IAAI,IAAI,CAAC1F,QAAQ,CAAC,IAC1BiD,IAAI,CAAC0C,QAAQ,IAAI,IAAI,CAAC1F,aAAa,CAAC,IACpCgD,IAAI,CAAC2C,WAAW,IAAI,IAAI,CAAC3F,aAAa,CAAC,IAAI,IAAI,CAACD,QAAQ,CAAC,CAAC;IAEhE,KAAK,MAAMiD,IAAI,IAAI,IAAI,CAACK,SAAS,CAACuC,SAAS,CAAC7C,MAAM,CAACA,MAAM,CAAC,EAAE;MAC1D,IAAI,CAACtF,mBAAmB,CAAC,CAACuF,IAAI,CAAC;IACjC;IAEAtB,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,kBAAkB,CAAC;EAC7C;EAEA,CAAC5D,iBAAiB,IAAK;IACrB2D,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,oBAAoB,CAAC;IAC1C;IACA;IACA,MAAMkE,MAAM,GAAG,IAAI,CAAC5E,IAAI,CAAC4E,MAAM,CAC5B9C,MAAM,CAAC9B,IAAI,IAAI;MACd,OAAO,CAACA,IAAI,CAACsB,MAAM,KAAK,KAAK,IAAItB,IAAI,CAACsB,MAAM,KAAK,QAAQ,KACvD,CAAC,IAAI,CAACpF,eAAe,CAAC,CAACqE,GAAG,CAACP,IAAI,CAAC+C,KAAK,CAAClC,IAAI,CAAC,IAC3C,CAACb,IAAI,CAAC+C,KAAK,CAAC8B,MAAM;IACtB,CAAC,CAAC,CACDZ,GAAG,CAACjE,IAAI,IAAIA,IAAI,CAAC+C,KAAK,CAAC;;IAE1B;IACA;IACA,MAAM+B,WAAW,GAAG,IAAI7E,GAAG,CAAC,CAAC;IAC7B,OAAOtE,oBAAoB,CAACiJ,MAAM,CAACX,GAAG,CAAC,MAAMlC,IAAI,IAAI;MACnD,KAAK,MAAMgD,CAAC,IAAI7K,MAAM,CAAC6H,IAAI,CAAClB,IAAI,CAAC,EAAE;QACjC,IAAIkE,CAAC,KAAKhD,IAAI,CAACuC,GAAG,CAACzD,IAAI,EAAE;UACvB;QACF;QACA,IAAIiE,WAAW,CAACvE,GAAG,CAACwE,CAAC,CAAC,EAAE;UACtB;QACF;QACAD,WAAW,CAAChB,GAAG,CAACiB,CAAC,CAAC;QAClB,MAAMC,EAAE,GAAG,MAAMtK,KAAK,CAACqK,CAAC,CAAC,CAACV,KAAK,CAAClE,EAAE,IAAI,IAAI,CAAC;QAC3C;QACA;QACA;QACA;QACA,IAAI6E,EAAE,IAAI,CAACA,EAAE,CAACC,WAAW,CAAC,CAAC,EAAE;UAC3B,MAAMpB,OAAO,GAAGnI,UAAU,CAACqJ,CAAC,CAAC;UAC7B,IAAI,CAAC/I,aAAa,CAAC,CAAC+I,CAAC,CAAC,GAAGlB,OAAO;UAChC,IAAI,CAACnH,UAAU,CAAC,CAACoH,GAAG,CAACD,OAAO,CAAC;UAC7B,MAAM,IAAI,CAAC7F,WAAW,CAAC,CAAC+G,CAAC,EAAElB,OAAO,CAAC;QACrC;MACF;MACA,MAAMqB,IAAI,GAAG,MAAMtK,MAAM,CAACmH,IAAI,CAAClB,IAAI,CAAC;MACpC,IAAI,CAAC3E,eAAe,CAAC,CAAC4H,GAAG,CAAC/B,IAAI,CAAClB,IAAI,CAAC;MACpC,IAAI,CAAC1E,gBAAgB,CAAC,CAAC2H,GAAG,CAACoB,IAAI,CAAC;IAClC,CAAC,CAAC,CAAC,CACAxD,IAAI,CAAC,MAAMjB,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,oBAAoB,CAAC,CAAC;EAC9D;EAEA,CAACxC,yBAAyB,EAAGiC,EAAE,EAAE;IAC/BM,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,6BAA6B,CAAC;IACnD;IACA,MAAMyE,KAAK,GAAG,IAAI,CAAChJ,gBAAgB,CAAC;IACpC;IACA,MAAMiJ,QAAQ,GAAG,EAAE;IACnB,MAAMC,OAAO,GAAG,CAAC,GAAGF,KAAK,EAAE,GAAGlE,MAAM,CAACqE,IAAI,CAAC,IAAI,CAACtJ,aAAa,CAAC,CAAC,CAAC;IAC/D,MAAMuJ,OAAO,GAAGF,OAAO,CACpBpB,GAAG,CAACpD,IAAI,IAAI9F,MAAM,CAAC8F,IAAI,CAAC,CAACwD,KAAK,CAAClE,EAAE,IAAIiF,QAAQ,CAAClC,IAAI,CAAC,CAACrC,IAAI,EAAEV,EAAE,CAAC,CAAC,CAAC,CAAC;IACnE,OAAOxE,oBAAoB,CAAC4J,OAAO,CAAC,CACjC7D,IAAI,CAAC,MAAM;MACV,IAAI0D,QAAQ,CAACI,MAAM,EAAE;QACnB,IAAI,CAAC7B,GAAG,CAAC8B,IAAI,CAAC,SAAS,EAAE,mCAAmC,EAAEL,QAAQ,CAAC;MACzE;IACF,CAAC,CAAC,CACD1D,IAAI,CAAC,MAAMjB,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,6BAA6B,CAAC,CAAC,CAClEgB,IAAI,CAAC,MAAM,IAAI,CAACzD,2BAA2B,CAAC,CAACkC,EAAE,CAAC,CAAC;EACtD;;EAEA;EACA;EACA;EACA,CAACpD,8BAA8B,IAAK;IAClC,MAAM2I,IAAI,GAAG,IAAI,CAAC1I,mBAAmB,CAAC;IACtC,MAAM2I,WAAW,GAAG,IAAI,CAAC3F,IAAI,CAAC4E,MAAM,CACjC9C,MAAM,CAACiD,CAAC,IAAI,CAACA,CAAC,CAACzD,MAAM,KAAK,QAAQ,IAAIyD,CAAC,CAACzD,MAAM,KAAK,KAAK,IAAI,CAACyD,CAAC,CAACzD,MAAM,KACpEyD,CAAC,CAAChC,KAAK,CAAC6C,aAAa,IAAI,CAACF,IAAI,CAACnF,GAAG,CAACwE,CAAC,CAAChC,KAAK,CAAC,IAC3C,CAAC,IAAI,CAACrG,UAAU,CAAC,CAAC6D,GAAG,CAACwE,CAAC,CAAChC,KAAK,CAAClC,IAAI,CAAC,CAAC;IAExC,IAAI,CAAC8E,WAAW,CAACH,MAAM,EAAE;MACvB;IACF;IAEA/E,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,uBAAuB,CAAC;IAE7C,MAAMmF,QAAQ,GAAG,IAAI,CAACnG,WAAW;IACjC,OAAO/D,oBAAoB,CAACgK,WAAW,CAAC1B,GAAG,CAACjE,IAAI,IAAI;MAClD,MAAM+B,IAAI,GAAG/B,IAAI,CAAC+C,KAAK;MACvB2C,IAAI,CAAC5B,GAAG,CAAC/B,IAAI,CAAC;MACd,OAAO/B,IAAI,CAACsB,MAAM,GAAG,IAAI,CAACnE,UAAU,CAAC,CAAC4E,IAAI,CAAC,GAAGA,IAAI;IACpD,CAAC,CAAC,CAAC,CACAL,IAAI,CAACoE,KAAK,IAAInK,oBAAoB,CAACmK,KAAK,CAAC7B,GAAG,CAAClC,IAAI,IAAI,IAAI8D,QAAQ,CAAC;MACjE,GAAG,IAAI,CAAClG,OAAO;MACfkB,IAAI,EAAEkB,IAAI,CAAClB;IACb,CAAC,CAAC,CAACkF,WAAW,CAAC;MAAEC,IAAI,EAAEjE;IAAK,CAAC,CAAC,CAAC,CAAC;IAChC;IAAA,CACCL,IAAI,CAAC,MAAM,IAAI,CAAC7E,UAAU,CAAC,CAAC,CAAC,CAAC,CAC9B6E,IAAI,CAAC,MAAM,IAAI,CAAC5E,iBAAiB,CAAC,CAAC,CAAC,CAAC,CACrC4E,IAAI,CAAC,MAAM,IAAI,CAACnD,oBAAoB,CAAC,CAAC,CAAC,CAAC,CACxCmD,IAAI,CAAC,MAAM,IAAI,CAAC3E,8BAA8B,CAAC,CAAC,CAAC,CAAC,CAClD2E,IAAI,CAAC,MAAMjB,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,uBAAuB,CAAC,CAAC;EACjE;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,CAACvD,UAAU,EAAG4E,IAAI,EAAE;IAClB,IAAI,IAAI,CAACrF,UAAU,CAAC,CAAC6D,GAAG,CAACwB,IAAI,CAAClB,IAAI,CAAC,EAAE;MACnC,OAAOkB,IAAI;IACb;IAEA,MAAMkE,KAAK,GAAG,aAAalE,IAAI,CAACmE,QAAQ,EAAE;IAC1CzF,OAAO,CAACC,IAAI,CAAC,MAAM,EAAEuF,KAAK,CAAC;IAC3B,IAAI,CAACzF,UAAU,CAAC,OAAO,EAAEuB,IAAI,CAACU,IAAI,EAAEV,IAAI,CAACmE,QAAQ,CAAC;IAElD,MAAM;MAAEC,UAAU;MAAEC;IAAY,CAAC,GAAG,IAAI,CAACzG,OAAO;IAChD,MAAM0G,CAAC,GAAG3D,OAAO,CAACtI,OAAO,CAAC,CAAC,CACxBsH,IAAI,CAAC,YAAY;MAChB;MACA;MACA;MACA;MACA;MACA,IAAIK,IAAI,CAAC0C,QAAQ,EAAE;QACjBvJ,WAAW,CAAC6G,IAAI,CAACuE,OAAO,EAAEH,UAAU,EAAEC,WAAW,EAAE,KAAK,CAAC;QACzDjL,aAAa,CAAC4G,IAAI,CAACuE,OAAO,EAAE,KAAK,CAAC;MACpC;MACA,MAAM,IAAI,CAACjJ,UAAU,CAAC,CAAC0E,IAAI,CAAC;MAC5B,MAAM,IAAI,CAAC3E,cAAc,CAAC,CAAC2E,IAAI,CAAC;MAChC,MAAM,IAAI,CAACxE,eAAe,CAAC,CAACwE,IAAI,CAAC;IACnC,CAAC,CAAC;IAEJ,OAAO,IAAI,CAACpF,sBAAsB,CAAC,CAACoF,IAAI,EAAEsE,CAAC,CAAC,CACzC3E,IAAI,CAAC,MAAM;MACV,IAAI,CAACf,aAAa,CAAC,OAAO,EAAEoB,IAAI,CAACU,IAAI,EAAEV,IAAI,CAACmE,QAAQ,CAAC;MACrDzF,OAAO,CAACC,IAAI,CAAC,SAAS,EAAEuF,KAAK,CAAC;MAC9B,OAAOlE,IAAI;IACb,CAAC,CAAC;EACN;;EAEA;EACA,OAAOrD,oBAAoB,EAAG6H,EAAE,EAAE;IAChC,IAAI,IAAI,CAACnL,MAAM,CAAC,IAAI,IAAI,CAACuD,YAAY,CAAC,CAAC4B,GAAG,CAACgG,EAAE,CAAC,EAAE;MAC9C;IACF;IACA,MAAMvB,EAAE,GAAG,MAAMtK,KAAK,CAAC6L,EAAE,CAAC,CAAClC,KAAK,CAAC,MAAM,IAAI,CAAC;IAC5C,IAAI,CAACW,EAAE,IAAIA,EAAE,CAACC,WAAW,CAAC,CAAC,EAAE;MAC3B,IAAI,CAACtG,YAAY,CAAC,CAACmF,GAAG,CAACyC,EAAE,CAAC;MAC1B;IACF;IACA,IAAI,CAAC5C,GAAG,CAAC8B,IAAI,CAAC,OAAO,EAAE,wBAAwB,EAAEc,EAAE,CAAC;IACpD,MAAMxL,MAAM,CAACwL,EAAE,CAAC;EAClB;EAEA,OAAOnJ,cAAc,EAAG2E,IAAI,EAAE;IAC5B;IACA;IACA;IACA;IACA;IACA;IACA;IACA,MAAMyE,GAAG,GAAGzE,IAAI,CAAC0E,QAAQ,GAAG,GAAG1E,IAAI,CAACU,IAAI,IAAI,IAAI,CAAClG,iBAAiB,CAAC,CAACwF,IAAI,CAAC0E,QAAQ,CAAC,EAAE,GAChF1E,IAAI,CAAC2E,WAAW,IAAI3E,IAAI,CAAC4E,OAAO,GAC9B,GAAG5E,IAAI,CAAC2E,WAAW,IAAI3E,IAAI,CAAC4E,OAAO,EAAE,GACrC,IAAI;;IAEV;IACA,IAAI,CAACH,GAAG,EAAE;MACR,MAAMI,OAAO,GAAG,wCAAwC,GACtD,kDAAkD,GAClD,mDAAmD,GACnD,2DAA2D;MAC7D,IAAI,CAACjD,GAAG,CAAC8B,IAAI,CAAC,OAAO,EAAEmB,OAAO,CAAC;MAC/B,IAAI,CAACjD,GAAG,CAACkD,OAAO,CAAC,OAAO,EAAE,2BAA2B,EAAE9E,IAAI,CAAClB,IAAI,CAAC;MACjEkB,IAAI,CAAC+E,MAAM,GAAG,IAAI;MAClB/E,IAAI,CAACgF,QAAQ,GAAG,IAAI;MACpB,IAAI,CAACvK,mBAAmB,CAAC,CAACuF,IAAI,CAAC;MAC/B;IACF;IAEA,MAAMwE,EAAE,GAAGnM,OAAO,CAAC2H,IAAI,CAAC+E,MAAM,CAACjG,IAAI,EAAE,cAAc,CAAC;IACpD,MAAM,IAAI,CAACnC,oBAAoB,CAAC,CAAC6H,EAAE,CAAC;IAEpC,IAAIxE,IAAI,CAAC8C,MAAM,EAAE;MACf,MAAM9J,MAAM,CAACgH,IAAI,CAAClB,IAAI,CAAC;MACvB,MAAM,IAAI,CAACvD,QAAQ,CAAC,CAACyE,IAAI,CAAC;IAC5B,CAAC,MAAM;MACL,MAAM9H,KAAK,CAAC,YAAY;QACtB,MAAM+K,EAAE,GAAG,MAAMtK,KAAK,CAACqH,IAAI,CAAClB,IAAI,CAAC,CAACwD,KAAK,CAAC2C,CAAC,IAAI,IAAI,CAAC;QAClD,IAAIhC,EAAE,IAAI,CAACA,EAAE,CAACC,WAAW,CAAC,CAAC,EAAE;UAC3BhL,KAAK,CAAC0J,GAAG,CAAC,gCAAgC,EAAE5B,IAAI,CAAC;UACjD,MAAMd,MAAM,CAACC,MAAM,CAAC,IAAId,KAAK,CAAC,0BAA0B,CAAC,EAAE;YACzDC,IAAI,EAAE,SAAS;YACfQ,IAAI,EAAEkB,IAAI,CAAClB;UACb,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;MACF,MAAMjH,MAAM,CAACqN,OAAO,CAACT,GAAG,EAAEzE,IAAI,CAAClB,IAAI,EAAE;QACnC,GAAG,IAAI,CAAClB,OAAO;QACf8G,QAAQ,EAAE1E,IAAI,CAAC0E,QAAQ;QACvBS,SAAS,EAAEnF,IAAI,CAACmF;MAClB,CAAC,CAAC;IACJ;EACF;EAEA,OAAO5J,QAAQ,EAAGyE,IAAI,EAAE;IACtB,MAAMoF,GAAG,GAAGhN,OAAO,CAAC4H,IAAI,CAAClB,IAAI,CAAC;IAC9B,MAAMiC,MAAM,GAAGf,IAAI,CAACqF,QAAQ;IAC5B,MAAMC,GAAG,GAAGhN,QAAQ,CAAC8M,GAAG,EAAErE,MAAM,CAAC;IACjC,MAAMlI,MAAM,CAACuM,GAAG,CAAC;IACjB,OAAOxM,OAAO,CAAC0M,GAAG,EAAEtF,IAAI,CAAClB,IAAI,EAAE,UAAU,CAAC;EAC5C;EAEA,CAACtD,eAAe,EAAGwE,IAAI,EAAE;IACvB,MAAM;MAACuF,GAAG;MAAEC;IAAU,CAAC,GAAGxF,IAAI,CAACuE,OAAO;IACtC,IAAIiB,UAAU,EAAE;MACd,IAAI,CAAC5D,GAAG,CAAC8B,IAAI,CAAC,YAAY,EAAE,GAAG6B,GAAG,KAAKC,UAAU,EAAE,CAAC;IACtD;EACF;;EAEA;EACA;EACA,CAAC5K,sBAAsB,EAAGoF,IAAI,EAAEsE,CAAC,EAAE;IACjC,OAAO,CAACtE,IAAI,CAAC0C,QAAQ,GAAG4B,CAAC,CAAChC,KAAK,CAAClE,EAAE,IAAI;MACpC,MAAMqH,GAAG,GAAG5L,WAAW,CAACmG,IAAI,CAAC;MAC7B,KAAKA,IAAI,IAAIyF,GAAG,EAAE;QAChB,IAAI,CAAC7D,GAAG,CAACkD,OAAO,CAAC,OAAO,EAAE,4BAA4B,EAAE9E,IAAI,CAAClB,IAAI,CAAC;QAClE,IAAI,CAACrE,mBAAmB,CAAC,CAACuF,IAAI,CAAC;MACjC;IACF,CAAC,CAAC,GAAGsE,CAAC,EAAE3E,IAAI,CAAC,MAAMK,IAAI,CAAC;EAC1B;EAEA,CAACxF,iBAAiB,EAAGkK,QAAQ,EAAE;IAC7B;IACA;IACA;IACA;IACA;IACA;IACA;IACA,OAAOA,QAAQ,IAAIA,QAAQ,CACxBgB,OAAO,CAAC,kCAAkC,EAAE,IAAI,CAACC,QAAQ,CAAC;EAC/D;;EAEA;EACA;EACA;EACA;EACA,CAAClK,0BAA0B,EACzBlD,KAAK,GAAG,CAAC,EAAEqN,cAAc,GAAG,IAAI,CAACrL,kBAAkB,CAAC,CAAC,CAAC,EACtD;IACA,IAAIhC,KAAK,KAAK,CAAC,EAAE;MACfmG,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,mBAAmB,CAAC;IAC3C;IAEA,MAAMkH,cAAc,GAAGD,cAAc,CAAC1E,GAAG,CAAC,gBAAgB,CAAC;IAC3D,IAAI3I,KAAK,GAAGsN,cAAc,EAAE;MAC1B;MACA,IAAIA,cAAc,KAAK,CAAC,CAAC,EAAE;QACzB,IAAI,CAAC1I,qBAAqB,CAAC,CAACyI,cAAc,CAAC;QAC3C,IAAI,CAAC9K,UAAU,CAAC,CAAC,CAAC;MACpB;MACA4D,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,mBAAmB,CAAC;MAC5C;IACF;;IAEA;IACA;IACA,MAAM8G,GAAG,GAAG,CAACG,cAAc,CAAC1E,GAAG,CAAC3I,KAAK,CAAC,IAAI,EAAE,EACzCwH,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACiE,IAAI,KAAK,IAAI,CAAC5D,SAAS,IAC1CL,IAAI,CAACe,MAAM,KAAKf,IAAI,CAACiE,IAAI,IACzB,CAAC,IAAI,CAACtJ,UAAU,CAAC,CAAC6D,GAAG,CAACwB,IAAI,CAAClB,IAAI,CAAC,CAAC;IAErC,IAAI,CAAC2G,GAAG,CAAChC,MAAM,EAAE;MACf,OAAO,IAAI,CAAChI,0BAA0B,CAAC,CAAClD,KAAK,GAAG,CAAC,EAAEqN,cAAc,CAAC;IACpE;;IAEA;IACA,OAAOhM,oBAAoB,CAAC6L,GAAG,CAACvD,GAAG,CAAClC,IAAI,IAAI;MAC1C,IAAI,CAAC9E,eAAe,CAAC,CAAC6G,GAAG,CAAC/B,IAAI,CAAC;MAC/B,OAAO,IAAI,CAAC5E,UAAU,CAAC,CAAC4E,IAAI,CAAC;IAC/B,CAAC,CAAC;IACF;IAAA,CACGL,IAAI,CAACoE,KAAK,IACTnK,oBAAoB,CAACmK,KAAK,CAAC7B,GAAG,CAAC,MAAMlC,IAAI,IAAI;MAC3C,MAAM8F,GAAG,GAAG,IAAI,IAAI,CAACnI,WAAW,CAAC;QAC/B,GAAG,IAAI,CAACC,OAAO;QACfkB,IAAI,EAAEkB,IAAI,CAAClB;MACb,CAAC,CAAC;MACF,MAAMiH,eAAe,GAAG,IAAI7H,GAAG,CAAC8B,IAAI,CAACiB,QAAQ,CAACsC,IAAI,CAAC,CAAC,CAAC;MACrD,MAAMuC,GAAG,CAACjF,UAAU,CAAC;QACnBoD,IAAI,EAAEjE,IAAI;QACV;QACA;QACA;QACA;QACAgG,gBAAgB,EAAEhG,IAAI,IAAI;UACxB,IAAIA,IAAI,CAACuE,OAAO,CAACgB,GAAG,EAAE;YACpB;YACAQ,eAAe,CAACE,MAAM,CAACjG,IAAI,CAACU,IAAI,CAAC;YACjC,OAAO,IAAI;UACb,CAAC,MAAM;YACL,OAAO,KAAK;UACd;QACF;MACF,CAAC,CAAC;MACF,KAAK,MAAMA,IAAI,IAAIqF,eAAe,EAAE;QAClC,IAAI,CAAC5K,cAAc,CAAC,CAAC4G,GAAG,CAAC/B,IAAI,CAACiB,QAAQ,CAACC,GAAG,CAACR,IAAI,CAAC,CAAC;MACnD;IACF,CAAC,CAAC,CAAC;IACP;IAAA,CACGf,IAAI,CAAC,MAAM,IAAI,CAAClE,0BAA0B,CAAC,CAAClD,KAAK,GAAG,CAAC,EAAEqN,cAAc,CAAC,CAAC;EAC5E;EAEA,CAACrL,kBAAkB,IAAK;IACtB,MAAMqL,cAAc,GAAG,IAAIM,GAAG,CAAC,CAAC;IAChC,IAAIL,cAAc,GAAG,CAAC,CAAC;IACvBrN,MAAM,CAAC;MACL2N,IAAI,EAAE,IAAI,CAAClI,IAAI;MACfmI,KAAK,EAAEnI,IAAI,IAAI;QACb,MAAM+B,IAAI,GAAG/B,IAAI,CAAC+C,KAAK;QACvB,IAAI,CAAChB,IAAI,EAAE;UACT;QACF;QACA,IAAIA,IAAI,CAACI,aAAa,EAAE;UACtB;QACF;QAEA,MAAM;UAAEiG;QAAmB,CAAC,GAAGrG,IAAI,CAACuE,OAAO;QAC3C,IAAI8B,kBAAkB,IAAIA,kBAAkB,CAAC5C,MAAM,EAAE;UACnDoC,cAAc,GAAGS,IAAI,CAACC,GAAG,CAACV,cAAc,EAAE7F,IAAI,CAACzH,KAAK,CAAC;UACrD,IAAI,CAACqN,cAAc,CAACpH,GAAG,CAACwB,IAAI,CAACzH,KAAK,CAAC,EAAE;YACnCqN,cAAc,CAACH,GAAG,CAACzF,IAAI,CAACzH,KAAK,EAAE,CAACyH,IAAI,CAAC,CAAC;UACxC,CAAC,MAAM;YACL4F,cAAc,CAAC1E,GAAG,CAAClB,IAAI,CAACzH,KAAK,CAAC,CAAC4I,IAAI,CAACnB,IAAI,CAAC;UAC3C;QACF;MACF,CAAC;MACDwG,WAAW,EAAEvI,IAAI,IAAIA,IAAI,CAACgD;IAC5B,CAAC,CAAC;IAEF2E,cAAc,CAACH,GAAG,CAAC,gBAAgB,EAAEI,cAAc,CAAC;IACpD,OAAOD,cAAc;EACvB;;EAEA;EACA,CAACzI,qBAAqB,EAAGyI,cAAc,EAAE;IACvC,MAAMa,cAAc,GAAG,IAAIvI,GAAG,CAAC,CAAC;;IAEhC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA,KAAK,MAAMwI,OAAO,IAAId,cAAc,CAACe,MAAM,CAAC,CAAC,EAAE;MAC7C;MACA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACH,OAAO,CAAC,EAAE;QAC3B;MACF;MACA,KAAK,MAAM1G,IAAI,IAAI0G,OAAO,EAAE;QAC1B,KAAK,MAAMhG,IAAI,IAAIV,IAAI,CAACiB,QAAQ,CAACsC,IAAI,CAAC,CAAC,EAAE;UACvC,MAAMuD,MAAM,GAAG9G,IAAI,CAAC+E,MAAM,CAAC1M,OAAO,CAACqI,IAAI,CAAC;UACxC,IAAI,CAACoG,MAAM,EAAE;YACX;UACF;UACAL,cAAc,CAAC1E,GAAG,CAAC+E,MAAM,CAAC;UAC1BA,MAAM,CAACC,UAAU,GAAG,IAAI;QAC1B;MACF;IACF;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,KAAK,MAAMD,MAAM,IAAIL,cAAc,EAAE;MACnC,KAAK,MAAMO,OAAO,IAAIF,MAAM,CAACxG,QAAQ,CAACqG,MAAM,CAAC,CAAC,EAAE;QAC9C;AACR;AACA;AACA;QACQ,IAAIK,OAAO,CAAC5E,EAAE,EAAE;UACdqE,cAAc,CAAC1E,GAAG,CAACiF,OAAO,CAAC5E,EAAE,CAAC;UAC9B4E,OAAO,CAAC5E,EAAE,CAAC2E,UAAU,GAAG,IAAI;QAC9B;MACF;IACF;IAEA,IAAIE,OAAO;IACX,GAAG;MACDA,OAAO,GAAG,KAAK;MACf,KAAK,MAAMH,MAAM,IAAIL,cAAc,EAAE;QACnC,KAAK,MAAMhG,IAAI,IAAIqG,MAAM,CAACI,OAAO,EAAE;UACjC,IAAI,CAACT,cAAc,CAACjI,GAAG,CAACiC,IAAI,CAAC0B,IAAI,CAAC,EAAE;YAClC2E,MAAM,CAACC,UAAU,GAAG,KAAK;YACzBN,cAAc,CAACR,MAAM,CAACa,MAAM,CAAC;YAC7BG,OAAO,GAAG,IAAI;YACd;UACF;QACF;MACF;IACF,CAAC,QAAQA,OAAO;IAEhB,KAAK,MAAMH,MAAM,IAAIL,cAAc,EAAE;MACnC,IAAI,CAAChM,mBAAmB,CAAC,CAACqM,MAAM,CAAC;MACjCA,MAAM,CAAC7C,IAAI,GAAG,IAAI;IACpB;EACF;EAEA,CAACvI,iBAAiB,IAAK;IACrB,IAAI,IAAI,CAACkC,OAAO,CAACuJ,KAAK,KAAK,KAAK,EAAE;MAChC,OAAO,IAAI,CAACC,WAAW,GAAG,IAAI;IAChC;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA1I,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,aAAa,CAAC;IACnC,MAAMf,OAAO,GAAG;MAAE,GAAG,IAAI,CAACA;IAAQ,CAAC;IACnC,MAAMuI,IAAI,GAAG,IAAI,CAAC9F,SAAS;;IAE3B;IACA,IAAI,IAAI,CAAC3F,WAAW,CAAC,IAAI,IAAI,CAACA,WAAW,CAAC,CAAC+I,MAAM,EAAE;MACjD7F,OAAO,CAACyJ,SAAS,GAAG,IAAI,CAACC,sBAAsB,CAACnB,IAAI,EAAE,IAAI,CAACzL,WAAW,CAAC,CAAC;IAC1E;IAEA,IAAI,CAAC0M,WAAW,GAAGtP,WAAW,CAACyP,IAAI,CAACpB,IAAI,EAAEvI,OAAO,CAAC,CAC/C+B,IAAI,CAAC8E,GAAG,IAAI;MACX/F,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,aAAa,CAAC;MACtC,IAAI,CAACyI,WAAW,GAAG3C,GAAG;IACxB,CAAC,CAAC;EACN;;EAEA;EACA,CAAC9I,gBAAgB,IAAK;IACpB,OAAO,IAAI,CAACyL,WAAW;EACzB;;EAEA;EACA;EACA;EACA;EACA,CAACxL,iBAAiB,IAAK;IACrB8C,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,cAAc,CAAC;IACpC,MAAM6I,OAAO,GAAG,EAAE;IAClBhP,MAAM,CAAC;MACL2N,IAAI,EAAE,IAAI,CAAClI,IAAI;MACfmI,KAAK,EAAEnI,IAAI,IAAI;QACb;QACA,IAAIA,IAAI,CAACsB,MAAM,KAAK,QAAQ,IAAItB,IAAI,CAACsB,MAAM,KAAK,KAAK,EAAE;UACrD;QACF;QAEA,MAAMS,IAAI,GAAG/B,IAAI,CAAC+C,KAAK;QACvB,MAAMyG,EAAE,GAAG,IAAI,CAACvM,eAAe,CAAC,CAACsD,GAAG,CAACwB,IAAI,CAAC;QAC1C,MAAM0H,EAAE,GAAG,IAAI,CAACzM,mBAAmB,CAAC,CAACuD,GAAG,CAACwB,IAAI,CAAC;QAC9C,MAAM2H,aAAa,GAAG,IAAI,CAACxM,cAAc,CAAC,CAACqD,GAAG,CAACwB,IAAI,CAAC;;QAEpD;QACA;QACA,MAAM4H,QAAQ,GAAG5H,IAAI;QAAI;QACvB;QACA,CAACA,IAAI,CAAC6H,MAAM;QACZ;QACA,CAACJ,EAAE;QACH;QACA,CAACC,EAAE;QACH;QACCC,aAAa,IAAI,CAAC3H,IAAI,CAAC8H,WAAW,CAAC;QAEtC,IAAIF,QAAQ,EAAE;UACZJ,OAAO,CAACrG,IAAI,CAAC,IAAI,CAAC/F,UAAU,CAAC,CAAC4E,IAAI,CAAC,CAAC;QACtC;MACF,CAAC;MACDwG,WAAW,EAAEvI,IAAI,IAAIA,IAAI,CAACgD;IAC5B,CAAC,CAAC;IACF,OAAOrH,oBAAoB,CAAC4N,OAAO,CAAC,CACjC7H,IAAI,CAAC,MAAMjB,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;EACxD;;EAEA;EACA;EACA;EACA;EACA;EACA,CAAC7C,yBAAyB,IAAK;IAC7B;IACA;IACA;IACA;IACA;IACA;IACA4C,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,gBAAgB,CAAC;IACtC,MAAMgD,KAAK,GAAG,IAAI,CAAC1H,aAAa,CAAC;IACjC,IAAI,CAACC,iBAAiB,CAAC,GAAG,CAAC,CAAC;IAC5B,OAAON,oBAAoB,CAAC,IAAI,CAACqE,IAAI,CAACgD,QAAQ,CAACiB,GAAG,CAACjE,IAAI,IAAI;MACzD;MACA,IAAIA,IAAI,CAACsB,MAAM,KAAK,QAAQ,IAAItB,IAAI,CAACsB,MAAM,KAAK,QAAQ,EAAE;QACxD;MACF;MAEA,MAAM;QAAET,IAAI,EAAEiJ;MAAW,CAAC,GAAG9J,IAAI,CAACmD,MAAM;MACxC,MAAM4G,YAAY,GAAGrG,KAAK,CAACoG,UAAU,CAAC;MACtC;MACA7P,KAAK,CAAC,MAAM;QACV,IAAI,CAAC8P,YAAY,EAAE;UACjB,MAAM5J,EAAE,GAAG,IAAIC,KAAK,CAAC,qCAAqC,CAAC;UAC3D,MAAMa,MAAM,CAACC,MAAM,CAACf,EAAE,EAAE;YACtB2J,UAAU;YACVC,YAAY;YACZ5G,MAAM,EAAEnD,IAAI,CAACmD,MAAM;YACnBJ,KAAK,EAAE/C,IAAI,CAAC+C,KAAK;YACjBzB,MAAM,EAAEtB,IAAI,CAACsB;UACf,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;MAEF,IAAI,CAACrF,iBAAiB,CAAC,CAAC8N,YAAY,CAAC,GAAG,EAAE;MAC1C,OAAOpO,oBAAoB,CAACqE,IAAI,CAACgK,SAAS,CAAC/F,GAAG,CAAClC,IAAI,IAAI;QACrD;QACA,IAAIA,IAAI,CAAC8C,MAAM,EAAE;UACf,OAAOjK,MAAM,CAACT,OAAO,CAAC4H,IAAI,CAAClB,IAAI,CAAC,CAAC,CAACa,IAAI,CAAC,MAAM,IAAI,CAACvE,UAAU,CAAC,CAAC4E,IAAI,CAAC,CAAC;QACtE;;QAEA;QACA,IAAIA,IAAI,CAAC8H,WAAW,IAAI,CAAC,IAAI,CAAC3M,cAAc,CAAC,CAACqD,GAAG,CAACwB,IAAI,CAAC,EAAE;UACvD;QACF;QAEA,IAAI,CAAC9F,iBAAiB,CAAC,CAAC8N,YAAY,CAAC,CAAC7G,IAAI,CAACnB,IAAI,CAAC;QAEhD,MAAMsF,GAAG,GAAGhN,QAAQ,CAACyP,UAAU,EAAE/H,IAAI,CAAClB,IAAI,CAAC;QAC3C,MAAMoJ,QAAQ,GAAG7P,OAAO,CAAC2P,YAAY,EAAE1C,GAAG,CAAC;QAC3C;QACA;QACA,MAAMmC,EAAE,GAAGzH,IAAI,CAACuE,OAAO,CAAC8B,kBAAkB;QAC1C,MAAMjB,GAAG,GAAGqC,EAAE,IAAIA,EAAE,CAAChE,MAAM,GAAGzD,IAAI,CAAClB,IAAI,GAAG,eAAe,GAAGkB,IAAI,CAAClB,IAAI;QACrE,OAAOjG,MAAM,CAACuM,GAAG,CAAC,CAACzF,IAAI,CAAC,MAAM,IAAI,CAAC9D,aAAa,CAAC,CAACmE,IAAI,EAAEkI,QAAQ,CAAC,CAAC;MACpE,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC,CACAvI,IAAI,CAAC,MAAMjB,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;EAC1D;;EAEA;EACA,CAAC9C,aAAa,EAAGmE,IAAI,EAAEkI,QAAQ,EAAE;IAC/B,OAAOhP,eAAe,CAAC;MACrB4F,IAAI,EAAEoJ,QAAQ;MACd3P,KAAK,EAAE,CAAC;MACR4P,gBAAgB,EAAE,IAAIjC,GAAG,CAAC,CAAC,CAACgC,QAAQ,GAAG,eAAe,EAAElI,IAAI,CAACuE,OAAO,CAAC,CAAC;IACxE,CAAC,CAAC,CAAC5E,IAAI,CAAC8E,GAAG,IAAI7K,oBAAoB,CAAC6K,GAAG,CAACvC,GAAG,CAACpD,IAAI,IAAI;MAClD,MAAMwG,GAAG,GAAGhN,QAAQ,CAAC4P,QAAQ,EAAEpJ,IAAI,CAAC;MACpC,MAAMsD,EAAE,GAAG/J,OAAO,CAAC2H,IAAI,CAAClB,IAAI,EAAEwG,GAAG,CAAC;MAClC,OAAO,IAAI,CAACrJ,WAAW,CAAC,CAAC6C,IAAI,EAAEsD,EAAE,CAAC;IACpC,CAAC,CAAC,CAAC,CAAC;EACN;EAEA,CAAChG,iCAAiC,EAAGgC,EAAE,EAAE;IACvC,MAAMuD,KAAK,GAAG,IAAI,CAAC1H,aAAa,CAAC;IACjC;IACA,MAAMmO,WAAW,GAAG,IAAIlC,GAAG,CAAChH,MAAM,CAAC+C,OAAO,CAACN,KAAK,CAAC,CAACO,GAAG,CAAC,CAAC,CAACmG,CAAC,EAAEC,CAAC,CAAC,KAAK,CAACA,CAAC,EAAED,CAAC,CAAC,CAAC,CAAC;IAC1E,MAAME,QAAQ,GAAGrJ,MAAM,CAAC+C,OAAO,CAAC,IAAI,CAAC/H,iBAAiB,CAAC,CAAC,CACrDgI,GAAG,CAAC,CAAC,CAAC8F,YAAY,EAAEjE,KAAK,CAAC,KAAKnK,oBAAoB,CAACmK,KAAK,CAAC7B,GAAG,CAAClC,IAAI,IAAI;MACrE,MAAM+H,UAAU,GAAGK,WAAW,CAAClH,GAAG,CAAC8G,YAAY,CAAC;MAChD,MAAM1C,GAAG,GAAGhN,QAAQ,CAACyP,UAAU,EAAE/H,IAAI,CAAClB,IAAI,CAAC;MAC3C,MAAMoJ,QAAQ,GAAG7P,OAAO,CAAC2P,YAAY,EAAE1C,GAAG,CAAC;MAC3C,OAAO,IAAI,CAACzJ,aAAa,CAAC,CAAC;QAAE,GAAGmE,IAAI;QAAElB,IAAI,EAAEoJ;MAAS,CAAC,EAAElI,IAAI,CAAClB,IAAI,CAAC;IACpE,CAAC,CAAC,CAAC,CAAC;IACN,OAAOlF,oBAAoB,CAAC2O,QAAQ,CAAC,CAClC5I,IAAI,CAAC,MAAM,IAAI,CAACxD,yBAAyB,CAAC,CAACiC,EAAE,CAAC,CAAC;EACpD;EAEA,CAACrC,MAAM,IAAK;IACV2C,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,aAAa,CAAC;;IAEnC;IACA;IACA;IACA,MAAMoF,KAAK,GAAG,EAAE;IAChBvL,MAAM,CAAC;MACL2N,IAAI,EAAE,IAAI,CAAClI,IAAI;MACfuK,KAAK,EAAEvK,IAAI,IAAI;QACb,IAAI,CAACA,IAAI,CAAC+C,KAAK,CAACZ,aAAa,EAAE;UAC7B2D,KAAK,CAAC5C,IAAI,CAAClD,IAAI,CAAC+C,KAAK,CAAC;QACxB;MACF,CAAC;MACD;MACAwF,WAAW,EAAEvI,IAAI,IAAIA,IAAI,IAAIA,IAAI,CAACgD,QAAQ;MAC1ClB,MAAM,EAAE9B,IAAI,IAAIA,IAAI,CAACsB,MAAM,KAAK,KAAK,IAAItB,IAAI,CAACsB,MAAM,KAAK;IAC3D,CAAC,CAAC;;IAEF;IACA;IACA,KAAK,MAAMS,IAAI,IAAI,IAAI,CAAC/B,IAAI,CAACgK,SAAS,EAAE;MACtC,MAAM9B,IAAI,GAAGnG,IAAI,CAACiE,IAAI,CAAClD,MAAM;;MAE7B;MACA;MACA;MACA,IAAIf,IAAI,CAAC8C,MAAM,IAAI9C,IAAI,CAACe,MAAM,CAAC0H,KAAK,KAAKtC,IAAI,EAAE;QAC7CpC,KAAK,CAAC5C,IAAI,CAACnB,IAAI,CAAC;MAClB;IACF;IAEA,OAAO,IAAI,CAAC0I,OAAO,CAAC;MAAE3E,KAAK;MAAE4E,qBAAqB,EAAE;IAAK,CAAC,CAAC,CACxDhJ,IAAI,CAAC,MAAMjB,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;EACvD;;EAEA;EACA;EACA;EACA;EACA,CAAC3C,YAAY,IAAK;IAChB0C,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,aAAa,CAAC;IACnC,MAAM4J,QAAQ,GAAG,EAAE;IACnB,MAAMlF,QAAQ,GAAG,EAAE;IACnB,MAAMuF,EAAE,GAAG9J,IAAI,IAAI9F,MAAM,CAAC8F,IAAI,CAAC,CAACwD,KAAK,CAAClE,EAAE,IAAIiF,QAAQ,CAAClC,IAAI,CAAC,CAACrC,IAAI,EAAEV,EAAE,CAAC,CAAC,CAAC;IAEtE,KAAK,MAAMU,IAAI,IAAI,IAAI,CAACnE,UAAU,CAAC,EAAE;MACnC4N,QAAQ,CAACpH,IAAI,CAACyH,EAAE,CAAC9J,IAAI,CAAC,CAAC;IACzB;IAEA,OAAOlF,oBAAoB,CAAC2O,QAAQ,CAAC,CAAC5I,IAAI,CAAC,MAAM;MAC/C,IAAI0D,QAAQ,CAACI,MAAM,EAAE;QACnB,IAAI,CAAC7B,GAAG,CAAC8B,IAAI,CAAC,SAAS,EAAE,mCAAmC,EAAEL,QAAQ,CAAC;MACzE;IACF,CAAC,CAAC,CACC1D,IAAI,CAAC,MAAMjB,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;EACvD;;EAEA;EACA;EACA,OAAOtC,cAAc,EAAGuB,OAAO,EAAE;IAC/B;IACA;IACA;IACA;;IAEA;IACA,IAAIA,OAAO,CAACiL,IAAI,KAAK,KAAK,IAAI,IAAI,CAAC3L,OAAO,CAAC,IAAI,IAAI,CAACR,OAAO,CAAC,EAAE;MAC5D,OAAO,KAAK;IACd;IAEAgC,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,YAAY,CAAC;IAElC,MAAMmK,YAAY,GAAG,IAAI5K,GAAG,CAAC,CAAC;;IAE9B;IACA;IACA;IACA;IACA,IAAI,IAAI,CAACd,YAAY,CAAC,CAACqG,MAAM,EAAE;MAC7B,KAAK,MAAM;QAAE/C,IAAI;QAAEyF,IAAI,EAAE4C;MAAQ,CAAC,IAAI,IAAI,CAAC3L,YAAY,CAAC,EAAE;QACxD;QACA,MAAMqD,IAAI,GAAGsI,OAAO,CAACzI,QAAQ,CAACY,GAAG,CAACR,IAAI,CAAC;QACvC,MAAMsI,GAAG,GAAGD,OAAO,CAACxE,OAAO;QAC3B,MAAM0E,GAAG,GAAGhR,GAAG,CAACI,OAAO,CAACqI,IAAI,EAAED,IAAI,CAACyI,IAAI,EAAEH,OAAO,CAAC1D,QAAQ,CAAC;QAC1D,MAAM;UAAC8D,OAAO;UAAEC;QAAO,CAAC,GAAGH,GAAG;QAE9B,MAAMC,IAAI,GAAGE,OAAO,GAAGA,OAAO,CAACD,OAAO,GAAGA,OAAO;QAChD,MAAME,KAAK,GAAG5I,IAAI,CAAC2B,EAAE;;QAErB;QACA;QACA;QACA;QACA,IAAI,CAACiH,KAAK,EAAE;UACV;QACF;QAEA,IAAIC,OAAO;QACX,IAAIL,GAAG,CAACtD,QAAQ,EAAE;UAChB,MAAMf,OAAO,GAAGyE,KAAK,CAACzE,OAAO;UAC7B,MAAM2E,WAAW,GAAG3E,OAAO,GAAG,IAAI,CAACvK,WAAW,CAAC,GAAGuK,OAAO,GAAG,GAAG;UAC/D;UACA;UACA;UACA;UACA;UACA,MAAM4E,OAAO,GAAG,CAACJ,OAAO,IAAIH,GAAG,EAAEQ,IAAI,KAAK,OAAO;UAEjD,IAAIC,KAAK,GAAGR,IAAI;UAChB,IACE,CAACM,OAAO,IACRN,IAAI,KAAK,GAAG,IACZnR,MAAM,CAACwR,WAAW,EAAEL,IAAI,EAAE;YAAES,KAAK,EAAE;UAAK,CAAC,CAAC,EAC1C;YACAD,KAAK,GAAGH,WAAW;UACrB;UAEA,MAAMK,KAAK,GAAGP,KAAK,CAAC1E,WAAW;UAC/B,MAAMkF,KAAK,GAAGnJ,IAAI,KAAKkJ,KAAK;UAC5BN,OAAO,GAAGO,KAAK,GAAG,OAAOD,KAAK,IAAIF,KAAK,EAAE,GAAGA,KAAK;QACnD,CAAC,MAAM,IAAIT,GAAG,CAACa,MAAM,EAAE;UACrB;UACA,MAAMC,CAAC,GAAGd,GAAG,CAACa,MAAM;UACpB,MAAME,GAAG,GAAG;YAAEC,YAAY,EAAE;UAAM,CAAC;UACnC,IAAIF,CAAC,CAACG,KAAK,IAAIH,CAAC,CAACI,IAAI,EAAE;YACrBb,OAAO,GAAG,OAAOS,CAAC,CAACG,KAAK,CAACF,GAAG,CAAC,EAAE;UACjC,CAAC,MAAM;YACLV,OAAO,GAAGS,CAAC,CAACK,QAAQ,CAACJ,GAAG,CAAC;UAC3B;QACF,CAAC,MAAM,IAAIf,GAAG,CAACQ,IAAI,KAAK,WAAW,IAAIR,GAAG,CAACQ,IAAI,KAAK,MAAM,EAAE;UAC1D;UACA;UACA;UACA;UACA;UACA,MAAMnF,CAAC,GAAG2E,GAAG,CAACoB,SAAS,CAAC3E,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;UAC7C,MAAMJ,GAAG,GAAG7L,OAAO,CAACsP,OAAO,CAAC1D,QAAQ,EAAEf,CAAC,CAAC;UACxCgF,OAAO,GAAG,QAAQhE,GAAG,EAAE;QACzB,CAAC,MAAM;UACLgE,OAAO,GAAGL,GAAG,CAACqB,QAAQ;QACxB;QAEA,IAAI1M,OAAO,CAAC2M,QAAQ,EAAE;UACpB,MAAMC,OAAO,GAAGzQ,WAAW,CAACmH,GAAG,CAACtD,OAAO,CAAC2M,QAAQ,CAAC;UACjDvB,GAAG,CAACwB,OAAO,CAAC,CAAC9J,IAAI,CAAC,GAAG4I,OAAO;UAC5B;UACA;UACA,IAAI1L,OAAO,CAAC2M,QAAQ,KAAK,MAAM,IAAIvB,GAAG,CAACyB,oBAAoB,EAAE;YAC3D,OAAOzB,GAAG,CAACyB,oBAAoB,CAAC/J,IAAI,CAAC;UACvC;QACF,CAAC,MAAM;UACL,IAAI1G,SAAS,CAACgP,GAAG,EAAE,cAAc,EAAEtI,IAAI,CAAC,EAAE;YACxCsI,GAAG,CAAC0B,YAAY,CAAChK,IAAI,CAAC,GAAG4I,OAAO;UAClC;UAEA,IAAItP,SAAS,CAACgP,GAAG,EAAE,iBAAiB,EAAEtI,IAAI,CAAC,EAAE;YAC3CsI,GAAG,CAAC2B,eAAe,CAACjK,IAAI,CAAC,GAAG4I,OAAO;YACnC;YACA,IAAItP,SAAS,CAACgP,GAAG,EAAE,kBAAkB,EAAEtI,IAAI,CAAC,IAAI,CAAC1I,UAAU,CAACsR,OAAO,EAAEN,GAAG,CAAC4B,gBAAgB,CAAClK,IAAI,CAAC,CAAC,EAAE;cAChGsI,GAAG,CAAC4B,gBAAgB,CAAClK,IAAI,CAAC,GAAG4I,OAAO;YACtC;YAEA,IAAItP,SAAS,CAACgP,GAAG,EAAE,sBAAsB,EAAEtI,IAAI,CAAC,IAAI,CAAC1I,UAAU,CAACsR,OAAO,EAAEN,GAAG,CAACyB,oBAAoB,CAAC/J,IAAI,CAAC,CAAC,EAAE;cACxGsI,GAAG,CAACyB,oBAAoB,CAAC/J,IAAI,CAAC,GAAG4I,OAAO;YAC1C;UACF,CAAC,MAAM;YACL,IAAItP,SAAS,CAACgP,GAAG,EAAE,kBAAkB,EAAEtI,IAAI,CAAC,EAAE;cAC5CsI,GAAG,CAAC4B,gBAAgB,CAAClK,IAAI,CAAC,GAAG4I,OAAO;YACtC;YAEA,IAAItP,SAAS,CAACgP,GAAG,EAAE,sBAAsB,EAAEtI,IAAI,CAAC,EAAE;cAChDsI,GAAG,CAACyB,oBAAoB,CAAC/J,IAAI,CAAC,GAAG4I,OAAO;YAC1C;UACF;QACF;QAEAR,YAAY,CAAC/G,GAAG,CAACgH,OAAO,CAAC;MAC3B;IACF;;IAEA;IACA,MAAM;MACJ,CAACzP,MAAM,CAACC,GAAG,CAAC,QAAQ,CAAC,GAAGsR;IAC1B,CAAC,GAAG,IAAI,CAACxK,SAAS,CAACkE,OAAO;IAC1B,MAAMuG,MAAM,GAAGD,MAAM,KAAKE,SAAS,GAAG,IAAI,GAAGF,MAAM;IAEnD,MAAMG,OAAO,GAAG;MACdF,MAAM,EAAG,IAAI,CAACxN,kBAAkB,CAAC,IAAIwN,MAAM,GAAIA,MAAM,GACnD,IAAI,CAACxN,kBAAkB;IAC3B,CAAC;IAED,MAAMiL,QAAQ,GAAG,CAAC,IAAI,CAACjM,aAAa,CAAC,CAAC0O,OAAO,CAAC,CAAC;IAE/C,MAAMC,iBAAiB,GAAG,MAAO9E,IAAI,IAAK;MACxC,MAAM+E,OAAO,GAAG,MAAMjS,WAAW,CAACsO,IAAI,CAACpB,IAAI,CAACrH,IAAI,CAAC,CAC9CwD,KAAK,CAAC,MAAM,IAAIrJ,WAAW,CAACkN,IAAI,CAACrH,IAAI,CAAC,CAAC;MAC1C,MAAM;QACJ4L,YAAY,GAAG,CAAC,CAAC;QACjBC,eAAe,GAAG,CAAC,CAAC;QACpBF,oBAAoB,GAAG,CAAC,CAAC;QACzBG,gBAAgB,GAAG,CAAC;MACtB,CAAC,GAAGzE,IAAI,CAAC5B,OAAO;MAEhB2G,OAAO,CAACC,MAAM,CAAC;QACbT,YAAY;QACZC,eAAe;QACfF,oBAAoB;QACpBG;MACF,CAAC,CAAC;MACF,MAAMM,OAAO,CAACrC,IAAI,CAAC,CAAC;IACtB,CAAC;;IAED;IACA,KAAK,MAAM;MAAE1G,IAAI,EAAEgE;IAAK,CAAC,IAAI,IAAI,CAACjG,gBAAgB,EAAE;MAClD4I,YAAY,CAAC/G,GAAG,CAACoE,IAAI,CAAC;IACxB;IAEA,KAAK,MAAMA,IAAI,IAAI2C,YAAY,EAAE;MAC/B;MACA3C,IAAI,CAAC5B,OAAO,GAAG4B,IAAI,CAAC5B,OAAO;MAC3BgE,QAAQ,CAACpH,IAAI,CAAC8J,iBAAiB,CAAC9E,IAAI,CAAC,CAAC;IACxC;IAEA,MAAMxF,OAAO,CAACC,GAAG,CAAC2H,QAAQ,CAAC;IAC3B7J,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,YAAY,CAAC;IACrC,OAAO,IAAI;EACb;EAEA,OAAOrC,aAAa,EAAG0O,OAAO,EAAE;IAC9B,IAAI,CAAC,IAAI,CAAC3N,eAAe,CAAC,EAAE;MAC1B;IACF;IAEA,MAAM;MAAE+N;IAAK,CAAC,GAAG,IAAI,CAAC/K,SAAS;IAE/B,OAAO+K,IAAI,CAACvC,IAAI,CAACmC,OAAO,CAAC;EAC3B;EAEA,OAAOzO,kBAAkB,IAAK;IAC5B;IACA,KAAK,MAAMuC,IAAI,IAAI,IAAI,CAACnE,UAAU,CAAC,EAAE;MACnC,MAAM0Q,GAAG,GAAG5R,OAAO,CAAC,IAAI,CAAC4G,SAAS,CAACgF,QAAQ,EAAEvG,IAAI,CAAC;MAClD,MAAMkB,IAAI,GAAG,IAAI,CAACK,SAAS,CAACuC,SAAS,CAAC1B,GAAG,CAACmK,GAAG,CAAC;MAC9C,IAAIrL,IAAI,IAAIA,IAAI,CAACiE,IAAI,KAAK,IAAI,CAAC5D,SAAS,EAAE;QACxCL,IAAI,CAAC+E,MAAM,GAAG,IAAI;MACpB;IACF;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,IAAI,CAAC9G,IAAI,IAAI,IAAI,CAACA,IAAI,CAACoJ,SAAS,CAAClH,IAAI,EAAE;MACzC,MAAMmL,MAAM,GAAG,IAAIpN,GAAG,CAAC,CAAC;MAExB,MAAM;QAAEmJ;MAAU,CAAC,GAAG,IAAI,CAACpJ,IAAI;MAC/B,MAAM0F,IAAI,GAAG,IAAIzF,GAAG,CAAC,CAAC;MACtB,KAAK,MAAM,CAACmN,GAAG,EAAErK,KAAK,CAAC,IAAI,IAAI,CAACX,SAAS,CAACuC,SAAS,CAACX,OAAO,CAAC,CAAC,EAAE;QAC7D0B,IAAI,CAAC5B,GAAG,CAACsJ,GAAG,CAAC;;QAEb;QACA;QACA,IAAIhE,SAAS,CAAC7I,GAAG,CAACwC,KAAK,CAAC,EAAE;UACxB;QACF;;QAEA;QACA;QACA;QACA;QACA,MAAMI,MAAM,GAAG,IAAI,CAACvC,UAAU,CAAC+D,SAAS,CAAC1B,GAAG,CAACmK,GAAG,CAAC;QACjD,IAAI,CAACjK,MAAM,EAAE;UACXJ,KAAK,CAACiD,IAAI,GAAG,IAAI;QACnB,CAAC,MAAM;UACL,IAAI,CAAC,GAAG7C,MAAM,CAACmK,OAAO,CAAC,CAAC/K,IAAI,CAACgL,IAAI,IAAInE,SAAS,CAAC7I,GAAG,CAACgN,IAAI,CAAC,CAAC,EAAE;YACzD7H,IAAI,CAAC5B,GAAG,CAACX,MAAM,CAAC+C,QAAQ,CAAC;YACzB;UACF;UACA,MAAM;YAAEkB,QAAQ;YAAEvC;UAAO,CAAC,GAAG1B,MAAM;UACnC,IAAI0B,MAAM,IAAI9B,KAAK,CAAC8B,MAAM,IAAI9B,KAAK,CAACqE,QAAQ,KAAKA,QAAQ,EAAE;YACzD;UACF,CAAC,MAAM;YACLiG,MAAM,CAACvJ,GAAG,CAACX,MAAM,CAAC;UACpB;QACF;MACF;;MAEA;MACA;MACA,KAAK,MAAM,CAACiK,GAAG,EAAEjK,MAAM,CAAC,IAAI,IAAI,CAACvC,UAAU,CAAC+D,SAAS,CAACX,OAAO,CAAC,CAAC,EAAE;QAC/D,IAAI0B,IAAI,CAACnF,GAAG,CAAC6M,GAAG,CAAC,EAAE;UACjB;QACF;QACA1H,IAAI,CAAC5B,GAAG,CAACsJ,GAAG,CAAC;;QAEb;QACA;QACA;QACA;QACA,IAAIhE,SAAS,CAAC7I,GAAG,CAAC4C,MAAM,CAAC,EAAE;UACzB;QACF;QAEAkK,MAAM,CAACvJ,GAAG,CAACX,MAAM,CAAC;MACpB;;MAEA;MACA,KAAK,MAAMA,MAAM,IAAIkK,MAAM,EAAE;QAC3BlK,MAAM,CAAC6C,IAAI,GAAG,IAAI,CAAC5D,SAAS;MAC9B;;MAEA;MACA,KAAK,MAAMkC,GAAG,IAAI,IAAI,CAAClC,SAAS,CAACoL,IAAI,EAAE;QACrC,IAAIlJ,GAAG,CAACgJ,OAAO,CAACpL,IAAI,KAAK,CAAC,EAAE;UAC1BoC,GAAG,CAAC0B,IAAI,GAAG,IAAI;QACjB;MACF;;MAEA;MACA;MACAnK,YAAY,CAAC,IAAI,CAACuG,SAAS,CAAC;IAC9B;;IAEA;IACA,IAAI,CAACA,SAAS,CAAC+K,IAAI,CAACM,QAAQ,GAC1B,IAAI,CAACrL,SAAS,CAACgF,QAAQ,GAAG,kCAAkC;IAC9D,IAAI,CAAChF,SAAS,CAAC+K,IAAI,CAACO,cAAc,GAAG,IAAI;IAEzC,IAAI,CAAC9M,UAAU,GAAG,IAAI,CAACwB,SAAS;IAChC,IAAI,CAACA,SAAS,GAAG,IAAI;IAErB,IAAI,CAAC,IAAI,CAACnD,OAAO,CAAC,EAAE;MAClB,MAAM,IAAI,CAAC2B,UAAU,CAACuM,IAAI,CAACvC,IAAI,CAAC,CAAC;IACnC;EACF;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}