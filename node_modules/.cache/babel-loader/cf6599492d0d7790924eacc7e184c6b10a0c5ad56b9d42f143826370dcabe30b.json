{"ast":null,"code":"// Given a dep, a node that depends on it, and the edge representing that\n// dependency, place the dep somewhere in the node's tree, and all of its\n// peer dependencies.\n//\n// Handles all of the tree updating needed to place the dep, including\n// removing replaced nodes, pruning now-extraneous or invalidated nodes,\n// and saves a set of what was placed and what needs re-evaluation as\n// a result.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\nconst log = require('proc-log');\nconst deepestNestingTarget = require('./deepest-nesting-target.js');\nconst CanPlaceDep = require('./can-place-dep.js');\nconst {\n  KEEP,\n  CONFLICT\n} = CanPlaceDep;\nconst debug = require('./debug.js');\nconst Link = require('./link.js');\nconst gatherDepSet = require('./gather-dep-set.js');\nconst peerEntrySets = require('./peer-entry-sets.js');\nclass PlaceDep {\n  constructor(options) {\n    const {\n      dep,\n      edge,\n      parent = null\n    } = options;\n    this.name = edge.name;\n    this.dep = dep;\n    this.edge = edge;\n    this.canPlace = null;\n    this.target = null;\n    this.placed = null;\n\n    // inherit all these fields from the parent to ensure consistency.\n    const {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      legacyPeerDeps,\n      globalStyle\n    } = parent || options;\n    Object.assign(this, {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      legacyPeerDeps,\n      globalStyle\n    });\n    this.children = [];\n    this.parent = parent;\n    this.peerConflict = null;\n    this.needEvaluation = new Set();\n    this.checks = new Map();\n    this.place();\n  }\n  place() {\n    const {\n      edge,\n      dep,\n      preferDedupe,\n      globalStyle,\n      legacyBundling,\n      explicitRequest,\n      updateNames,\n      checks\n    } = this;\n\n    // nothing to do if the edge is fine as it is\n    if (edge.to && !edge.error && !explicitRequest && !updateNames.includes(edge.name) && !this.isVulnerable(edge.to)) {\n      return;\n    }\n\n    // walk up the tree until we hit either a top/root node, or a place\n    // where the dep is not a peer dep.\n    const start = this.getStartNode();\n    let canPlace = null;\n    let canPlaceSelf = null;\n    for (const target of start.ancestry()) {\n      // if the current location has a peerDep on it, then we can't place here\n      // this is pretty rare to hit, since we always prefer deduping peers,\n      // and the getStartNode will start us out above any peers from the\n      // thing that depends on it.  but we could hit it with something like:\n      //\n      // a -> (b@1, c@1)\n      // +-- c@1\n      // +-- b -> PEEROPTIONAL(v) (c@2)\n      //     +-- c@2 -> (v)\n      //\n      // So we check if we can place v under c@2, that's fine.\n      // Then we check under b, and can't, because of the optional peer dep.\n      // but we CAN place it under a, so the correct thing to do is keep\n      // walking up the tree.\n      const targetEdge = target.edgesOut.get(edge.name);\n      if (!target.isTop && targetEdge && targetEdge.peer) {\n        continue;\n      }\n      const cpd = new CanPlaceDep({\n        dep,\n        edge,\n        // note: this sets the parent's canPlace as the parent of this\n        // canPlace, but it does NOT add this canPlace to the parent's\n        // children.  This way, we can know that it's a peer dep, and\n        // get the top edge easily, while still maintaining the\n        // tree of checks that factored into the original decision.\n        parent: this.parent && this.parent.canPlace,\n        target,\n        preferDedupe,\n        explicitRequest: this.explicitRequest\n      });\n      checks.set(target, cpd);\n\n      // It's possible that a \"conflict\" is a conflict among the *peers* of\n      // a given node we're trying to place, but there actually is no current\n      // node.  Eg,\n      // root -> (a, b)\n      // a -> PEER(c)\n      // b -> PEER(d)\n      // d -> PEER(c@2)\n      // We place (a), and get a peer of (c) along with it.\n      // then we try to place (b), and get CONFLICT in the check, because\n      // of the conflicting peer from (b)->(d)->(c@2).  In that case, we\n      // should treat (b) and (d) as OK, and place them in the last place\n      // where they did not themselves conflict, and skip c@2 if conflict\n      // is ok by virtue of being forced or not ours and not strict.\n      if (cpd.canPlaceSelf !== CONFLICT) {\n        canPlaceSelf = cpd;\n      }\n\n      // we found a place this can go, along with all its peer friends.\n      // we break when we get the first conflict\n      if (cpd.canPlace !== CONFLICT) {\n        canPlace = cpd;\n      } else {\n        break;\n      }\n\n      // if it's a load failure, just plop it in the first place attempted,\n      // since we're going to crash the build or prune it out anyway.\n      // but, this will frequently NOT be a successful canPlace, because\n      // it'll have no version or other information.\n      if (dep.errors.length) {\n        break;\n      }\n\n      // nest packages like npm v1 and v2\n      // very disk-inefficient\n      if (legacyBundling) {\n        break;\n      }\n\n      // when installing globally, or just in global style, we never place\n      // deps above the first level.\n      if (globalStyle) {\n        const rp = target.resolveParent;\n        if (rp && rp.isProjectRoot) {\n          break;\n        }\n      }\n    }\n    Object.assign(this, {\n      canPlace,\n      canPlaceSelf\n    });\n    this.current = edge.to;\n\n    // if we can't find a target, that means that the last place checked,\n    // and all the places before it, had a conflict.\n    if (!canPlace) {\n      // if not forced, or it's our dep, or strictPeerDeps is set, then\n      // this is an ERESOLVE error.\n      if (!this.conflictOk) {\n        return this.failPeerConflict();\n      }\n\n      // ok!  we're gonna allow the conflict, but we should still warn\n      // if we have a current, then we treat CONFLICT as a KEEP.\n      // otherwise, we just skip it.  Only warn on the one that actually\n      // could not be placed somewhere.\n      if (!canPlaceSelf) {\n        this.warnPeerConflict();\n        return;\n      }\n      this.canPlace = canPlaceSelf;\n    }\n\n    // now we have a target, a tree of CanPlaceDep results for the peer group,\n    // and we are ready to go\n    this.placeInTree();\n  }\n  placeInTree() {\n    const {\n      dep,\n      canPlace,\n      edge\n    } = this;\n\n    /* istanbul ignore next */\n    if (!canPlace) {\n      debug(() => {\n        throw new Error('canPlace not set, but trying to place in tree');\n      });\n      return;\n    }\n    const {\n      target\n    } = canPlace;\n    log.silly('placeDep', target.location || 'ROOT', `${dep.name}@${dep.version}`, canPlace.description, `for: ${this.edge.from.package._id || this.edge.from.location}`, `want: ${edge.spec || '*'}`);\n    const placementType = canPlace.canPlace === CONFLICT ? canPlace.canPlaceSelf : canPlace.canPlace;\n\n    // if we're placing in the tree with --force, we can get here even though\n    // it's a conflict.  Treat it as a KEEP, but warn and move on.\n    if (placementType === KEEP) {\n      // this was an overridden peer dep\n      if (edge.peer && !edge.valid) {\n        this.warnPeerConflict();\n      }\n\n      // if we get a KEEP in a update scenario, then we MAY have something\n      // already duplicating this unnecessarily!  For example:\n      // ```\n      // root (dep: y@1)\n      // +-- x (dep: y@1.1)\n      // |   +-- y@1.1.0 (replacing with 1.1.2, got KEEP at the root)\n      // +-- y@1.1.2 (updated already from 1.0.0)\n      // ```\n      // Now say we do `reify({update:['y']})`, and the latest version is\n      // 1.1.2, which we now have in the root.  We'll try to place y@1.1.2\n      // first in x, then in the root, ending with KEEP, because we already\n      // have it.  In that case, we ought to REMOVE the nm/x/nm/y node, because\n      // it is an unnecessary duplicate.\n      this.pruneDedupable(target);\n      return;\n    }\n\n    // we were told to place it here in the target, so either it does not\n    // already exist in the tree, OR it's shadowed.\n    // handle otherwise unresolvable dependency nesting loops by\n    // creating a symbolic link\n    // a1 -> b1 -> a2 -> b2 -> a1 -> ...\n    // instead of nesting forever, when the loop occurs, create\n    // a symbolic link to the earlier instance\n    for (let p = target; p; p = p.resolveParent) {\n      if (p.matches(dep) && !p.isTop) {\n        this.placed = new Link({\n          parent: target,\n          target: p\n        });\n        return;\n      }\n    }\n\n    // XXX if we are replacing SOME of a peer entry group, we will need to\n    // remove any that are not being replaced and will now be invalid, and\n    // re-evaluate them deeper into the tree.\n\n    const virtualRoot = dep.parent;\n    this.placed = new dep.constructor({\n      name: dep.name,\n      pkg: dep.package,\n      resolved: dep.resolved,\n      integrity: dep.integrity,\n      legacyPeerDeps: this.legacyPeerDeps,\n      error: dep.errors[0],\n      ...(dep.isLink ? {\n        target: dep.target,\n        realpath: dep.realpath\n      } : {})\n    });\n    this.oldDep = target.children.get(this.name);\n    if (this.oldDep) {\n      this.replaceOldDep();\n    } else {\n      this.placed.parent = target;\n    }\n\n    // if it's an overridden peer dep, warn about it\n    if (edge.peer && !this.placed.satisfies(edge)) {\n      this.warnPeerConflict();\n    }\n\n    // If the edge is not an error, then we're updating something, and\n    // MAY end up putting a better/identical node further up the tree in\n    // a way that causes an unnecessary duplication.  If so, remove the\n    // now-unnecessary node.\n    if (edge.valid && edge.to && edge.to !== this.placed) {\n      this.pruneDedupable(edge.to, false);\n    }\n\n    // in case we just made some duplicates that can be removed,\n    // prune anything deeper in the tree that can be replaced by this\n    for (const node of target.root.inventory.query('name', this.name)) {\n      if (node.isDescendantOf(target) && !node.isTop) {\n        this.pruneDedupable(node, false);\n        // only walk the direct children of the ones we kept\n        if (node.root === target.root) {\n          for (const kid of node.children.values()) {\n            this.pruneDedupable(kid, false);\n          }\n        }\n      }\n    }\n\n    // also place its unmet or invalid peer deps at this location\n    // loop through any peer deps from the thing we just placed, and place\n    // those ones as well.  it's safe to do this with the virtual nodes,\n    // because we're copying rather than moving them out of the virtual root,\n    // otherwise they'd be gone and the peer set would change throughout\n    // this loop.\n    for (const peerEdge of this.placed.edgesOut.values()) {\n      if (peerEdge.valid || !peerEdge.peer || peerEdge.overridden) {\n        continue;\n      }\n      const peer = virtualRoot.children.get(peerEdge.name);\n\n      // Note: if the virtualRoot *doesn't* have the peer, then that means\n      // it's an optional peer dep.  If it's not being properly met (ie,\n      // peerEdge.valid is false), then this is likely heading for an\n      // ERESOLVE error, unless it can walk further up the tree.\n      if (!peer) {\n        continue;\n      }\n\n      // overridden peerEdge, just accept what's there already\n      if (!peer.satisfies(peerEdge)) {\n        continue;\n      }\n      this.children.push(new PlaceDep({\n        parent: this,\n        dep: peer,\n        node: this.placed,\n        edge: peerEdge\n      }));\n    }\n  }\n  replaceOldDep() {\n    const target = this.oldDep.parent;\n\n    // XXX handle replacing an entire peer group?\n    // what about cases where we need to push some other peer groups deeper\n    // into the tree?  all the tree updating should be done here, and track\n    // all the things that we add and remove, so that we can know what\n    // to re-evaluate.\n\n    // if we're replacing, we should also remove any nodes for edges that\n    // are now invalid, and where this (or its deps) is the only dependent,\n    // and also recurse on that pruning.  Otherwise leaving that dep node\n    // around can result in spurious conflicts pushing nodes deeper into\n    // the tree than needed in the case of cycles that will be removed\n    // later anyway.\n    const oldDeps = [];\n    for (const [name, edge] of this.oldDep.edgesOut.entries()) {\n      if (!this.placed.edgesOut.has(name) && edge.to) {\n        oldDeps.push(...gatherDepSet([edge.to], e => e.to !== edge.to));\n      }\n    }\n\n    // gather all peer edgesIn which are at this level, and will not be\n    // satisfied by the new dependency.  Those are the peer sets that need\n    // to be either warned about (if they cannot go deeper), or removed and\n    // re-placed (if they can).\n    const prunePeerSets = [];\n    for (const edge of this.oldDep.edgesIn) {\n      if (this.placed.satisfies(edge) || !edge.peer || edge.from.parent !== target || edge.overridden) {\n        // not a peer dep, not invalid, or not from this level, so it's fine\n        // to just let it re-evaluate as a problemEdge later, or let it be\n        // satisfied by the new dep being placed.\n        continue;\n      }\n      for (const entryEdge of peerEntrySets(edge.from).keys()) {\n        // either this one needs to be pruned and re-evaluated, or marked\n        // as overridden and warned about.  If the entryEdge comes in from\n        // the root, then we have to leave it alone, and in that case, it\n        // will have already warned or crashed by getting to this point.\n        const entryNode = entryEdge.to;\n        const deepestTarget = deepestNestingTarget(entryNode);\n        if (deepestTarget !== target && !entryEdge.from.isRoot) {\n          prunePeerSets.push(...gatherDepSet([entryNode], e => {\n            return e.to !== entryNode && !e.overridden;\n          }));\n        } else {\n          this.warnPeerConflict(edge, this.dep);\n        }\n      }\n    }\n    this.placed.replace(this.oldDep);\n    this.pruneForReplacement(this.placed, oldDeps);\n    for (const dep of prunePeerSets) {\n      for (const edge of dep.edgesIn) {\n        this.needEvaluation.add(edge.from);\n      }\n      dep.root = null;\n    }\n  }\n  pruneForReplacement(node, oldDeps) {\n    // gather up all the now-invalid/extraneous edgesOut, as long as they are\n    // only depended upon by the old node/deps\n    const invalidDeps = new Set([...node.edgesOut.values()].filter(e => e.to && !e.valid).map(e => e.to));\n    for (const dep of oldDeps) {\n      const set = gatherDepSet([dep], e => e.to !== dep && e.valid);\n      for (const dep of set) {\n        invalidDeps.add(dep);\n      }\n    }\n\n    // ignore dependency edges from the node being replaced, but\n    // otherwise filter the set down to just the set with no\n    // dependencies from outside the set, except the node in question.\n    const deps = gatherDepSet(invalidDeps, edge => edge.from !== node && edge.to !== node && edge.valid);\n\n    // now just delete whatever's left, because it's junk\n    for (const dep of deps) {\n      dep.root = null;\n    }\n  }\n\n  // prune all the nodes in a branch of the tree that can be safely removed\n  // This is only the most basic duplication detection; it finds if there\n  // is another satisfying node further up the tree, and if so, dedupes.\n  // Even in legacyBundling mode, we do this amount of deduplication.\n  pruneDedupable(node, descend = true) {\n    if (node.canDedupe(this.preferDedupe)) {\n      // gather up all deps that have no valid edges in from outside\n      // the dep set, except for this node we're deduping, so that we\n      // also prune deps that would be made extraneous.\n      const deps = gatherDepSet([node], e => e.to !== node && e.valid);\n      for (const node of deps) {\n        node.root = null;\n      }\n      return;\n    }\n    if (descend) {\n      // sort these so that they're deterministically ordered\n      // otherwise, resulting tree shape is dependent on the order\n      // in which they happened to be resolved.\n      const nodeSort = (a, b) => localeCompare(a.location, b.location);\n      const children = [...node.children.values()].sort(nodeSort);\n      for (const child of children) {\n        this.pruneDedupable(child);\n      }\n      const fsChildren = [...node.fsChildren].sort(nodeSort);\n      for (const topNode of fsChildren) {\n        const children = [...topNode.children.values()].sort(nodeSort);\n        for (const child of children) {\n          this.pruneDedupable(child);\n        }\n      }\n    }\n  }\n  get conflictOk() {\n    return this.force || !this.isMine && !this.strictPeerDeps;\n  }\n  get isMine() {\n    const {\n      edge\n    } = this.top;\n    const {\n      from: node\n    } = edge;\n    if (node.isWorkspace || node.isProjectRoot) {\n      return true;\n    }\n    if (!edge.peer) {\n      return false;\n    }\n\n    // re-entry case.  check if any non-peer edges come from the project,\n    // or any entryEdges on peer groups are from the root.\n    let hasPeerEdges = false;\n    for (const edge of node.edgesIn) {\n      if (edge.peer) {\n        hasPeerEdges = true;\n        continue;\n      }\n      if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n        return true;\n      }\n    }\n    if (hasPeerEdges) {\n      for (const edge of peerEntrySets(node).keys()) {\n        if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  warnPeerConflict(edge, dep) {\n    edge = edge || this.edge;\n    dep = dep || this.dep;\n    edge.overridden = true;\n    const expl = this.explainPeerConflict(edge, dep);\n    log.warn('ERESOLVE', 'overriding peer dependency', expl);\n  }\n  failPeerConflict(edge, dep) {\n    edge = edge || this.top.edge;\n    dep = dep || this.top.dep;\n    const expl = this.explainPeerConflict(edge, dep);\n    throw Object.assign(new Error('could not resolve'), expl);\n  }\n  explainPeerConflict(edge, dep) {\n    const {\n      from: node\n    } = edge;\n    const curNode = node.resolve(edge.name);\n    const expl = {\n      code: 'ERESOLVE',\n      edge: edge.explain(),\n      dep: dep.explain(edge)\n    };\n    if (this.parent) {\n      // this is the conflicted peer\n      expl.current = curNode && curNode.explain(edge);\n      expl.peerConflict = this.current && this.current.explain(this.edge);\n    } else {\n      expl.current = curNode && curNode.explain();\n      if (this.canPlaceSelf && this.canPlaceSelf.canPlaceSelf !== CONFLICT) {\n        // failed while checking for a child dep\n        const cps = this.canPlaceSelf;\n        for (const peer of cps.conflictChildren) {\n          if (peer.current) {\n            expl.peerConflict = {\n              current: peer.current.explain(),\n              peer: peer.dep.explain(peer.edge)\n            };\n            break;\n          }\n        }\n      } else {\n        expl.peerConflict = {\n          current: this.current && this.current.explain(),\n          peer: this.dep.explain(this.edge)\n        };\n      }\n    }\n    const {\n      strictPeerDeps,\n      force,\n      isMine\n    } = this;\n    Object.assign(expl, {\n      strictPeerDeps,\n      force,\n      isMine\n    });\n\n    // XXX decorate more with this.canPlace and this.canPlaceSelf,\n    // this.checks, this.children, walk over conflicted peers, etc.\n    return expl;\n  }\n  getStartNode() {\n    // if we are a peer, then we MUST be at least as shallow as the\n    // peer dependent\n    const from = this.parent ? this.parent.getStartNode() : this.edge.from;\n    return deepestNestingTarget(from, this.name);\n  }\n  get top() {\n    return this.parent ? this.parent.top : this;\n  }\n  isVulnerable(node) {\n    return this.auditReport && this.auditReport.isVulnerable(node);\n  }\n  get allChildren() {\n    const set = new Set(this.children);\n    for (const child of set) {\n      for (const grandchild of child.children) {\n        set.add(grandchild);\n      }\n    }\n    return [...set];\n  }\n}\nmodule.exports = PlaceDep;","map":{"version":3,"names":["localeCompare","require","log","deepestNestingTarget","CanPlaceDep","KEEP","CONFLICT","debug","Link","gatherDepSet","peerEntrySets","PlaceDep","constructor","options","dep","edge","parent","name","canPlace","target","placed","preferDedupe","force","explicitRequest","updateNames","auditReport","legacyBundling","strictPeerDeps","legacyPeerDeps","globalStyle","Object","assign","children","peerConflict","needEvaluation","Set","checks","Map","place","to","error","includes","isVulnerable","start","getStartNode","canPlaceSelf","ancestry","targetEdge","edgesOut","get","isTop","peer","cpd","set","errors","length","rp","resolveParent","isProjectRoot","current","conflictOk","failPeerConflict","warnPeerConflict","placeInTree","Error","silly","location","version","description","from","package","_id","spec","placementType","valid","pruneDedupable","p","matches","virtualRoot","pkg","resolved","integrity","isLink","realpath","oldDep","replaceOldDep","satisfies","node","root","inventory","query","isDescendantOf","kid","values","peerEdge","overridden","push","oldDeps","entries","has","e","prunePeerSets","edgesIn","entryEdge","keys","entryNode","deepestTarget","isRoot","replace","pruneForReplacement","add","invalidDeps","filter","map","deps","descend","canDedupe","nodeSort","a","b","sort","child","fsChildren","topNode","isMine","top","isWorkspace","hasPeerEdges","expl","explainPeerConflict","warn","curNode","resolve","code","explain","cps","conflictChildren","allChildren","grandchild","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/place-dep.js"],"sourcesContent":["// Given a dep, a node that depends on it, and the edge representing that\n// dependency, place the dep somewhere in the node's tree, and all of its\n// peer dependencies.\n//\n// Handles all of the tree updating needed to place the dep, including\n// removing replaced nodes, pruning now-extraneous or invalidated nodes,\n// and saves a set of what was placed and what needs re-evaluation as\n// a result.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst log = require('proc-log')\nconst deepestNestingTarget = require('./deepest-nesting-target.js')\nconst CanPlaceDep = require('./can-place-dep.js')\nconst {\n  KEEP,\n  CONFLICT,\n} = CanPlaceDep\nconst debug = require('./debug.js')\n\nconst Link = require('./link.js')\nconst gatherDepSet = require('./gather-dep-set.js')\nconst peerEntrySets = require('./peer-entry-sets.js')\n\nclass PlaceDep {\n  constructor (options) {\n    const {\n      dep,\n      edge,\n      parent = null,\n    } = options\n    this.name = edge.name\n    this.dep = dep\n    this.edge = edge\n    this.canPlace = null\n\n    this.target = null\n    this.placed = null\n\n    // inherit all these fields from the parent to ensure consistency.\n    const {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      legacyPeerDeps,\n      globalStyle,\n    } = parent || options\n    Object.assign(this, {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      legacyPeerDeps,\n      globalStyle,\n    })\n\n    this.children = []\n    this.parent = parent\n    this.peerConflict = null\n\n    this.needEvaluation = new Set()\n\n    this.checks = new Map()\n\n    this.place()\n  }\n\n  place () {\n    const {\n      edge,\n      dep,\n      preferDedupe,\n      globalStyle,\n      legacyBundling,\n      explicitRequest,\n      updateNames,\n      checks,\n    } = this\n\n    // nothing to do if the edge is fine as it is\n    if (edge.to &&\n        !edge.error &&\n        !explicitRequest &&\n        !updateNames.includes(edge.name) &&\n        !this.isVulnerable(edge.to)) {\n      return\n    }\n\n    // walk up the tree until we hit either a top/root node, or a place\n    // where the dep is not a peer dep.\n    const start = this.getStartNode()\n\n    let canPlace = null\n    let canPlaceSelf = null\n    for (const target of start.ancestry()) {\n      // if the current location has a peerDep on it, then we can't place here\n      // this is pretty rare to hit, since we always prefer deduping peers,\n      // and the getStartNode will start us out above any peers from the\n      // thing that depends on it.  but we could hit it with something like:\n      //\n      // a -> (b@1, c@1)\n      // +-- c@1\n      // +-- b -> PEEROPTIONAL(v) (c@2)\n      //     +-- c@2 -> (v)\n      //\n      // So we check if we can place v under c@2, that's fine.\n      // Then we check under b, and can't, because of the optional peer dep.\n      // but we CAN place it under a, so the correct thing to do is keep\n      // walking up the tree.\n      const targetEdge = target.edgesOut.get(edge.name)\n      if (!target.isTop && targetEdge && targetEdge.peer) {\n        continue\n      }\n\n      const cpd = new CanPlaceDep({\n        dep,\n        edge,\n        // note: this sets the parent's canPlace as the parent of this\n        // canPlace, but it does NOT add this canPlace to the parent's\n        // children.  This way, we can know that it's a peer dep, and\n        // get the top edge easily, while still maintaining the\n        // tree of checks that factored into the original decision.\n        parent: this.parent && this.parent.canPlace,\n        target,\n        preferDedupe,\n        explicitRequest: this.explicitRequest,\n      })\n      checks.set(target, cpd)\n\n      // It's possible that a \"conflict\" is a conflict among the *peers* of\n      // a given node we're trying to place, but there actually is no current\n      // node.  Eg,\n      // root -> (a, b)\n      // a -> PEER(c)\n      // b -> PEER(d)\n      // d -> PEER(c@2)\n      // We place (a), and get a peer of (c) along with it.\n      // then we try to place (b), and get CONFLICT in the check, because\n      // of the conflicting peer from (b)->(d)->(c@2).  In that case, we\n      // should treat (b) and (d) as OK, and place them in the last place\n      // where they did not themselves conflict, and skip c@2 if conflict\n      // is ok by virtue of being forced or not ours and not strict.\n      if (cpd.canPlaceSelf !== CONFLICT) {\n        canPlaceSelf = cpd\n      }\n\n      // we found a place this can go, along with all its peer friends.\n      // we break when we get the first conflict\n      if (cpd.canPlace !== CONFLICT) {\n        canPlace = cpd\n      } else {\n        break\n      }\n\n      // if it's a load failure, just plop it in the first place attempted,\n      // since we're going to crash the build or prune it out anyway.\n      // but, this will frequently NOT be a successful canPlace, because\n      // it'll have no version or other information.\n      if (dep.errors.length) {\n        break\n      }\n\n      // nest packages like npm v1 and v2\n      // very disk-inefficient\n      if (legacyBundling) {\n        break\n      }\n\n      // when installing globally, or just in global style, we never place\n      // deps above the first level.\n      if (globalStyle) {\n        const rp = target.resolveParent\n        if (rp && rp.isProjectRoot) {\n          break\n        }\n      }\n    }\n\n    Object.assign(this, {\n      canPlace,\n      canPlaceSelf,\n    })\n    this.current = edge.to\n\n    // if we can't find a target, that means that the last place checked,\n    // and all the places before it, had a conflict.\n    if (!canPlace) {\n      // if not forced, or it's our dep, or strictPeerDeps is set, then\n      // this is an ERESOLVE error.\n      if (!this.conflictOk) {\n        return this.failPeerConflict()\n      }\n\n      // ok!  we're gonna allow the conflict, but we should still warn\n      // if we have a current, then we treat CONFLICT as a KEEP.\n      // otherwise, we just skip it.  Only warn on the one that actually\n      // could not be placed somewhere.\n      if (!canPlaceSelf) {\n        this.warnPeerConflict()\n        return\n      }\n\n      this.canPlace = canPlaceSelf\n    }\n\n    // now we have a target, a tree of CanPlaceDep results for the peer group,\n    // and we are ready to go\n    this.placeInTree()\n  }\n\n  placeInTree () {\n    const {\n      dep,\n      canPlace,\n      edge,\n    } = this\n\n    /* istanbul ignore next */\n    if (!canPlace) {\n      debug(() => {\n        throw new Error('canPlace not set, but trying to place in tree')\n      })\n      return\n    }\n\n    const { target } = canPlace\n\n    log.silly(\n      'placeDep',\n      target.location || 'ROOT',\n      `${dep.name}@${dep.version}`,\n      canPlace.description,\n      `for: ${this.edge.from.package._id || this.edge.from.location}`,\n      `want: ${edge.spec || '*'}`\n    )\n\n    const placementType = canPlace.canPlace === CONFLICT\n      ? canPlace.canPlaceSelf\n      : canPlace.canPlace\n\n    // if we're placing in the tree with --force, we can get here even though\n    // it's a conflict.  Treat it as a KEEP, but warn and move on.\n    if (placementType === KEEP) {\n      // this was an overridden peer dep\n      if (edge.peer && !edge.valid) {\n        this.warnPeerConflict()\n      }\n\n      // if we get a KEEP in a update scenario, then we MAY have something\n      // already duplicating this unnecessarily!  For example:\n      // ```\n      // root (dep: y@1)\n      // +-- x (dep: y@1.1)\n      // |   +-- y@1.1.0 (replacing with 1.1.2, got KEEP at the root)\n      // +-- y@1.1.2 (updated already from 1.0.0)\n      // ```\n      // Now say we do `reify({update:['y']})`, and the latest version is\n      // 1.1.2, which we now have in the root.  We'll try to place y@1.1.2\n      // first in x, then in the root, ending with KEEP, because we already\n      // have it.  In that case, we ought to REMOVE the nm/x/nm/y node, because\n      // it is an unnecessary duplicate.\n      this.pruneDedupable(target)\n      return\n    }\n\n    // we were told to place it here in the target, so either it does not\n    // already exist in the tree, OR it's shadowed.\n    // handle otherwise unresolvable dependency nesting loops by\n    // creating a symbolic link\n    // a1 -> b1 -> a2 -> b2 -> a1 -> ...\n    // instead of nesting forever, when the loop occurs, create\n    // a symbolic link to the earlier instance\n    for (let p = target; p; p = p.resolveParent) {\n      if (p.matches(dep) && !p.isTop) {\n        this.placed = new Link({ parent: target, target: p })\n        return\n      }\n    }\n\n    // XXX if we are replacing SOME of a peer entry group, we will need to\n    // remove any that are not being replaced and will now be invalid, and\n    // re-evaluate them deeper into the tree.\n\n    const virtualRoot = dep.parent\n    this.placed = new dep.constructor({\n      name: dep.name,\n      pkg: dep.package,\n      resolved: dep.resolved,\n      integrity: dep.integrity,\n      legacyPeerDeps: this.legacyPeerDeps,\n      error: dep.errors[0],\n      ...(dep.isLink ? { target: dep.target, realpath: dep.realpath } : {}),\n    })\n\n    this.oldDep = target.children.get(this.name)\n    if (this.oldDep) {\n      this.replaceOldDep()\n    } else {\n      this.placed.parent = target\n    }\n\n    // if it's an overridden peer dep, warn about it\n    if (edge.peer && !this.placed.satisfies(edge)) {\n      this.warnPeerConflict()\n    }\n\n    // If the edge is not an error, then we're updating something, and\n    // MAY end up putting a better/identical node further up the tree in\n    // a way that causes an unnecessary duplication.  If so, remove the\n    // now-unnecessary node.\n    if (edge.valid && edge.to && edge.to !== this.placed) {\n      this.pruneDedupable(edge.to, false)\n    }\n\n    // in case we just made some duplicates that can be removed,\n    // prune anything deeper in the tree that can be replaced by this\n    for (const node of target.root.inventory.query('name', this.name)) {\n      if (node.isDescendantOf(target) && !node.isTop) {\n        this.pruneDedupable(node, false)\n        // only walk the direct children of the ones we kept\n        if (node.root === target.root) {\n          for (const kid of node.children.values()) {\n            this.pruneDedupable(kid, false)\n          }\n        }\n      }\n    }\n\n    // also place its unmet or invalid peer deps at this location\n    // loop through any peer deps from the thing we just placed, and place\n    // those ones as well.  it's safe to do this with the virtual nodes,\n    // because we're copying rather than moving them out of the virtual root,\n    // otherwise they'd be gone and the peer set would change throughout\n    // this loop.\n    for (const peerEdge of this.placed.edgesOut.values()) {\n      if (peerEdge.valid || !peerEdge.peer || peerEdge.overridden) {\n        continue\n      }\n\n      const peer = virtualRoot.children.get(peerEdge.name)\n\n      // Note: if the virtualRoot *doesn't* have the peer, then that means\n      // it's an optional peer dep.  If it's not being properly met (ie,\n      // peerEdge.valid is false), then this is likely heading for an\n      // ERESOLVE error, unless it can walk further up the tree.\n      if (!peer) {\n        continue\n      }\n\n      // overridden peerEdge, just accept what's there already\n      if (!peer.satisfies(peerEdge)) {\n        continue\n      }\n\n      this.children.push(new PlaceDep({\n        parent: this,\n        dep: peer,\n        node: this.placed,\n        edge: peerEdge,\n      }))\n    }\n  }\n\n  replaceOldDep () {\n    const target = this.oldDep.parent\n\n    // XXX handle replacing an entire peer group?\n    // what about cases where we need to push some other peer groups deeper\n    // into the tree?  all the tree updating should be done here, and track\n    // all the things that we add and remove, so that we can know what\n    // to re-evaluate.\n\n    // if we're replacing, we should also remove any nodes for edges that\n    // are now invalid, and where this (or its deps) is the only dependent,\n    // and also recurse on that pruning.  Otherwise leaving that dep node\n    // around can result in spurious conflicts pushing nodes deeper into\n    // the tree than needed in the case of cycles that will be removed\n    // later anyway.\n    const oldDeps = []\n    for (const [name, edge] of this.oldDep.edgesOut.entries()) {\n      if (!this.placed.edgesOut.has(name) && edge.to) {\n        oldDeps.push(...gatherDepSet([edge.to], e => e.to !== edge.to))\n      }\n    }\n\n    // gather all peer edgesIn which are at this level, and will not be\n    // satisfied by the new dependency.  Those are the peer sets that need\n    // to be either warned about (if they cannot go deeper), or removed and\n    // re-placed (if they can).\n    const prunePeerSets = []\n    for (const edge of this.oldDep.edgesIn) {\n      if (this.placed.satisfies(edge) ||\n          !edge.peer ||\n          edge.from.parent !== target ||\n          edge.overridden) {\n        // not a peer dep, not invalid, or not from this level, so it's fine\n        // to just let it re-evaluate as a problemEdge later, or let it be\n        // satisfied by the new dep being placed.\n        continue\n      }\n      for (const entryEdge of peerEntrySets(edge.from).keys()) {\n        // either this one needs to be pruned and re-evaluated, or marked\n        // as overridden and warned about.  If the entryEdge comes in from\n        // the root, then we have to leave it alone, and in that case, it\n        // will have already warned or crashed by getting to this point.\n        const entryNode = entryEdge.to\n        const deepestTarget = deepestNestingTarget(entryNode)\n        if (deepestTarget !== target && !entryEdge.from.isRoot) {\n          prunePeerSets.push(...gatherDepSet([entryNode], e => {\n            return e.to !== entryNode && !e.overridden\n          }))\n        } else {\n          this.warnPeerConflict(edge, this.dep)\n        }\n      }\n    }\n\n    this.placed.replace(this.oldDep)\n    this.pruneForReplacement(this.placed, oldDeps)\n    for (const dep of prunePeerSets) {\n      for (const edge of dep.edgesIn) {\n        this.needEvaluation.add(edge.from)\n      }\n      dep.root = null\n    }\n  }\n\n  pruneForReplacement (node, oldDeps) {\n    // gather up all the now-invalid/extraneous edgesOut, as long as they are\n    // only depended upon by the old node/deps\n    const invalidDeps = new Set([...node.edgesOut.values()]\n      .filter(e => e.to && !e.valid).map(e => e.to))\n    for (const dep of oldDeps) {\n      const set = gatherDepSet([dep], e => e.to !== dep && e.valid)\n      for (const dep of set) {\n        invalidDeps.add(dep)\n      }\n    }\n\n    // ignore dependency edges from the node being replaced, but\n    // otherwise filter the set down to just the set with no\n    // dependencies from outside the set, except the node in question.\n    const deps = gatherDepSet(invalidDeps, edge =>\n      edge.from !== node && edge.to !== node && edge.valid)\n\n    // now just delete whatever's left, because it's junk\n    for (const dep of deps) {\n      dep.root = null\n    }\n  }\n\n  // prune all the nodes in a branch of the tree that can be safely removed\n  // This is only the most basic duplication detection; it finds if there\n  // is another satisfying node further up the tree, and if so, dedupes.\n  // Even in legacyBundling mode, we do this amount of deduplication.\n  pruneDedupable (node, descend = true) {\n    if (node.canDedupe(this.preferDedupe)) {\n      // gather up all deps that have no valid edges in from outside\n      // the dep set, except for this node we're deduping, so that we\n      // also prune deps that would be made extraneous.\n      const deps = gatherDepSet([node], e => e.to !== node && e.valid)\n      for (const node of deps) {\n        node.root = null\n      }\n      return\n    }\n    if (descend) {\n      // sort these so that they're deterministically ordered\n      // otherwise, resulting tree shape is dependent on the order\n      // in which they happened to be resolved.\n      const nodeSort = (a, b) => localeCompare(a.location, b.location)\n\n      const children = [...node.children.values()].sort(nodeSort)\n      for (const child of children) {\n        this.pruneDedupable(child)\n      }\n      const fsChildren = [...node.fsChildren].sort(nodeSort)\n      for (const topNode of fsChildren) {\n        const children = [...topNode.children.values()].sort(nodeSort)\n        for (const child of children) {\n          this.pruneDedupable(child)\n        }\n      }\n    }\n  }\n\n  get conflictOk () {\n    return this.force || (!this.isMine && !this.strictPeerDeps)\n  }\n\n  get isMine () {\n    const { edge } = this.top\n    const { from: node } = edge\n\n    if (node.isWorkspace || node.isProjectRoot) {\n      return true\n    }\n\n    if (!edge.peer) {\n      return false\n    }\n\n    // re-entry case.  check if any non-peer edges come from the project,\n    // or any entryEdges on peer groups are from the root.\n    let hasPeerEdges = false\n    for (const edge of node.edgesIn) {\n      if (edge.peer) {\n        hasPeerEdges = true\n        continue\n      }\n      if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n        return true\n      }\n    }\n    if (hasPeerEdges) {\n      for (const edge of peerEntrySets(node).keys()) {\n        if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  warnPeerConflict (edge, dep) {\n    edge = edge || this.edge\n    dep = dep || this.dep\n    edge.overridden = true\n    const expl = this.explainPeerConflict(edge, dep)\n    log.warn('ERESOLVE', 'overriding peer dependency', expl)\n  }\n\n  failPeerConflict (edge, dep) {\n    edge = edge || this.top.edge\n    dep = dep || this.top.dep\n    const expl = this.explainPeerConflict(edge, dep)\n    throw Object.assign(new Error('could not resolve'), expl)\n  }\n\n  explainPeerConflict (edge, dep) {\n    const { from: node } = edge\n    const curNode = node.resolve(edge.name)\n\n    const expl = {\n      code: 'ERESOLVE',\n      edge: edge.explain(),\n      dep: dep.explain(edge),\n    }\n\n    if (this.parent) {\n      // this is the conflicted peer\n      expl.current = curNode && curNode.explain(edge)\n      expl.peerConflict = this.current && this.current.explain(this.edge)\n    } else {\n      expl.current = curNode && curNode.explain()\n      if (this.canPlaceSelf && this.canPlaceSelf.canPlaceSelf !== CONFLICT) {\n        // failed while checking for a child dep\n        const cps = this.canPlaceSelf\n        for (const peer of cps.conflictChildren) {\n          if (peer.current) {\n            expl.peerConflict = {\n              current: peer.current.explain(),\n              peer: peer.dep.explain(peer.edge),\n            }\n            break\n          }\n        }\n      } else {\n        expl.peerConflict = {\n          current: this.current && this.current.explain(),\n          peer: this.dep.explain(this.edge),\n        }\n      }\n    }\n\n    const {\n      strictPeerDeps,\n      force,\n      isMine,\n    } = this\n    Object.assign(expl, {\n      strictPeerDeps,\n      force,\n      isMine,\n    })\n\n    // XXX decorate more with this.canPlace and this.canPlaceSelf,\n    // this.checks, this.children, walk over conflicted peers, etc.\n    return expl\n  }\n\n  getStartNode () {\n    // if we are a peer, then we MUST be at least as shallow as the\n    // peer dependent\n    const from = this.parent ? this.parent.getStartNode() : this.edge.from\n    return deepestNestingTarget(from, this.name)\n  }\n\n  get top () {\n    return this.parent ? this.parent.top : this\n  }\n\n  isVulnerable (node) {\n    return this.auditReport && this.auditReport.isVulnerable(node)\n  }\n\n  get allChildren () {\n    const set = new Set(this.children)\n    for (const child of set) {\n      for (const grandchild of child.children) {\n        set.add(grandchild)\n      }\n    }\n    return [...set]\n  }\n}\n\nmodule.exports = PlaceDep\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,aAAa,GAAGC,OAAO,CAAC,+BAA+B,CAAC,CAAC,IAAI,CAAC;AACpE,MAAMC,GAAG,GAAGD,OAAO,CAAC,UAAU,CAAC;AAC/B,MAAME,oBAAoB,GAAGF,OAAO,CAAC,6BAA6B,CAAC;AACnE,MAAMG,WAAW,GAAGH,OAAO,CAAC,oBAAoB,CAAC;AACjD,MAAM;EACJI,IAAI;EACJC;AACF,CAAC,GAAGF,WAAW;AACf,MAAMG,KAAK,GAAGN,OAAO,CAAC,YAAY,CAAC;AAEnC,MAAMO,IAAI,GAAGP,OAAO,CAAC,WAAW,CAAC;AACjC,MAAMQ,YAAY,GAAGR,OAAO,CAAC,qBAAqB,CAAC;AACnD,MAAMS,aAAa,GAAGT,OAAO,CAAC,sBAAsB,CAAC;AAErD,MAAMU,QAAQ,CAAC;EACbC,WAAWA,CAAEC,OAAO,EAAE;IACpB,MAAM;MACJC,GAAG;MACHC,IAAI;MACJC,MAAM,GAAG;IACX,CAAC,GAAGH,OAAO;IACX,IAAI,CAACI,IAAI,GAAGF,IAAI,CAACE,IAAI;IACrB,IAAI,CAACH,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACG,QAAQ,GAAG,IAAI;IAEpB,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,MAAM,GAAG,IAAI;;IAElB;IACA,MAAM;MACJC,YAAY;MACZC,KAAK;MACLC,eAAe;MACfC,WAAW;MACXC,WAAW;MACXC,cAAc;MACdC,cAAc;MACdC,cAAc;MACdC;IACF,CAAC,GAAGb,MAAM,IAAIH,OAAO;IACrBiB,MAAM,CAACC,MAAM,CAAC,IAAI,EAAE;MAClBV,YAAY;MACZC,KAAK;MACLC,eAAe;MACfC,WAAW;MACXC,WAAW;MACXC,cAAc;MACdC,cAAc;MACdC,cAAc;MACdC;IACF,CAAC,CAAC;IAEF,IAAI,CAACG,QAAQ,GAAG,EAAE;IAClB,IAAI,CAAChB,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACiB,YAAY,GAAG,IAAI;IAExB,IAAI,CAACC,cAAc,GAAG,IAAIC,GAAG,CAAC,CAAC;IAE/B,IAAI,CAACC,MAAM,GAAG,IAAIC,GAAG,CAAC,CAAC;IAEvB,IAAI,CAACC,KAAK,CAAC,CAAC;EACd;EAEAA,KAAKA,CAAA,EAAI;IACP,MAAM;MACJvB,IAAI;MACJD,GAAG;MACHO,YAAY;MACZQ,WAAW;MACXH,cAAc;MACdH,eAAe;MACfC,WAAW;MACXY;IACF,CAAC,GAAG,IAAI;;IAER;IACA,IAAIrB,IAAI,CAACwB,EAAE,IACP,CAACxB,IAAI,CAACyB,KAAK,IACX,CAACjB,eAAe,IAChB,CAACC,WAAW,CAACiB,QAAQ,CAAC1B,IAAI,CAACE,IAAI,CAAC,IAChC,CAAC,IAAI,CAACyB,YAAY,CAAC3B,IAAI,CAACwB,EAAE,CAAC,EAAE;MAC/B;IACF;;IAEA;IACA;IACA,MAAMI,KAAK,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;IAEjC,IAAI1B,QAAQ,GAAG,IAAI;IACnB,IAAI2B,YAAY,GAAG,IAAI;IACvB,KAAK,MAAM1B,MAAM,IAAIwB,KAAK,CAACG,QAAQ,CAAC,CAAC,EAAE;MACrC;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,MAAMC,UAAU,GAAG5B,MAAM,CAAC6B,QAAQ,CAACC,GAAG,CAAClC,IAAI,CAACE,IAAI,CAAC;MACjD,IAAI,CAACE,MAAM,CAAC+B,KAAK,IAAIH,UAAU,IAAIA,UAAU,CAACI,IAAI,EAAE;QAClD;MACF;MAEA,MAAMC,GAAG,GAAG,IAAIhD,WAAW,CAAC;QAC1BU,GAAG;QACHC,IAAI;QACJ;QACA;QACA;QACA;QACA;QACAC,MAAM,EAAE,IAAI,CAACA,MAAM,IAAI,IAAI,CAACA,MAAM,CAACE,QAAQ;QAC3CC,MAAM;QACNE,YAAY;QACZE,eAAe,EAAE,IAAI,CAACA;MACxB,CAAC,CAAC;MACFa,MAAM,CAACiB,GAAG,CAAClC,MAAM,EAAEiC,GAAG,CAAC;;MAEvB;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAIA,GAAG,CAACP,YAAY,KAAKvC,QAAQ,EAAE;QACjCuC,YAAY,GAAGO,GAAG;MACpB;;MAEA;MACA;MACA,IAAIA,GAAG,CAAClC,QAAQ,KAAKZ,QAAQ,EAAE;QAC7BY,QAAQ,GAAGkC,GAAG;MAChB,CAAC,MAAM;QACL;MACF;;MAEA;MACA;MACA;MACA;MACA,IAAItC,GAAG,CAACwC,MAAM,CAACC,MAAM,EAAE;QACrB;MACF;;MAEA;MACA;MACA,IAAI7B,cAAc,EAAE;QAClB;MACF;;MAEA;MACA;MACA,IAAIG,WAAW,EAAE;QACf,MAAM2B,EAAE,GAAGrC,MAAM,CAACsC,aAAa;QAC/B,IAAID,EAAE,IAAIA,EAAE,CAACE,aAAa,EAAE;UAC1B;QACF;MACF;IACF;IAEA5B,MAAM,CAACC,MAAM,CAAC,IAAI,EAAE;MAClBb,QAAQ;MACR2B;IACF,CAAC,CAAC;IACF,IAAI,CAACc,OAAO,GAAG5C,IAAI,CAACwB,EAAE;;IAEtB;IACA;IACA,IAAI,CAACrB,QAAQ,EAAE;MACb;MACA;MACA,IAAI,CAAC,IAAI,CAAC0C,UAAU,EAAE;QACpB,OAAO,IAAI,CAACC,gBAAgB,CAAC,CAAC;MAChC;;MAEA;MACA;MACA;MACA;MACA,IAAI,CAAChB,YAAY,EAAE;QACjB,IAAI,CAACiB,gBAAgB,CAAC,CAAC;QACvB;MACF;MAEA,IAAI,CAAC5C,QAAQ,GAAG2B,YAAY;IAC9B;;IAEA;IACA;IACA,IAAI,CAACkB,WAAW,CAAC,CAAC;EACpB;EAEAA,WAAWA,CAAA,EAAI;IACb,MAAM;MACJjD,GAAG;MACHI,QAAQ;MACRH;IACF,CAAC,GAAG,IAAI;;IAER;IACA,IAAI,CAACG,QAAQ,EAAE;MACbX,KAAK,CAAC,MAAM;QACV,MAAM,IAAIyD,KAAK,CAAC,+CAA+C,CAAC;MAClE,CAAC,CAAC;MACF;IACF;IAEA,MAAM;MAAE7C;IAAO,CAAC,GAAGD,QAAQ;IAE3BhB,GAAG,CAAC+D,KAAK,CACP,UAAU,EACV9C,MAAM,CAAC+C,QAAQ,IAAI,MAAM,EACzB,GAAGpD,GAAG,CAACG,IAAI,IAAIH,GAAG,CAACqD,OAAO,EAAE,EAC5BjD,QAAQ,CAACkD,WAAW,EACpB,QAAQ,IAAI,CAACrD,IAAI,CAACsD,IAAI,CAACC,OAAO,CAACC,GAAG,IAAI,IAAI,CAACxD,IAAI,CAACsD,IAAI,CAACH,QAAQ,EAAE,EAC/D,SAASnD,IAAI,CAACyD,IAAI,IAAI,GAAG,EAC3B,CAAC;IAED,MAAMC,aAAa,GAAGvD,QAAQ,CAACA,QAAQ,KAAKZ,QAAQ,GAChDY,QAAQ,CAAC2B,YAAY,GACrB3B,QAAQ,CAACA,QAAQ;;IAErB;IACA;IACA,IAAIuD,aAAa,KAAKpE,IAAI,EAAE;MAC1B;MACA,IAAIU,IAAI,CAACoC,IAAI,IAAI,CAACpC,IAAI,CAAC2D,KAAK,EAAE;QAC5B,IAAI,CAACZ,gBAAgB,CAAC,CAAC;MACzB;;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAI,CAACa,cAAc,CAACxD,MAAM,CAAC;MAC3B;IACF;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,KAAK,IAAIyD,CAAC,GAAGzD,MAAM,EAAEyD,CAAC,EAAEA,CAAC,GAAGA,CAAC,CAACnB,aAAa,EAAE;MAC3C,IAAImB,CAAC,CAACC,OAAO,CAAC/D,GAAG,CAAC,IAAI,CAAC8D,CAAC,CAAC1B,KAAK,EAAE;QAC9B,IAAI,CAAC9B,MAAM,GAAG,IAAIZ,IAAI,CAAC;UAAEQ,MAAM,EAAEG,MAAM;UAAEA,MAAM,EAAEyD;QAAE,CAAC,CAAC;QACrD;MACF;IACF;;IAEA;IACA;IACA;;IAEA,MAAME,WAAW,GAAGhE,GAAG,CAACE,MAAM;IAC9B,IAAI,CAACI,MAAM,GAAG,IAAIN,GAAG,CAACF,WAAW,CAAC;MAChCK,IAAI,EAAEH,GAAG,CAACG,IAAI;MACd8D,GAAG,EAAEjE,GAAG,CAACwD,OAAO;MAChBU,QAAQ,EAAElE,GAAG,CAACkE,QAAQ;MACtBC,SAAS,EAAEnE,GAAG,CAACmE,SAAS;MACxBrD,cAAc,EAAE,IAAI,CAACA,cAAc;MACnCY,KAAK,EAAE1B,GAAG,CAACwC,MAAM,CAAC,CAAC,CAAC;MACpB,IAAIxC,GAAG,CAACoE,MAAM,GAAG;QAAE/D,MAAM,EAAEL,GAAG,CAACK,MAAM;QAAEgE,QAAQ,EAAErE,GAAG,CAACqE;MAAS,CAAC,GAAG,CAAC,CAAC;IACtE,CAAC,CAAC;IAEF,IAAI,CAACC,MAAM,GAAGjE,MAAM,CAACa,QAAQ,CAACiB,GAAG,CAAC,IAAI,CAAChC,IAAI,CAAC;IAC5C,IAAI,IAAI,CAACmE,MAAM,EAAE;MACf,IAAI,CAACC,aAAa,CAAC,CAAC;IACtB,CAAC,MAAM;MACL,IAAI,CAACjE,MAAM,CAACJ,MAAM,GAAGG,MAAM;IAC7B;;IAEA;IACA,IAAIJ,IAAI,CAACoC,IAAI,IAAI,CAAC,IAAI,CAAC/B,MAAM,CAACkE,SAAS,CAACvE,IAAI,CAAC,EAAE;MAC7C,IAAI,CAAC+C,gBAAgB,CAAC,CAAC;IACzB;;IAEA;IACA;IACA;IACA;IACA,IAAI/C,IAAI,CAAC2D,KAAK,IAAI3D,IAAI,CAACwB,EAAE,IAAIxB,IAAI,CAACwB,EAAE,KAAK,IAAI,CAACnB,MAAM,EAAE;MACpD,IAAI,CAACuD,cAAc,CAAC5D,IAAI,CAACwB,EAAE,EAAE,KAAK,CAAC;IACrC;;IAEA;IACA;IACA,KAAK,MAAMgD,IAAI,IAAIpE,MAAM,CAACqE,IAAI,CAACC,SAAS,CAACC,KAAK,CAAC,MAAM,EAAE,IAAI,CAACzE,IAAI,CAAC,EAAE;MACjE,IAAIsE,IAAI,CAACI,cAAc,CAACxE,MAAM,CAAC,IAAI,CAACoE,IAAI,CAACrC,KAAK,EAAE;QAC9C,IAAI,CAACyB,cAAc,CAACY,IAAI,EAAE,KAAK,CAAC;QAChC;QACA,IAAIA,IAAI,CAACC,IAAI,KAAKrE,MAAM,CAACqE,IAAI,EAAE;UAC7B,KAAK,MAAMI,GAAG,IAAIL,IAAI,CAACvD,QAAQ,CAAC6D,MAAM,CAAC,CAAC,EAAE;YACxC,IAAI,CAAClB,cAAc,CAACiB,GAAG,EAAE,KAAK,CAAC;UACjC;QACF;MACF;IACF;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA,KAAK,MAAME,QAAQ,IAAI,IAAI,CAAC1E,MAAM,CAAC4B,QAAQ,CAAC6C,MAAM,CAAC,CAAC,EAAE;MACpD,IAAIC,QAAQ,CAACpB,KAAK,IAAI,CAACoB,QAAQ,CAAC3C,IAAI,IAAI2C,QAAQ,CAACC,UAAU,EAAE;QAC3D;MACF;MAEA,MAAM5C,IAAI,GAAG2B,WAAW,CAAC9C,QAAQ,CAACiB,GAAG,CAAC6C,QAAQ,CAAC7E,IAAI,CAAC;;MAEpD;MACA;MACA;MACA;MACA,IAAI,CAACkC,IAAI,EAAE;QACT;MACF;;MAEA;MACA,IAAI,CAACA,IAAI,CAACmC,SAAS,CAACQ,QAAQ,CAAC,EAAE;QAC7B;MACF;MAEA,IAAI,CAAC9D,QAAQ,CAACgE,IAAI,CAAC,IAAIrF,QAAQ,CAAC;QAC9BK,MAAM,EAAE,IAAI;QACZF,GAAG,EAAEqC,IAAI;QACToC,IAAI,EAAE,IAAI,CAACnE,MAAM;QACjBL,IAAI,EAAE+E;MACR,CAAC,CAAC,CAAC;IACL;EACF;EAEAT,aAAaA,CAAA,EAAI;IACf,MAAMlE,MAAM,GAAG,IAAI,CAACiE,MAAM,CAACpE,MAAM;;IAEjC;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA,MAAMiF,OAAO,GAAG,EAAE;IAClB,KAAK,MAAM,CAAChF,IAAI,EAAEF,IAAI,CAAC,IAAI,IAAI,CAACqE,MAAM,CAACpC,QAAQ,CAACkD,OAAO,CAAC,CAAC,EAAE;MACzD,IAAI,CAAC,IAAI,CAAC9E,MAAM,CAAC4B,QAAQ,CAACmD,GAAG,CAAClF,IAAI,CAAC,IAAIF,IAAI,CAACwB,EAAE,EAAE;QAC9C0D,OAAO,CAACD,IAAI,CAAC,GAAGvF,YAAY,CAAC,CAACM,IAAI,CAACwB,EAAE,CAAC,EAAE6D,CAAC,IAAIA,CAAC,CAAC7D,EAAE,KAAKxB,IAAI,CAACwB,EAAE,CAAC,CAAC;MACjE;IACF;;IAEA;IACA;IACA;IACA;IACA,MAAM8D,aAAa,GAAG,EAAE;IACxB,KAAK,MAAMtF,IAAI,IAAI,IAAI,CAACqE,MAAM,CAACkB,OAAO,EAAE;MACtC,IAAI,IAAI,CAAClF,MAAM,CAACkE,SAAS,CAACvE,IAAI,CAAC,IAC3B,CAACA,IAAI,CAACoC,IAAI,IACVpC,IAAI,CAACsD,IAAI,CAACrD,MAAM,KAAKG,MAAM,IAC3BJ,IAAI,CAACgF,UAAU,EAAE;QACnB;QACA;QACA;QACA;MACF;MACA,KAAK,MAAMQ,SAAS,IAAI7F,aAAa,CAACK,IAAI,CAACsD,IAAI,CAAC,CAACmC,IAAI,CAAC,CAAC,EAAE;QACvD;QACA;QACA;QACA;QACA,MAAMC,SAAS,GAAGF,SAAS,CAAChE,EAAE;QAC9B,MAAMmE,aAAa,GAAGvG,oBAAoB,CAACsG,SAAS,CAAC;QACrD,IAAIC,aAAa,KAAKvF,MAAM,IAAI,CAACoF,SAAS,CAAClC,IAAI,CAACsC,MAAM,EAAE;UACtDN,aAAa,CAACL,IAAI,CAAC,GAAGvF,YAAY,CAAC,CAACgG,SAAS,CAAC,EAAEL,CAAC,IAAI;YACnD,OAAOA,CAAC,CAAC7D,EAAE,KAAKkE,SAAS,IAAI,CAACL,CAAC,CAACL,UAAU;UAC5C,CAAC,CAAC,CAAC;QACL,CAAC,MAAM;UACL,IAAI,CAACjC,gBAAgB,CAAC/C,IAAI,EAAE,IAAI,CAACD,GAAG,CAAC;QACvC;MACF;IACF;IAEA,IAAI,CAACM,MAAM,CAACwF,OAAO,CAAC,IAAI,CAACxB,MAAM,CAAC;IAChC,IAAI,CAACyB,mBAAmB,CAAC,IAAI,CAACzF,MAAM,EAAE6E,OAAO,CAAC;IAC9C,KAAK,MAAMnF,GAAG,IAAIuF,aAAa,EAAE;MAC/B,KAAK,MAAMtF,IAAI,IAAID,GAAG,CAACwF,OAAO,EAAE;QAC9B,IAAI,CAACpE,cAAc,CAAC4E,GAAG,CAAC/F,IAAI,CAACsD,IAAI,CAAC;MACpC;MACAvD,GAAG,CAAC0E,IAAI,GAAG,IAAI;IACjB;EACF;EAEAqB,mBAAmBA,CAAEtB,IAAI,EAAEU,OAAO,EAAE;IAClC;IACA;IACA,MAAMc,WAAW,GAAG,IAAI5E,GAAG,CAAC,CAAC,GAAGoD,IAAI,CAACvC,QAAQ,CAAC6C,MAAM,CAAC,CAAC,CAAC,CACpDmB,MAAM,CAACZ,CAAC,IAAIA,CAAC,CAAC7D,EAAE,IAAI,CAAC6D,CAAC,CAAC1B,KAAK,CAAC,CAACuC,GAAG,CAACb,CAAC,IAAIA,CAAC,CAAC7D,EAAE,CAAC,CAAC;IAChD,KAAK,MAAMzB,GAAG,IAAImF,OAAO,EAAE;MACzB,MAAM5C,GAAG,GAAG5C,YAAY,CAAC,CAACK,GAAG,CAAC,EAAEsF,CAAC,IAAIA,CAAC,CAAC7D,EAAE,KAAKzB,GAAG,IAAIsF,CAAC,CAAC1B,KAAK,CAAC;MAC7D,KAAK,MAAM5D,GAAG,IAAIuC,GAAG,EAAE;QACrB0D,WAAW,CAACD,GAAG,CAAChG,GAAG,CAAC;MACtB;IACF;;IAEA;IACA;IACA;IACA,MAAMoG,IAAI,GAAGzG,YAAY,CAACsG,WAAW,EAAEhG,IAAI,IACzCA,IAAI,CAACsD,IAAI,KAAKkB,IAAI,IAAIxE,IAAI,CAACwB,EAAE,KAAKgD,IAAI,IAAIxE,IAAI,CAAC2D,KAAK,CAAC;;IAEvD;IACA,KAAK,MAAM5D,GAAG,IAAIoG,IAAI,EAAE;MACtBpG,GAAG,CAAC0E,IAAI,GAAG,IAAI;IACjB;EACF;;EAEA;EACA;EACA;EACA;EACAb,cAAcA,CAAEY,IAAI,EAAE4B,OAAO,GAAG,IAAI,EAAE;IACpC,IAAI5B,IAAI,CAAC6B,SAAS,CAAC,IAAI,CAAC/F,YAAY,CAAC,EAAE;MACrC;MACA;MACA;MACA,MAAM6F,IAAI,GAAGzG,YAAY,CAAC,CAAC8E,IAAI,CAAC,EAAEa,CAAC,IAAIA,CAAC,CAAC7D,EAAE,KAAKgD,IAAI,IAAIa,CAAC,CAAC1B,KAAK,CAAC;MAChE,KAAK,MAAMa,IAAI,IAAI2B,IAAI,EAAE;QACvB3B,IAAI,CAACC,IAAI,GAAG,IAAI;MAClB;MACA;IACF;IACA,IAAI2B,OAAO,EAAE;MACX;MACA;MACA;MACA,MAAME,QAAQ,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAKvH,aAAa,CAACsH,CAAC,CAACpD,QAAQ,EAAEqD,CAAC,CAACrD,QAAQ,CAAC;MAEhE,MAAMlC,QAAQ,GAAG,CAAC,GAAGuD,IAAI,CAACvD,QAAQ,CAAC6D,MAAM,CAAC,CAAC,CAAC,CAAC2B,IAAI,CAACH,QAAQ,CAAC;MAC3D,KAAK,MAAMI,KAAK,IAAIzF,QAAQ,EAAE;QAC5B,IAAI,CAAC2C,cAAc,CAAC8C,KAAK,CAAC;MAC5B;MACA,MAAMC,UAAU,GAAG,CAAC,GAAGnC,IAAI,CAACmC,UAAU,CAAC,CAACF,IAAI,CAACH,QAAQ,CAAC;MACtD,KAAK,MAAMM,OAAO,IAAID,UAAU,EAAE;QAChC,MAAM1F,QAAQ,GAAG,CAAC,GAAG2F,OAAO,CAAC3F,QAAQ,CAAC6D,MAAM,CAAC,CAAC,CAAC,CAAC2B,IAAI,CAACH,QAAQ,CAAC;QAC9D,KAAK,MAAMI,KAAK,IAAIzF,QAAQ,EAAE;UAC5B,IAAI,CAAC2C,cAAc,CAAC8C,KAAK,CAAC;QAC5B;MACF;IACF;EACF;EAEA,IAAI7D,UAAUA,CAAA,EAAI;IAChB,OAAO,IAAI,CAACtC,KAAK,IAAK,CAAC,IAAI,CAACsG,MAAM,IAAI,CAAC,IAAI,CAACjG,cAAe;EAC7D;EAEA,IAAIiG,MAAMA,CAAA,EAAI;IACZ,MAAM;MAAE7G;IAAK,CAAC,GAAG,IAAI,CAAC8G,GAAG;IACzB,MAAM;MAAExD,IAAI,EAAEkB;IAAK,CAAC,GAAGxE,IAAI;IAE3B,IAAIwE,IAAI,CAACuC,WAAW,IAAIvC,IAAI,CAAC7B,aAAa,EAAE;MAC1C,OAAO,IAAI;IACb;IAEA,IAAI,CAAC3C,IAAI,CAACoC,IAAI,EAAE;MACd,OAAO,KAAK;IACd;;IAEA;IACA;IACA,IAAI4E,YAAY,GAAG,KAAK;IACxB,KAAK,MAAMhH,IAAI,IAAIwE,IAAI,CAACe,OAAO,EAAE;MAC/B,IAAIvF,IAAI,CAACoC,IAAI,EAAE;QACb4E,YAAY,GAAG,IAAI;QACnB;MACF;MACA,IAAIhH,IAAI,CAACsD,IAAI,CAACyD,WAAW,IAAI/G,IAAI,CAACsD,IAAI,CAACX,aAAa,EAAE;QACpD,OAAO,IAAI;MACb;IACF;IACA,IAAIqE,YAAY,EAAE;MAChB,KAAK,MAAMhH,IAAI,IAAIL,aAAa,CAAC6E,IAAI,CAAC,CAACiB,IAAI,CAAC,CAAC,EAAE;QAC7C,IAAIzF,IAAI,CAACsD,IAAI,CAACyD,WAAW,IAAI/G,IAAI,CAACsD,IAAI,CAACX,aAAa,EAAE;UACpD,OAAO,IAAI;QACb;MACF;IACF;IAEA,OAAO,KAAK;EACd;EAEAI,gBAAgBA,CAAE/C,IAAI,EAAED,GAAG,EAAE;IAC3BC,IAAI,GAAGA,IAAI,IAAI,IAAI,CAACA,IAAI;IACxBD,GAAG,GAAGA,GAAG,IAAI,IAAI,CAACA,GAAG;IACrBC,IAAI,CAACgF,UAAU,GAAG,IAAI;IACtB,MAAMiC,IAAI,GAAG,IAAI,CAACC,mBAAmB,CAAClH,IAAI,EAAED,GAAG,CAAC;IAChDZ,GAAG,CAACgI,IAAI,CAAC,UAAU,EAAE,4BAA4B,EAAEF,IAAI,CAAC;EAC1D;EAEAnE,gBAAgBA,CAAE9C,IAAI,EAAED,GAAG,EAAE;IAC3BC,IAAI,GAAGA,IAAI,IAAI,IAAI,CAAC8G,GAAG,CAAC9G,IAAI;IAC5BD,GAAG,GAAGA,GAAG,IAAI,IAAI,CAAC+G,GAAG,CAAC/G,GAAG;IACzB,MAAMkH,IAAI,GAAG,IAAI,CAACC,mBAAmB,CAAClH,IAAI,EAAED,GAAG,CAAC;IAChD,MAAMgB,MAAM,CAACC,MAAM,CAAC,IAAIiC,KAAK,CAAC,mBAAmB,CAAC,EAAEgE,IAAI,CAAC;EAC3D;EAEAC,mBAAmBA,CAAElH,IAAI,EAAED,GAAG,EAAE;IAC9B,MAAM;MAAEuD,IAAI,EAAEkB;IAAK,CAAC,GAAGxE,IAAI;IAC3B,MAAMoH,OAAO,GAAG5C,IAAI,CAAC6C,OAAO,CAACrH,IAAI,CAACE,IAAI,CAAC;IAEvC,MAAM+G,IAAI,GAAG;MACXK,IAAI,EAAE,UAAU;MAChBtH,IAAI,EAAEA,IAAI,CAACuH,OAAO,CAAC,CAAC;MACpBxH,GAAG,EAAEA,GAAG,CAACwH,OAAO,CAACvH,IAAI;IACvB,CAAC;IAED,IAAI,IAAI,CAACC,MAAM,EAAE;MACf;MACAgH,IAAI,CAACrE,OAAO,GAAGwE,OAAO,IAAIA,OAAO,CAACG,OAAO,CAACvH,IAAI,CAAC;MAC/CiH,IAAI,CAAC/F,YAAY,GAAG,IAAI,CAAC0B,OAAO,IAAI,IAAI,CAACA,OAAO,CAAC2E,OAAO,CAAC,IAAI,CAACvH,IAAI,CAAC;IACrE,CAAC,MAAM;MACLiH,IAAI,CAACrE,OAAO,GAAGwE,OAAO,IAAIA,OAAO,CAACG,OAAO,CAAC,CAAC;MAC3C,IAAI,IAAI,CAACzF,YAAY,IAAI,IAAI,CAACA,YAAY,CAACA,YAAY,KAAKvC,QAAQ,EAAE;QACpE;QACA,MAAMiI,GAAG,GAAG,IAAI,CAAC1F,YAAY;QAC7B,KAAK,MAAMM,IAAI,IAAIoF,GAAG,CAACC,gBAAgB,EAAE;UACvC,IAAIrF,IAAI,CAACQ,OAAO,EAAE;YAChBqE,IAAI,CAAC/F,YAAY,GAAG;cAClB0B,OAAO,EAAER,IAAI,CAACQ,OAAO,CAAC2E,OAAO,CAAC,CAAC;cAC/BnF,IAAI,EAAEA,IAAI,CAACrC,GAAG,CAACwH,OAAO,CAACnF,IAAI,CAACpC,IAAI;YAClC,CAAC;YACD;UACF;QACF;MACF,CAAC,MAAM;QACLiH,IAAI,CAAC/F,YAAY,GAAG;UAClB0B,OAAO,EAAE,IAAI,CAACA,OAAO,IAAI,IAAI,CAACA,OAAO,CAAC2E,OAAO,CAAC,CAAC;UAC/CnF,IAAI,EAAE,IAAI,CAACrC,GAAG,CAACwH,OAAO,CAAC,IAAI,CAACvH,IAAI;QAClC,CAAC;MACH;IACF;IAEA,MAAM;MACJY,cAAc;MACdL,KAAK;MACLsG;IACF,CAAC,GAAG,IAAI;IACR9F,MAAM,CAACC,MAAM,CAACiG,IAAI,EAAE;MAClBrG,cAAc;MACdL,KAAK;MACLsG;IACF,CAAC,CAAC;;IAEF;IACA;IACA,OAAOI,IAAI;EACb;EAEApF,YAAYA,CAAA,EAAI;IACd;IACA;IACA,MAAMyB,IAAI,GAAG,IAAI,CAACrD,MAAM,GAAG,IAAI,CAACA,MAAM,CAAC4B,YAAY,CAAC,CAAC,GAAG,IAAI,CAAC7B,IAAI,CAACsD,IAAI;IACtE,OAAOlE,oBAAoB,CAACkE,IAAI,EAAE,IAAI,CAACpD,IAAI,CAAC;EAC9C;EAEA,IAAI4G,GAAGA,CAAA,EAAI;IACT,OAAO,IAAI,CAAC7G,MAAM,GAAG,IAAI,CAACA,MAAM,CAAC6G,GAAG,GAAG,IAAI;EAC7C;EAEAnF,YAAYA,CAAE6C,IAAI,EAAE;IAClB,OAAO,IAAI,CAAC9D,WAAW,IAAI,IAAI,CAACA,WAAW,CAACiB,YAAY,CAAC6C,IAAI,CAAC;EAChE;EAEA,IAAIkD,WAAWA,CAAA,EAAI;IACjB,MAAMpF,GAAG,GAAG,IAAIlB,GAAG,CAAC,IAAI,CAACH,QAAQ,CAAC;IAClC,KAAK,MAAMyF,KAAK,IAAIpE,GAAG,EAAE;MACvB,KAAK,MAAMqF,UAAU,IAAIjB,KAAK,CAACzF,QAAQ,EAAE;QACvCqB,GAAG,CAACyD,GAAG,CAAC4B,UAAU,CAAC;MACrB;IACF;IACA,OAAO,CAAC,GAAGrF,GAAG,CAAC;EACjB;AACF;AAEAsF,MAAM,CAACC,OAAO,GAAGjI,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}