{"ast":null,"code":"// Arborist.rebuild({path = this.path}) will do all the binlinks and\n// bundle building needed.  Called by reify, and by `npm rebuild`.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\nconst {\n  depth: dfwalk\n} = require('treeverse');\nconst promiseAllRejectLate = require('promise-all-reject-late');\nconst rpj = require('read-package-json-fast');\nconst binLinks = require('bin-links');\nconst runScript = require('@npmcli/run-script');\nconst promiseCallLimit = require('promise-call-limit');\nconst {\n  resolve\n} = require('path');\nconst {\n  isNodeGypPackage,\n  defaultGypInstallScript\n} = require('@npmcli/node-gyp');\nconst boolEnv = b => b ? '1' : '';\nconst sortNodes = (a, b) => a.depth - b.depth || localeCompare(a.path, b.path);\nconst _workspaces = Symbol.for('workspaces');\nconst _build = Symbol('build');\nconst _resetQueues = Symbol('resetQueues');\nconst _rebuildBundle = Symbol('rebuildBundle');\nconst _ignoreScripts = Symbol('ignoreScripts');\nconst _binLinks = Symbol('binLinks');\nconst _oldMeta = Symbol('oldMeta');\nconst _createBinLinks = Symbol('createBinLinks');\nconst _doHandleOptionalFailure = Symbol('doHandleOptionalFailure');\nconst _linkAllBins = Symbol('linkAllBins');\nconst _runScripts = Symbol('runScripts');\nconst _buildQueues = Symbol('buildQueues');\nconst _addToBuildSet = Symbol('addToBuildSet');\nconst _checkBins = Symbol.for('checkBins');\nconst _queues = Symbol('queues');\nconst _scriptShell = Symbol('scriptShell');\nconst _force = Symbol.for('force');\n\n// defined by reify mixin\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure');\nconst _trashList = Symbol.for('trashList');\nmodule.exports = cls => class Builder extends cls {\n  constructor(options) {\n    super(options);\n    const {\n      ignoreScripts = false,\n      scriptShell,\n      binLinks = true,\n      rebuildBundle = true\n    } = options;\n    this.scriptsRun = new Set();\n    this[_binLinks] = binLinks;\n    this[_ignoreScripts] = !!ignoreScripts;\n    this[_scriptShell] = scriptShell;\n    this[_rebuildBundle] = !!rebuildBundle;\n    this[_resetQueues]();\n    this[_oldMeta] = null;\n  }\n  async rebuild({\n    nodes,\n    handleOptionalFailure = false\n  } = {}) {\n    // nothing to do if we're not building anything!\n    if (this[_ignoreScripts] && !this[_binLinks]) {\n      return;\n    }\n\n    // when building for the first time, as part of reify, we ignore\n    // failures in optional nodes, and just delete them.  however, when\n    // running JUST a rebuild, we treat optional failures as real fails\n    this[_doHandleOptionalFailure] = handleOptionalFailure;\n\n    // if we don't have a set of nodes, then just rebuild\n    // the actual tree on disk.\n    if (!nodes) {\n      const tree = await this.loadActual();\n      if (this[_workspaces] && this[_workspaces].length) {\n        const filterSet = this.workspaceDependencySet(tree, this[_workspaces]);\n        nodes = tree.inventory.filter(node => filterSet.has(node));\n      } else {\n        nodes = tree.inventory.values();\n      }\n    }\n\n    // separates links nodes so that it can run\n    // prepare scripts and link bins in the expected order\n    process.emit('time', 'build');\n    const depNodes = new Set();\n    const linkNodes = new Set();\n    for (const node of nodes) {\n      // we skip the target nodes to that workspace in order to make sure\n      // we only run lifecycle scripts / place bin links once per workspace\n      if (node.isLink) {\n        linkNodes.add(node);\n      } else {\n        depNodes.add(node);\n      }\n    }\n    await this[_build](depNodes, {});\n    if (linkNodes.size) {\n      this[_resetQueues]();\n      await this[_build](linkNodes, {\n        type: 'links'\n      });\n    }\n    process.emit('timeEnd', 'build');\n  }\n  [_resetQueues]() {\n    this[_queues] = {\n      preinstall: [],\n      install: [],\n      postinstall: [],\n      prepare: [],\n      bin: []\n    };\n  }\n  async [_build](nodes, {\n    type = 'deps'\n  }) {\n    process.emit('time', `build:${type}`);\n    await this[_buildQueues](nodes);\n    if (!this[_ignoreScripts]) {\n      await this[_runScripts]('preinstall');\n    }\n    if (this[_binLinks] && type !== 'links') {\n      await this[_linkAllBins]();\n    }\n\n    // links should also run prepare scripts and only link bins after that\n    if (type === 'links') {\n      await this[_runScripts]('prepare');\n      if (this[_binLinks]) {\n        await this[_linkAllBins]();\n      }\n    }\n    if (!this[_ignoreScripts]) {\n      await this[_runScripts]('install');\n      await this[_runScripts]('postinstall');\n    }\n    process.emit('timeEnd', `build:${type}`);\n  }\n  async [_buildQueues](nodes) {\n    process.emit('time', 'build:queue');\n    const set = new Set();\n    const promises = [];\n    for (const node of nodes) {\n      promises.push(this[_addToBuildSet](node, set));\n\n      // if it has bundle deps, add those too, if rebuildBundle\n      if (this[_rebuildBundle] !== false) {\n        const bd = node.package.bundleDependencies;\n        if (bd && bd.length) {\n          dfwalk({\n            tree: node,\n            leave: node => promises.push(this[_addToBuildSet](node, set)),\n            getChildren: node => [...node.children.values()],\n            filter: node => node.inBundle\n          });\n        }\n      }\n    }\n    await promiseAllRejectLate(promises);\n\n    // now sort into the queues for the 4 things we have to do\n    // run in the same predictable order that buildIdealTree uses\n    // there's no particular reason for doing it in this order rather\n    // than another, but sorting *somehow* makes it consistent.\n    const queue = [...set].sort(sortNodes);\n    for (const node of queue) {\n      const {\n        package: {\n          bin,\n          scripts = {}\n        }\n      } = node.target;\n      const {\n        preinstall,\n        install,\n        postinstall,\n        prepare\n      } = scripts;\n      const tests = {\n        bin,\n        preinstall,\n        install,\n        postinstall,\n        prepare\n      };\n      for (const [key, has] of Object.entries(tests)) {\n        if (has) {\n          this[_queues][key].push(node);\n        }\n      }\n    }\n    process.emit('timeEnd', 'build:queue');\n  }\n  async [_checkBins](node) {\n    // if the node is a global top, and we're not in force mode, then\n    // any existing bins need to either be missing, or a symlink into\n    // the node path.  Otherwise a package can have a preinstall script\n    // that unlinks something, to allow them to silently overwrite system\n    // binaries, which is unsafe and insecure.\n    if (!node.globalTop || this[_force]) {\n      return;\n    }\n    const {\n      path,\n      package: pkg\n    } = node;\n    await binLinks.checkBins({\n      pkg,\n      path,\n      top: true,\n      global: true\n    });\n  }\n  async [_addToBuildSet](node, set, refreshed = false) {\n    if (set.has(node)) {\n      return;\n    }\n    if (this[_oldMeta] === null) {\n      const {\n        root: {\n          meta\n        }\n      } = node;\n      this[_oldMeta] = meta && meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2);\n    }\n    const {\n      package: pkg,\n      hasInstallScript\n    } = node.target;\n    const {\n      gypfile,\n      bin,\n      scripts = {}\n    } = pkg;\n    const {\n      preinstall,\n      install,\n      postinstall,\n      prepare\n    } = scripts;\n    const anyScript = preinstall || install || postinstall || prepare;\n    if (!refreshed && !anyScript && (hasInstallScript || this[_oldMeta])) {\n      // we either have an old metadata (and thus might have scripts)\n      // or we have an indication that there's install scripts (but\n      // don't yet know what they are) so we have to load the package.json\n      // from disk to see what the deal is.  Failure here just means\n      // no scripts to add, probably borked package.json.\n      // add to the set then remove while we're reading the pj, so we\n      // don't accidentally hit it multiple times.\n      set.add(node);\n      const pkg = await rpj(node.path + '/package.json').catch(() => ({}));\n      set.delete(node);\n      const {\n        scripts = {}\n      } = pkg;\n      node.package.scripts = scripts;\n      return this[_addToBuildSet](node, set, true);\n    }\n\n    // Rebuild node-gyp dependencies lacking an install or preinstall script\n    // note that 'scripts' might be missing entirely, and the package may\n    // set gypfile:false to avoid this automatic detection.\n    const isGyp = gypfile !== false && !install && !preinstall && (await isNodeGypPackage(node.path));\n    if (bin || preinstall || install || postinstall || prepare || isGyp) {\n      if (bin) {\n        await this[_checkBins](node);\n      }\n      if (isGyp) {\n        scripts.install = defaultGypInstallScript;\n        node.package.scripts = scripts;\n      }\n      set.add(node);\n    }\n  }\n  async [_runScripts](event) {\n    const queue = this[_queues][event];\n    if (!queue.length) {\n      return;\n    }\n    process.emit('time', `build:run:${event}`);\n    const stdio = this.options.foregroundScripts ? 'inherit' : 'pipe';\n    const limit = this.options.foregroundScripts ? 1 : undefined;\n    await promiseCallLimit(queue.map(node => async () => {\n      const {\n        path,\n        integrity,\n        resolved,\n        optional,\n        peer,\n        dev,\n        devOptional,\n        package: pkg,\n        location\n      } = node.target;\n\n      // skip any that we know we'll be deleting\n      if (this[_trashList].has(path)) {\n        return;\n      }\n      const timer = `build:run:${event}:${location}`;\n      process.emit('time', timer);\n      this.log.info('run', pkg._id, event, location, pkg.scripts[event]);\n      const env = {\n        npm_package_resolved: resolved,\n        npm_package_integrity: integrity,\n        npm_package_json: resolve(path, 'package.json'),\n        npm_package_optional: boolEnv(optional),\n        npm_package_dev: boolEnv(dev),\n        npm_package_peer: boolEnv(peer),\n        npm_package_dev_optional: boolEnv(devOptional && !dev && !optional)\n      };\n      const runOpts = {\n        event,\n        path,\n        pkg,\n        stdioString: true,\n        stdio,\n        env,\n        scriptShell: this[_scriptShell]\n      };\n      const p = runScript(runOpts).catch(er => {\n        const {\n          code,\n          signal\n        } = er;\n        this.log.info('run', pkg._id, event, {\n          code,\n          signal\n        });\n        throw er;\n      }).then(({\n        args,\n        code,\n        signal,\n        stdout,\n        stderr\n      }) => {\n        this.scriptsRun.add({\n          pkg,\n          path,\n          event,\n          cmd: args && args[args.length - 1],\n          env,\n          code,\n          signal,\n          stdout,\n          stderr\n        });\n        this.log.info('run', pkg._id, event, {\n          code,\n          signal\n        });\n      });\n      await (this[_doHandleOptionalFailure] ? this[_handleOptionalFailure](node, p) : p);\n      process.emit('timeEnd', timer);\n    }), limit);\n    process.emit('timeEnd', `build:run:${event}`);\n  }\n  async [_linkAllBins]() {\n    const queue = this[_queues].bin;\n    if (!queue.length) {\n      return;\n    }\n    process.emit('time', 'build:link');\n    const promises = [];\n    // sort the queue by node path, so that the module-local collision\n    // detector in bin-links will always resolve the same way.\n    for (const node of queue.sort(sortNodes)) {\n      promises.push(this[_createBinLinks](node));\n    }\n    await promiseAllRejectLate(promises);\n    process.emit('timeEnd', 'build:link');\n  }\n  async [_createBinLinks](node) {\n    if (this[_trashList].has(node.path)) {\n      return;\n    }\n    process.emit('time', `build:link:${node.location}`);\n    const p = binLinks({\n      pkg: node.package,\n      path: node.path,\n      top: !!(node.isTop || node.globalTop),\n      force: this[_force],\n      global: !!node.globalTop\n    });\n    await (this[_doHandleOptionalFailure] ? this[_handleOptionalFailure](node, p) : p);\n    process.emit('timeEnd', `build:link:${node.location}`);\n  }\n};","map":{"version":3,"names":["localeCompare","require","depth","dfwalk","promiseAllRejectLate","rpj","binLinks","runScript","promiseCallLimit","resolve","isNodeGypPackage","defaultGypInstallScript","boolEnv","b","sortNodes","a","path","_workspaces","Symbol","for","_build","_resetQueues","_rebuildBundle","_ignoreScripts","_binLinks","_oldMeta","_createBinLinks","_doHandleOptionalFailure","_linkAllBins","_runScripts","_buildQueues","_addToBuildSet","_checkBins","_queues","_scriptShell","_force","_handleOptionalFailure","_trashList","module","exports","cls","Builder","constructor","options","ignoreScripts","scriptShell","rebuildBundle","scriptsRun","Set","rebuild","nodes","handleOptionalFailure","tree","loadActual","length","filterSet","workspaceDependencySet","inventory","filter","node","has","values","process","emit","depNodes","linkNodes","isLink","add","size","type","preinstall","install","postinstall","prepare","bin","set","promises","push","bd","package","bundleDependencies","leave","getChildren","children","inBundle","queue","sort","scripts","target","tests","key","Object","entries","globalTop","pkg","checkBins","top","global","refreshed","root","meta","loadedFromDisk","originalLockfileVersion","hasInstallScript","gypfile","anyScript","catch","delete","isGyp","event","stdio","foregroundScripts","limit","undefined","map","integrity","resolved","optional","peer","dev","devOptional","location","timer","log","info","_id","env","npm_package_resolved","npm_package_integrity","npm_package_json","npm_package_optional","npm_package_dev","npm_package_peer","npm_package_dev_optional","runOpts","stdioString","p","er","code","signal","then","args","stdout","stderr","cmd","isTop","force"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/rebuild.js"],"sourcesContent":["// Arborist.rebuild({path = this.path}) will do all the binlinks and\n// bundle building needed.  Called by reify, and by `npm rebuild`.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst {depth: dfwalk} = require('treeverse')\nconst promiseAllRejectLate = require('promise-all-reject-late')\nconst rpj = require('read-package-json-fast')\nconst binLinks = require('bin-links')\nconst runScript = require('@npmcli/run-script')\nconst promiseCallLimit = require('promise-call-limit')\nconst {resolve} = require('path')\nconst {\n  isNodeGypPackage,\n  defaultGypInstallScript,\n} = require('@npmcli/node-gyp')\n\nconst boolEnv = b => b ? '1' : ''\nconst sortNodes = (a, b) =>\n  (a.depth - b.depth) || localeCompare(a.path, b.path)\n\nconst _workspaces = Symbol.for('workspaces')\nconst _build = Symbol('build')\nconst _resetQueues = Symbol('resetQueues')\nconst _rebuildBundle = Symbol('rebuildBundle')\nconst _ignoreScripts = Symbol('ignoreScripts')\nconst _binLinks = Symbol('binLinks')\nconst _oldMeta = Symbol('oldMeta')\nconst _createBinLinks = Symbol('createBinLinks')\nconst _doHandleOptionalFailure = Symbol('doHandleOptionalFailure')\nconst _linkAllBins = Symbol('linkAllBins')\nconst _runScripts = Symbol('runScripts')\nconst _buildQueues = Symbol('buildQueues')\nconst _addToBuildSet = Symbol('addToBuildSet')\nconst _checkBins = Symbol.for('checkBins')\nconst _queues = Symbol('queues')\nconst _scriptShell = Symbol('scriptShell')\n\nconst _force = Symbol.for('force')\n\n// defined by reify mixin\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure')\nconst _trashList = Symbol.for('trashList')\n\nmodule.exports = cls => class Builder extends cls {\n  constructor (options) {\n    super(options)\n\n    const {\n      ignoreScripts = false,\n      scriptShell,\n      binLinks = true,\n      rebuildBundle = true,\n    } = options\n\n    this.scriptsRun = new Set()\n    this[_binLinks] = binLinks\n    this[_ignoreScripts] = !!ignoreScripts\n    this[_scriptShell] = scriptShell\n    this[_rebuildBundle] = !!rebuildBundle\n    this[_resetQueues]()\n    this[_oldMeta] = null\n  }\n\n  async rebuild ({ nodes, handleOptionalFailure = false } = {}) {\n    // nothing to do if we're not building anything!\n    if (this[_ignoreScripts] && !this[_binLinks]) {\n      return\n    }\n\n    // when building for the first time, as part of reify, we ignore\n    // failures in optional nodes, and just delete them.  however, when\n    // running JUST a rebuild, we treat optional failures as real fails\n    this[_doHandleOptionalFailure] = handleOptionalFailure\n\n    // if we don't have a set of nodes, then just rebuild\n    // the actual tree on disk.\n    if (!nodes) {\n      const tree = await this.loadActual()\n      if (this[_workspaces] && this[_workspaces].length) {\n        const filterSet = this.workspaceDependencySet(tree, this[_workspaces])\n        nodes = tree.inventory.filter(node => filterSet.has(node))\n      } else {\n        nodes = tree.inventory.values()\n      }\n    }\n\n    // separates links nodes so that it can run\n    // prepare scripts and link bins in the expected order\n    process.emit('time', 'build')\n    const depNodes = new Set()\n    const linkNodes = new Set()\n    for (const node of nodes) {\n      // we skip the target nodes to that workspace in order to make sure\n      // we only run lifecycle scripts / place bin links once per workspace\n      if (node.isLink) {\n        linkNodes.add(node)\n      } else {\n        depNodes.add(node)\n      }\n    }\n\n    await this[_build](depNodes, {})\n\n    if (linkNodes.size) {\n      this[_resetQueues]()\n      await this[_build](linkNodes, { type: 'links' })\n    }\n\n    process.emit('timeEnd', 'build')\n  }\n\n  [_resetQueues] () {\n    this[_queues] = {\n      preinstall: [],\n      install: [],\n      postinstall: [],\n      prepare: [],\n      bin: [],\n    }\n  }\n\n  async [_build] (nodes, { type = 'deps' }) {\n    process.emit('time', `build:${type}`)\n\n    await this[_buildQueues](nodes)\n    if (!this[_ignoreScripts]) {\n      await this[_runScripts]('preinstall')\n    }\n    if (this[_binLinks] && type !== 'links') {\n      await this[_linkAllBins]()\n    }\n\n    // links should also run prepare scripts and only link bins after that\n    if (type === 'links') {\n      await this[_runScripts]('prepare')\n\n      if (this[_binLinks]) {\n        await this[_linkAllBins]()\n      }\n    }\n\n    if (!this[_ignoreScripts]) {\n      await this[_runScripts]('install')\n      await this[_runScripts]('postinstall')\n    }\n\n    process.emit('timeEnd', `build:${type}`)\n  }\n\n  async [_buildQueues] (nodes) {\n    process.emit('time', 'build:queue')\n    const set = new Set()\n\n    const promises = []\n    for (const node of nodes) {\n      promises.push(this[_addToBuildSet](node, set))\n\n      // if it has bundle deps, add those too, if rebuildBundle\n      if (this[_rebuildBundle] !== false) {\n        const bd = node.package.bundleDependencies\n        if (bd && bd.length) {\n          dfwalk({\n            tree: node,\n            leave: node => promises.push(this[_addToBuildSet](node, set)),\n            getChildren: node => [...node.children.values()],\n            filter: node => node.inBundle,\n          })\n        }\n      }\n    }\n    await promiseAllRejectLate(promises)\n\n    // now sort into the queues for the 4 things we have to do\n    // run in the same predictable order that buildIdealTree uses\n    // there's no particular reason for doing it in this order rather\n    // than another, but sorting *somehow* makes it consistent.\n    const queue = [...set].sort(sortNodes)\n\n    for (const node of queue) {\n      const { package: { bin, scripts = {} } } = node.target\n      const { preinstall, install, postinstall, prepare } = scripts\n      const tests = { bin, preinstall, install, postinstall, prepare }\n      for (const [key, has] of Object.entries(tests)) {\n        if (has) {\n          this[_queues][key].push(node)\n        }\n      }\n    }\n    process.emit('timeEnd', 'build:queue')\n  }\n\n  async [_checkBins] (node) {\n    // if the node is a global top, and we're not in force mode, then\n    // any existing bins need to either be missing, or a symlink into\n    // the node path.  Otherwise a package can have a preinstall script\n    // that unlinks something, to allow them to silently overwrite system\n    // binaries, which is unsafe and insecure.\n    if (!node.globalTop || this[_force]) {\n      return\n    }\n    const { path, package: pkg } = node\n    await binLinks.checkBins({ pkg, path, top: true, global: true })\n  }\n\n  async [_addToBuildSet] (node, set, refreshed = false) {\n    if (set.has(node)) {\n      return\n    }\n\n    if (this[_oldMeta] === null) {\n      const {root: {meta}} = node\n      this[_oldMeta] = meta && meta.loadedFromDisk &&\n        !(meta.originalLockfileVersion >= 2)\n    }\n\n    const { package: pkg, hasInstallScript } = node.target\n    const { gypfile, bin, scripts = {} } = pkg\n\n    const { preinstall, install, postinstall, prepare } = scripts\n    const anyScript = preinstall || install || postinstall || prepare\n    if (!refreshed && !anyScript && (hasInstallScript || this[_oldMeta])) {\n      // we either have an old metadata (and thus might have scripts)\n      // or we have an indication that there's install scripts (but\n      // don't yet know what they are) so we have to load the package.json\n      // from disk to see what the deal is.  Failure here just means\n      // no scripts to add, probably borked package.json.\n      // add to the set then remove while we're reading the pj, so we\n      // don't accidentally hit it multiple times.\n      set.add(node)\n      const pkg = await rpj(node.path + '/package.json').catch(() => ({}))\n      set.delete(node)\n\n      const {scripts = {}} = pkg\n      node.package.scripts = scripts\n      return this[_addToBuildSet](node, set, true)\n    }\n\n    // Rebuild node-gyp dependencies lacking an install or preinstall script\n    // note that 'scripts' might be missing entirely, and the package may\n    // set gypfile:false to avoid this automatic detection.\n    const isGyp = gypfile !== false &&\n      !install &&\n      !preinstall &&\n      await isNodeGypPackage(node.path)\n\n    if (bin || preinstall || install || postinstall || prepare || isGyp) {\n      if (bin) {\n        await this[_checkBins](node)\n      }\n      if (isGyp) {\n        scripts.install = defaultGypInstallScript\n        node.package.scripts = scripts\n      }\n      set.add(node)\n    }\n  }\n\n  async [_runScripts] (event) {\n    const queue = this[_queues][event]\n\n    if (!queue.length) {\n      return\n    }\n\n    process.emit('time', `build:run:${event}`)\n    const stdio = this.options.foregroundScripts ? 'inherit' : 'pipe'\n    const limit = this.options.foregroundScripts ? 1 : undefined\n    await promiseCallLimit(queue.map(node => async () => {\n      const {\n        path,\n        integrity,\n        resolved,\n        optional,\n        peer,\n        dev,\n        devOptional,\n        package: pkg,\n        location,\n      } = node.target\n\n      // skip any that we know we'll be deleting\n      if (this[_trashList].has(path)) {\n        return\n      }\n\n      const timer = `build:run:${event}:${location}`\n      process.emit('time', timer)\n      this.log.info('run', pkg._id, event, location, pkg.scripts[event])\n      const env = {\n        npm_package_resolved: resolved,\n        npm_package_integrity: integrity,\n        npm_package_json: resolve(path, 'package.json'),\n        npm_package_optional: boolEnv(optional),\n        npm_package_dev: boolEnv(dev),\n        npm_package_peer: boolEnv(peer),\n        npm_package_dev_optional:\n          boolEnv(devOptional && !dev && !optional),\n      }\n      const runOpts = {\n        event,\n        path,\n        pkg,\n        stdioString: true,\n        stdio,\n        env,\n        scriptShell: this[_scriptShell],\n      }\n      const p = runScript(runOpts).catch(er => {\n        const { code, signal } = er\n        this.log.info('run', pkg._id, event, {code, signal})\n        throw er\n      }).then(({args, code, signal, stdout, stderr}) => {\n        this.scriptsRun.add({\n          pkg,\n          path,\n          event,\n          cmd: args && args[args.length - 1],\n          env,\n          code,\n          signal,\n          stdout,\n          stderr,\n        })\n        this.log.info('run', pkg._id, event, {code, signal})\n      })\n\n      await (this[_doHandleOptionalFailure]\n        ? this[_handleOptionalFailure](node, p)\n        : p)\n\n      process.emit('timeEnd', timer)\n    }), limit)\n    process.emit('timeEnd', `build:run:${event}`)\n  }\n\n  async [_linkAllBins] () {\n    const queue = this[_queues].bin\n    if (!queue.length) {\n      return\n    }\n\n    process.emit('time', 'build:link')\n    const promises = []\n    // sort the queue by node path, so that the module-local collision\n    // detector in bin-links will always resolve the same way.\n    for (const node of queue.sort(sortNodes)) {\n      promises.push(this[_createBinLinks](node))\n    }\n\n    await promiseAllRejectLate(promises)\n    process.emit('timeEnd', 'build:link')\n  }\n\n  async [_createBinLinks] (node) {\n    if (this[_trashList].has(node.path)) {\n      return\n    }\n\n    process.emit('time', `build:link:${node.location}`)\n\n    const p = binLinks({\n      pkg: node.package,\n      path: node.path,\n      top: !!(node.isTop || node.globalTop),\n      force: this[_force],\n      global: !!node.globalTop,\n    })\n\n    await (this[_doHandleOptionalFailure]\n      ? this[_handleOptionalFailure](node, p)\n      : p)\n\n    process.emit('timeEnd', `build:link:${node.location}`)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}