{"ast":null,"code":"// Parse a field, coercing it to the best type available.\nconst typeDefs = require('./type-defs.js');\nconst envReplace = require('./env-replace.js');\nconst {\n  resolve\n} = require('path');\nconst {\n  parse: umaskParse\n} = require('./umask.js');\nconst parseField = (f, key, opts, listElement = false) => {\n  if (typeof f !== 'string' && !Array.isArray(f)) return f;\n  const {\n    platform,\n    types,\n    log,\n    home,\n    env\n  } = opts;\n\n  // type can be array or a single thing.  coerce to array.\n  const typeList = new Set([].concat(types[key]));\n  const isPath = typeList.has(typeDefs.path.type);\n  const isBool = typeList.has(typeDefs.Boolean.type);\n  const isString = isPath || typeList.has(typeDefs.String.type);\n  const isUmask = typeList.has(typeDefs.Umask.type);\n  const isNumber = typeList.has(typeDefs.Number.type);\n  const isList = !listElement && typeList.has(Array);\n  if (Array.isArray(f)) return !isList ? f : f.map(field => parseField(field, key, opts, true));\n\n  // now we know it's a string\n  f = f.trim();\n\n  // list types get put in the environment separated by double-\\n\n  // usually a single \\n would suffice, but ca/cert configs can contain\n  // line breaks and multiple entries.\n  if (isList) return parseField(f.split('\\n\\n'), key, opts);\n\n  // --foo is like --foo=true for boolean types\n  if (isBool && !isString && f === '') return true;\n\n  // string types can be the string 'true', 'false', etc.\n  // otherwise, parse these values out\n  if (!isString && !isPath && !isNumber) {\n    switch (f) {\n      case 'true':\n        return true;\n      case 'false':\n        return false;\n      case 'null':\n        return null;\n      case 'undefined':\n        return undefined;\n    }\n  }\n  f = envReplace(f, env);\n  if (isPath) {\n    const homePattern = platform === 'win32' ? /^~(\\/|\\\\)/ : /^~\\//;\n    if (homePattern.test(f) && home) f = resolve(home, f.substr(2));else f = resolve(f);\n  }\n  if (isUmask) {\n    try {\n      return umaskParse(f);\n    } catch (er) {\n      // let it warn later when we validate\n      return f;\n    }\n  }\n  if (isNumber && !isNaN(f)) f = +f;\n  return f;\n};\nmodule.exports = parseField;","map":{"version":3,"names":["typeDefs","require","envReplace","resolve","parse","umaskParse","parseField","f","key","opts","listElement","Array","isArray","platform","types","log","home","env","typeList","Set","concat","isPath","has","path","type","isBool","Boolean","isString","String","isUmask","Umask","isNumber","Number","isList","map","field","trim","split","undefined","homePattern","test","substr","er","isNaN","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/config/lib/parse-field.js"],"sourcesContent":["// Parse a field, coercing it to the best type available.\nconst typeDefs = require('./type-defs.js')\nconst envReplace = require('./env-replace.js')\nconst { resolve } = require('path')\n\nconst { parse: umaskParse } = require('./umask.js')\n\nconst parseField = (f, key, opts, listElement = false) => {\n  if (typeof f !== 'string' && !Array.isArray(f))\n    return f\n\n  const { platform, types, log, home, env } = opts\n\n  // type can be array or a single thing.  coerce to array.\n  const typeList = new Set([].concat(types[key]))\n  const isPath = typeList.has(typeDefs.path.type)\n  const isBool = typeList.has(typeDefs.Boolean.type)\n  const isString = isPath || typeList.has(typeDefs.String.type)\n  const isUmask = typeList.has(typeDefs.Umask.type)\n  const isNumber = typeList.has(typeDefs.Number.type)\n  const isList = !listElement && typeList.has(Array)\n\n  if (Array.isArray(f))\n    return !isList ? f : f.map(field => parseField(field, key, opts, true))\n\n  // now we know it's a string\n  f = f.trim()\n\n  // list types get put in the environment separated by double-\\n\n  // usually a single \\n would suffice, but ca/cert configs can contain\n  // line breaks and multiple entries.\n  if (isList)\n    return parseField(f.split('\\n\\n'), key, opts)\n\n  // --foo is like --foo=true for boolean types\n  if (isBool && !isString && f === '')\n    return true\n\n  // string types can be the string 'true', 'false', etc.\n  // otherwise, parse these values out\n  if (!isString && !isPath && !isNumber) {\n    switch (f) {\n      case 'true': return true\n      case 'false': return false\n      case 'null': return null\n      case 'undefined': return undefined\n    }\n  }\n\n  f = envReplace(f, env)\n\n  if (isPath) {\n    const homePattern = platform === 'win32' ? /^~(\\/|\\\\)/ : /^~\\//\n    if (homePattern.test(f) && home)\n      f = resolve(home, f.substr(2))\n    else\n      f = resolve(f)\n  }\n\n  if (isUmask) {\n    try {\n      return umaskParse(f)\n    } catch (er) {\n      // let it warn later when we validate\n      return f\n    }\n  }\n\n  if (isNumber && !isNaN(f))\n    f = +f\n\n  return f\n}\n\nmodule.exports = parseField\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}