{"ast":null,"code":"const util = require('util');\nconst _data = Symbol('data');\nconst _delete = Symbol('delete');\nconst _append = Symbol('append');\nconst sqBracketsMatcher = str => str.match(/(.+)\\[([^\\]]+)\\]\\.?(.*)$/);\n\n// replaces any occurence of an empty-brackets (e.g: []) with a special\n// Symbol(append) to represent it, this is going to be useful for the setter\n// method that will push values to the end of the array when finding these\nconst replaceAppendSymbols = str => {\n  const matchEmptyBracket = str.match(/^(.*)\\[\\]\\.?(.*)$/);\n  if (matchEmptyBracket) {\n    const [, pre, post] = matchEmptyBracket;\n    return [...replaceAppendSymbols(pre), _append, post].filter(Boolean);\n  }\n  return [str];\n};\nconst parseKeys = key => {\n  const sqBracketItems = new Set();\n  sqBracketItems.add(_append);\n  const parseSqBrackets = str => {\n    const index = sqBracketsMatcher(str);\n\n    // once we find square brackets, we recursively parse all these\n    if (index) {\n      const preSqBracketPortion = index[1];\n\n      // we want to have a `new String` wrapper here in order to differentiate\n      // between multiple occurences of the same string, e.g:\n      // foo.bar[foo.bar] should split into { foo: { bar: { 'foo.bar': {} } }\n      /* eslint-disable-next-line no-new-wrappers */\n      const foundKey = new String(index[2]);\n      const postSqBracketPortion = index[3];\n\n      // we keep track of items found during this step to make sure\n      // we don't try to split-separate keys that were defined within\n      // square brackets, since the key name itself might contain dots\n      sqBracketItems.add(foundKey);\n\n      // returns an array that contains either dot-separate items (that will\n      // be splitted appart during the next step OR the fully parsed keys\n      // read from square brackets, e.g:\n      // foo.bar[1.0.0].a.b -> ['foo.bar', '1.0.0', 'a.b']\n      return [...parseSqBrackets(preSqBracketPortion), foundKey, ...(postSqBracketPortion ? parseSqBrackets(postSqBracketPortion) : [])];\n    }\n\n    // at the end of parsing, any usage of the special empty-bracket syntax\n    // (e.g: foo.array[]) has  not yet been parsed, here we'll take care\n    // of parsing it and adding a special symbol to represent it in\n    // the resulting list of keys\n    return replaceAppendSymbols(str);\n  };\n  const res = [];\n  // starts by parsing items defined as square brackets, those might be\n  // representing properties that have a dot in the name or just array\n  // indexes, e.g: foo[1.0.0] or list[0]\n  const sqBracketKeys = parseSqBrackets(key.trim());\n  for (const k of sqBracketKeys) {\n    // keys parsed from square brackets should just be added to list of\n    // resulting keys as they might have dots as part of the key\n    if (sqBracketItems.has(k)) res.push(k);else {\n      // splits the dot-sep property names and add them to the list of keys\n      for (const splitKey of k.split('.')) /* eslint-disable-next-line no-new-wrappers */\n      res.push(new String(splitKey));\n    }\n  }\n\n  // returns an ordered list of strings in which each entry\n  // represents a key in an object defined by the previous entry\n  return res;\n};\nconst getter = ({\n  data,\n  key\n}) => {\n  // keys are a list in which each entry represents the name of\n  // a property that should be walked through the object in order to\n  // return the final found value\n  const keys = parseKeys(key);\n  let _data = data;\n  let label = '';\n  for (const k of keys) {\n    // empty-bracket-shortcut-syntax is not supported on getter\n    if (k === _append) {\n      throw Object.assign(new Error('Empty brackets are not valid syntax for retrieving values.'), {\n        code: 'EINVALIDSYNTAX'\n      });\n    }\n\n    // extra logic to take into account printing array, along with its\n    // special syntax in which using a dot-sep property name after an\n    // arry will expand it's results, e.g:\n    // arr.name -> arr[0].name=value, arr[1].name=value, ...\n    const maybeIndex = Number(k);\n    if (Array.isArray(_data) && !Number.isInteger(maybeIndex)) {\n      _data = _data.reduce((acc, i, index) => {\n        acc[`${label}[${index}].${k}`] = i[k];\n        return acc;\n      }, {});\n      return _data;\n    } else {\n      // if can't find any more values, it means it's just over\n      // and there's nothing to return\n      if (!_data[k]) return undefined;\n\n      // otherwise sets the next value\n      _data = _data[k];\n    }\n    label += k;\n  }\n\n  // these are some legacy expectations from\n  // the old API consumed by lib/view.js\n  if (Array.isArray(_data) && _data.length <= 1) _data = _data[0];\n  return {\n    [key]: _data\n  };\n};\nconst setter = ({\n  data,\n  key,\n  value,\n  force\n}) => {\n  // setter goes to recursively transform the provided data obj,\n  // setting properties from the list of parsed keys, e.g:\n  // ['foo', 'bar', 'baz'] -> { foo: { bar: { baz:  {} } }\n  const keys = parseKeys(key);\n  const setKeys = (_data, _key) => {\n    // handles array indexes, converting valid integers to numbers,\n    // note that occurences of Symbol(append) will throw,\n    // so we just ignore these for now\n    let maybeIndex = Number.NaN;\n    try {\n      maybeIndex = Number(_key);\n    } catch (err) {}\n    if (!Number.isNaN(maybeIndex)) _key = maybeIndex;\n\n    // creates new array in case key is an index\n    // and the array obj is not yet defined\n    const keyIsAnArrayIndex = _key === maybeIndex || _key === _append;\n    const dataHasNoItems = !Object.keys(_data).length;\n    if (keyIsAnArrayIndex && dataHasNoItems && !Array.isArray(_data)) _data = [];\n\n    // converting from array to an object is also possible, in case the\n    // user is using force mode, we should also convert existing arrays\n    // to an empty object if the current _data is an array\n    if (force && Array.isArray(_data) && !keyIsAnArrayIndex) _data = {\n      ..._data\n    };\n\n    // the _append key is a special key that is used to represent\n    // the empty-bracket notation, e.g: arr[] -> arr[arr.length]\n    if (_key === _append) {\n      if (!Array.isArray(_data)) {\n        throw Object.assign(new Error(`Can't use append syntax in non-Array element`), {\n          code: 'ENOAPPEND'\n        });\n      }\n      _key = _data.length;\n    }\n\n    // retrieves the next data object to recursively iterate on,\n    // throws if trying to override a literal value or add props to an array\n    const next = () => {\n      const haveContents = !force && _data[_key] != null && value !== _delete;\n      const shouldNotOverrideLiteralValue = !(typeof _data[_key] === 'object');\n      // if the next obj to recurse is an array and the next key to be\n      // appended to the resulting obj is not an array index, then it\n      // should throw since we can't append arbitrary props to arrays\n      const shouldNotAddPropsToArrays = typeof keys[0] !== 'symbol' && Array.isArray(_data[_key]) && Number.isNaN(Number(keys[0]));\n      const overrideError = haveContents && shouldNotOverrideLiteralValue;\n      if (overrideError) {\n        throw Object.assign(new Error(`Property ${_key} already exists and is not an Array or Object.`), {\n          code: 'EOVERRIDEVALUE'\n        });\n      }\n      const addPropsToArrayError = haveContents && shouldNotAddPropsToArrays;\n      if (addPropsToArrayError) {\n        throw Object.assign(new Error(`Can't add property ${key} to an Array.`), {\n          code: 'ENOADDPROP'\n        });\n      }\n      return typeof _data[_key] === 'object' ? _data[_key] || {} : {};\n    };\n\n    // sets items from the parsed array of keys as objects, recurses to\n    // setKeys in case there are still items to be handled, otherwise it\n    // just sets the original value set by the user\n    if (keys.length) _data[_key] = setKeys(next(), keys.shift());else {\n      // handles special deletion cases for obj props / array items\n      if (value === _delete) {\n        if (Array.isArray(_data)) _data.splice(_key, 1);else delete _data[_key];\n      } else\n        // finally, sets the value in its right place\n        _data[_key] = value;\n    }\n    return _data;\n  };\n  setKeys(data, keys.shift());\n};\nclass Queryable {\n  constructor(obj) {\n    if (!obj || typeof obj !== 'object') {\n      throw Object.assign(new Error('Queryable needs an object to query properties from.'), {\n        code: 'ENOQUERYABLEOBJ'\n      });\n    }\n    this[_data] = obj;\n  }\n  query(queries) {\n    // this ugly interface here is meant to be a compatibility layer\n    // with the legacy API lib/view.js is consuming, if at some point\n    // we refactor that command then we can revisit making this nicer\n    if (queries === '') return {\n      '': this[_data]\n    };\n    const q = query => getter({\n      data: this[_data],\n      key: query\n    });\n    if (Array.isArray(queries)) {\n      let res = {};\n      for (const query of queries) res = {\n        ...res,\n        ...q(query)\n      };\n      return res;\n    } else return q(queries);\n  }\n\n  // return the value for a single query if found, otherwise returns undefined\n  get(query) {\n    const obj = this.query(query);\n    if (obj) return obj[query];\n  }\n\n  // creates objects along the way for the provided `query` parameter\n  // and assigns `value` to the last property of the query chain\n  set(query, value, {\n    force\n  } = {}) {\n    setter({\n      data: this[_data],\n      key: query,\n      value,\n      force\n    });\n  }\n\n  // deletes the value of the property found at `query`\n  delete(query) {\n    setter({\n      data: this[_data],\n      key: query,\n      value: _delete\n    });\n  }\n  toJSON() {\n    return this[_data];\n  }\n  [util.inspect.custom]() {\n    return this.toJSON();\n  }\n}\nmodule.exports = Queryable;","map":{"version":3,"names":["util","require","_data","Symbol","_delete","_append","sqBracketsMatcher","str","match","replaceAppendSymbols","matchEmptyBracket","pre","post","filter","Boolean","parseKeys","key","sqBracketItems","Set","add","parseSqBrackets","index","preSqBracketPortion","foundKey","String","postSqBracketPortion","res","sqBracketKeys","trim","k","has","push","splitKey","split","getter","data","keys","label","Object","assign","Error","code","maybeIndex","Number","Array","isArray","isInteger","reduce","acc","i","undefined","length","setter","value","force","setKeys","_key","NaN","err","isNaN","keyIsAnArrayIndex","dataHasNoItems","next","haveContents","shouldNotOverrideLiteralValue","shouldNotAddPropsToArrays","overrideError","addPropsToArrayError","shift","splice","Queryable","constructor","obj","query","queries","q","get","set","delete","toJSON","inspect","custom","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/lib/utils/queryable.js"],"sourcesContent":["const util = require('util')\nconst _data = Symbol('data')\nconst _delete = Symbol('delete')\nconst _append = Symbol('append')\n\nconst sqBracketsMatcher = str => str.match(/(.+)\\[([^\\]]+)\\]\\.?(.*)$/)\n\n// replaces any occurence of an empty-brackets (e.g: []) with a special\n// Symbol(append) to represent it, this is going to be useful for the setter\n// method that will push values to the end of the array when finding these\nconst replaceAppendSymbols = str => {\n  const matchEmptyBracket = str.match(/^(.*)\\[\\]\\.?(.*)$/)\n\n  if (matchEmptyBracket) {\n    const [, pre, post] = matchEmptyBracket\n    return [...replaceAppendSymbols(pre), _append, post].filter(Boolean)\n  }\n\n  return [str]\n}\n\nconst parseKeys = (key) => {\n  const sqBracketItems = new Set()\n  sqBracketItems.add(_append)\n  const parseSqBrackets = (str) => {\n    const index = sqBracketsMatcher(str)\n\n    // once we find square brackets, we recursively parse all these\n    if (index) {\n      const preSqBracketPortion = index[1]\n\n      // we want to have a `new String` wrapper here in order to differentiate\n      // between multiple occurences of the same string, e.g:\n      // foo.bar[foo.bar] should split into { foo: { bar: { 'foo.bar': {} } }\n      /* eslint-disable-next-line no-new-wrappers */\n      const foundKey = new String(index[2])\n      const postSqBracketPortion = index[3]\n\n      // we keep track of items found during this step to make sure\n      // we don't try to split-separate keys that were defined within\n      // square brackets, since the key name itself might contain dots\n      sqBracketItems.add(foundKey)\n\n      // returns an array that contains either dot-separate items (that will\n      // be splitted appart during the next step OR the fully parsed keys\n      // read from square brackets, e.g:\n      // foo.bar[1.0.0].a.b -> ['foo.bar', '1.0.0', 'a.b']\n      return [\n        ...parseSqBrackets(preSqBracketPortion),\n        foundKey,\n        ...(\n          postSqBracketPortion\n            ? parseSqBrackets(postSqBracketPortion)\n            : []\n        ),\n      ]\n    }\n\n    // at the end of parsing, any usage of the special empty-bracket syntax\n    // (e.g: foo.array[]) has  not yet been parsed, here we'll take care\n    // of parsing it and adding a special symbol to represent it in\n    // the resulting list of keys\n    return replaceAppendSymbols(str)\n  }\n\n  const res = []\n  // starts by parsing items defined as square brackets, those might be\n  // representing properties that have a dot in the name or just array\n  // indexes, e.g: foo[1.0.0] or list[0]\n  const sqBracketKeys = parseSqBrackets(key.trim())\n\n  for (const k of sqBracketKeys) {\n    // keys parsed from square brackets should just be added to list of\n    // resulting keys as they might have dots as part of the key\n    if (sqBracketItems.has(k))\n      res.push(k)\n    else {\n      // splits the dot-sep property names and add them to the list of keys\n      for (const splitKey of k.split('.'))\n        /* eslint-disable-next-line no-new-wrappers */\n        res.push(new String(splitKey))\n    }\n  }\n\n  // returns an ordered list of strings in which each entry\n  // represents a key in an object defined by the previous entry\n  return res\n}\n\nconst getter = ({ data, key }) => {\n  // keys are a list in which each entry represents the name of\n  // a property that should be walked through the object in order to\n  // return the final found value\n  const keys = parseKeys(key)\n  let _data = data\n  let label = ''\n\n  for (const k of keys) {\n    // empty-bracket-shortcut-syntax is not supported on getter\n    if (k === _append) {\n      throw Object.assign(\n        new Error('Empty brackets are not valid syntax for retrieving values.'),\n        { code: 'EINVALIDSYNTAX' }\n      )\n    }\n\n    // extra logic to take into account printing array, along with its\n    // special syntax in which using a dot-sep property name after an\n    // arry will expand it's results, e.g:\n    // arr.name -> arr[0].name=value, arr[1].name=value, ...\n    const maybeIndex = Number(k)\n    if (Array.isArray(_data) && !Number.isInteger(maybeIndex)) {\n      _data = _data.reduce((acc, i, index) => {\n        acc[`${label}[${index}].${k}`] = i[k]\n        return acc\n      }, {})\n      return _data\n    } else {\n      // if can't find any more values, it means it's just over\n      // and there's nothing to return\n      if (!_data[k])\n        return undefined\n\n      // otherwise sets the next value\n      _data = _data[k]\n    }\n\n    label += k\n  }\n\n  // these are some legacy expectations from\n  // the old API consumed by lib/view.js\n  if (Array.isArray(_data) && _data.length <= 1)\n    _data = _data[0]\n\n  return {\n    [key]: _data,\n  }\n}\n\nconst setter = ({ data, key, value, force }) => {\n  // setter goes to recursively transform the provided data obj,\n  // setting properties from the list of parsed keys, e.g:\n  // ['foo', 'bar', 'baz'] -> { foo: { bar: { baz:  {} } }\n  const keys = parseKeys(key)\n  const setKeys = (_data, _key) => {\n    // handles array indexes, converting valid integers to numbers,\n    // note that occurences of Symbol(append) will throw,\n    // so we just ignore these for now\n    let maybeIndex = Number.NaN\n    try {\n      maybeIndex = Number(_key)\n    } catch (err) {}\n    if (!Number.isNaN(maybeIndex))\n      _key = maybeIndex\n\n    // creates new array in case key is an index\n    // and the array obj is not yet defined\n    const keyIsAnArrayIndex = _key === maybeIndex || _key === _append\n    const dataHasNoItems = !Object.keys(_data).length\n    if (keyIsAnArrayIndex && dataHasNoItems && !Array.isArray(_data))\n      _data = []\n\n    // converting from array to an object is also possible, in case the\n    // user is using force mode, we should also convert existing arrays\n    // to an empty object if the current _data is an array\n    if (force && Array.isArray(_data) && !keyIsAnArrayIndex)\n      _data = { ..._data }\n\n    // the _append key is a special key that is used to represent\n    // the empty-bracket notation, e.g: arr[] -> arr[arr.length]\n    if (_key === _append) {\n      if (!Array.isArray(_data)) {\n        throw Object.assign(\n          new Error(`Can't use append syntax in non-Array element`),\n          { code: 'ENOAPPEND' }\n        )\n      }\n      _key = _data.length\n    }\n\n    // retrieves the next data object to recursively iterate on,\n    // throws if trying to override a literal value or add props to an array\n    const next = () => {\n      const haveContents =\n        !force &&\n        _data[_key] != null &&\n        value !== _delete\n      const shouldNotOverrideLiteralValue =\n        !(typeof _data[_key] === 'object')\n      // if the next obj to recurse is an array and the next key to be\n      // appended to the resulting obj is not an array index, then it\n      // should throw since we can't append arbitrary props to arrays\n      const shouldNotAddPropsToArrays =\n        typeof keys[0] !== 'symbol' &&\n        Array.isArray(_data[_key]) &&\n        Number.isNaN(Number(keys[0]))\n\n      const overrideError =\n        haveContents &&\n        shouldNotOverrideLiteralValue\n      if (overrideError) {\n        throw Object.assign(\n          new Error(`Property ${_key} already exists and is not an Array or Object.`),\n          { code: 'EOVERRIDEVALUE' }\n        )\n      }\n\n      const addPropsToArrayError =\n        haveContents &&\n        shouldNotAddPropsToArrays\n      if (addPropsToArrayError) {\n        throw Object.assign(\n          new Error(`Can't add property ${key} to an Array.`),\n          { code: 'ENOADDPROP' }\n        )\n      }\n\n      return typeof _data[_key] === 'object' ? _data[_key] || {} : {}\n    }\n\n    // sets items from the parsed array of keys as objects, recurses to\n    // setKeys in case there are still items to be handled, otherwise it\n    // just sets the original value set by the user\n    if (keys.length)\n      _data[_key] = setKeys(next(), keys.shift())\n    else {\n      // handles special deletion cases for obj props / array items\n      if (value === _delete) {\n        if (Array.isArray(_data))\n          _data.splice(_key, 1)\n        else\n          delete _data[_key]\n      } else\n        // finally, sets the value in its right place\n        _data[_key] = value\n    }\n\n    return _data\n  }\n\n  setKeys(data, keys.shift())\n}\n\nclass Queryable {\n  constructor (obj) {\n    if (!obj || typeof obj !== 'object') {\n      throw Object.assign(\n        new Error('Queryable needs an object to query properties from.'),\n        { code: 'ENOQUERYABLEOBJ' }\n      )\n    }\n\n    this[_data] = obj\n  }\n\n  query (queries) {\n    // this ugly interface here is meant to be a compatibility layer\n    // with the legacy API lib/view.js is consuming, if at some point\n    // we refactor that command then we can revisit making this nicer\n    if (queries === '')\n      return { '': this[_data] }\n\n    const q = query => getter({\n      data: this[_data],\n      key: query,\n    })\n\n    if (Array.isArray(queries)) {\n      let res = {}\n      for (const query of queries)\n        res = { ...res, ...q(query) }\n      return res\n    } else\n      return q(queries)\n  }\n\n  // return the value for a single query if found, otherwise returns undefined\n  get (query) {\n    const obj = this.query(query)\n    if (obj)\n      return obj[query]\n  }\n\n  // creates objects along the way for the provided `query` parameter\n  // and assigns `value` to the last property of the query chain\n  set (query, value, { force } = {}) {\n    setter({\n      data: this[_data],\n      key: query,\n      value,\n      force,\n    })\n  }\n\n  // deletes the value of the property found at `query`\n  delete (query) {\n    setter({\n      data: this[_data],\n      key: query,\n      value: _delete,\n    })\n  }\n\n  toJSON () {\n    return this[_data]\n  }\n\n  [util.inspect.custom] () {\n    return this.toJSON()\n  }\n}\n\nmodule.exports = Queryable\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}