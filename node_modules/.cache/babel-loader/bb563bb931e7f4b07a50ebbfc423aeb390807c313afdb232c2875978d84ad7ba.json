{"ast":null,"code":"// parse a yarn lock file\n// basic format\n//\n// <request spec>[, <request spec> ...]:\n//   <key> <value>\n//   <subkey>:\n//     <key> <value>\n//\n// Assume that any key or value might be quoted, though that's only done\n// in practice if certain chars are in the string.  Quoting unnecessarily\n// does not cause problems for yarn, so that's what we do when we write\n// it back.\n//\n// The data format would support nested objects, but at this time, it\n// appears that yarn does not use that for anything, so in the interest\n// of a simpler parser algorithm, this implementation only supports a\n// single layer of sub objects.\n//\n// This doesn't deterministically define the shape of the tree, and so\n// cannot be used (on its own) for Arborist.loadVirtual.\n// But it can give us resolved, integrity, and version, which is useful\n// for Arborist.loadActual and for building the ideal tree.\n//\n// At the very least, when a yarn.lock file is present, we update it\n// along the way, and save it back in Shrinkwrap.save()\n//\n// NIHing this rather than using @yarnpkg/lockfile because that module\n// is an impenetrable 10kloc of webpack flow output, which is overkill\n// for something relatively simple and tailored to Arborist's use case.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\nconst consistentResolve = require('./consistent-resolve.js');\nconst {\n  dirname\n} = require('path');\nconst {\n  breadth\n} = require('treeverse');\n\n// sort a key/value object into a string of JSON stringified keys and vals\nconst sortKV = obj => Object.keys(obj).sort(localeCompare).map(k => `    ${JSON.stringify(k)} ${JSON.stringify(obj[k])}`).join('\\n');\n\n// for checking against previous entries\nconst match = (p, n) => p.integrity && n.integrity ? p.integrity === n.integrity : p.resolved && n.resolved ? p.resolved === n.resolved : p.version && n.version ? p.version === n.version : true;\nconst prefix = `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# yarn lockfile v1\n\n\n`;\nconst nullSymbol = Symbol('null');\nclass YarnLock {\n  static parse(data) {\n    return new YarnLock().parse(data);\n  }\n  static fromTree(tree) {\n    return new YarnLock().fromTree(tree);\n  }\n  constructor() {\n    this.entries = null;\n    this.endCurrent();\n  }\n  endCurrent() {\n    this.current = null;\n    this.subkey = nullSymbol;\n  }\n  parse(data) {\n    const ENTRY_START = /^[^\\s].*:$/;\n    const SUBKEY = /^ {2}[^\\s]+:$/;\n    const SUBVAL = /^ {4}[^\\s]+ .+$/;\n    const METADATA = /^ {2}[^\\s]+ .+$/;\n    this.entries = new Map();\n    this.current = null;\n    const linere = /([^\\r\\n]*)\\r?\\n/gm;\n    let match;\n    let lineNum = 0;\n    if (!/\\n$/.test(data)) {\n      data += '\\n';\n    }\n    while (match = linere.exec(data)) {\n      const line = match[1];\n      lineNum++;\n      if (line.charAt(0) === '#') {\n        continue;\n      }\n      if (line === '') {\n        this.endCurrent();\n        continue;\n      }\n      if (ENTRY_START.test(line)) {\n        this.endCurrent();\n        const specs = this.splitQuoted(line.slice(0, -1), /, */);\n        this.current = new YarnLockEntry(specs);\n        specs.forEach(spec => this.entries.set(spec, this.current));\n        continue;\n      }\n      if (SUBKEY.test(line)) {\n        this.subkey = line.slice(2, -1);\n        this.current[this.subkey] = {};\n        continue;\n      }\n      if (SUBVAL.test(line) && this.current && this.current[this.subkey]) {\n        const subval = this.splitQuoted(line.trimLeft(), ' ');\n        if (subval.length === 2) {\n          this.current[this.subkey][subval[0]] = subval[1];\n          continue;\n        }\n      }\n      // any other metadata\n      if (METADATA.test(line) && this.current) {\n        const metadata = this.splitQuoted(line.trimLeft(), ' ');\n        if (metadata.length === 2) {\n          // strip off the legacy shasum hashes\n          if (metadata[0] === 'resolved') {\n            metadata[1] = metadata[1].replace(/#.*/, '');\n          }\n          this.current[metadata[0]] = metadata[1];\n          continue;\n        }\n      }\n      throw Object.assign(new Error('invalid or corrupted yarn.lock file'), {\n        position: match.index,\n        content: match[0],\n        line: lineNum\n      });\n    }\n    this.endCurrent();\n    return this;\n  }\n  splitQuoted(str, delim) {\n    // a,\"b,c\",d\"e,f => ['a','\"b','c\"','d\"e','f'] => ['a','b,c','d\"e','f']\n    const split = str.split(delim);\n    const out = [];\n    let o = 0;\n    for (let i = 0; i < split.length; i++) {\n      const chunk = split[i];\n      if (/^\".*\"$/.test(chunk)) {\n        out[o++] = chunk.trim().slice(1, -1);\n      } else if (/^\"/.test(chunk)) {\n        let collect = chunk.trimLeft().slice(1);\n        while (++i < split.length) {\n          const n = split[i];\n          // something that is not a slash, followed by an even number\n          // of slashes then a \" then end => ending on an unescaped \"\n          if (/[^\\\\](\\\\\\\\)*\"$/.test(n)) {\n            collect += n.trimRight().slice(0, -1);\n            break;\n          } else {\n            collect += n;\n          }\n        }\n        out[o++] = collect;\n      } else {\n        out[o++] = chunk.trim();\n      }\n    }\n    return out;\n  }\n  toString() {\n    return prefix + [...new Set([...this.entries.values()])].map(e => e.toString()).sort(localeCompare).join('\\n\\n') + '\\n';\n  }\n  fromTree(tree) {\n    this.entries = new Map();\n    // walk the tree in a deterministic order, breadth-first, alphabetical\n    breadth({\n      tree,\n      visit: node => this.addEntryFromNode(node),\n      getChildren: node => [...node.children.values(), ...node.fsChildren].sort((a, b) => a.depth - b.depth || localeCompare(a.name, b.name))\n    });\n    return this;\n  }\n  addEntryFromNode(node) {\n    const specs = [...node.edgesIn].map(e => `${node.name}@${e.spec}`).sort(localeCompare);\n\n    // Note:\n    // yarn will do excessive duplication in a case like this:\n    // root -> (x@1.x, y@1.x, z@1.x)\n    // y@1.x -> (x@1.1, z@2.x)\n    // z@1.x -> ()\n    // z@2.x -> (x@1.x)\n    //\n    // where x@1.2 exists, because the \"x@1.x\" spec will *always* resolve\n    // to x@1.2, which doesn't work for y's dep on x@1.1, so you'll get this:\n    //\n    // root\n    // +-- x@1.2.0\n    // +-- y\n    // |   +-- x@1.1.0\n    // |   +-- z@2\n    // |       +-- x@1.2.0\n    // +-- z@1\n    //\n    // instead of this more deduped tree that arborist builds by default:\n    //\n    // root\n    // +-- x@1.2.0 (dep is x@1.x, from root)\n    // +-- y\n    // |   +-- x@1.1.0\n    // |   +-- z@2 (dep on x@1.x deduped to x@1.1.0 under y)\n    // +-- z@1\n    //\n    // In order to not create an invalid yarn.lock file with conflicting\n    // entries, AND not tell yarn to create an invalid tree, we need to\n    // ignore the x@1.x spec coming from z, since it's already in the entries.\n    //\n    // So, if the integrity and resolved don't match a previous entry, skip it.\n    // We call this method on shallower nodes first, so this is fine.\n    const n = this.entryDataFromNode(node);\n    let priorEntry = null;\n    const newSpecs = [];\n    for (const s of specs) {\n      const prev = this.entries.get(s);\n      // no previous entry for this spec at all, so it's new\n      if (!prev) {\n        // if we saw a match already, then assign this spec to it as well\n        if (priorEntry) {\n          priorEntry.addSpec(s);\n        } else {\n          newSpecs.push(s);\n        }\n        continue;\n      }\n      const m = match(prev, n);\n      // there was a prior entry, but a different thing.  skip this one\n      if (!m) {\n        continue;\n      }\n\n      // previous matches, but first time seeing it, so already has this spec.\n      // go ahead and add all the previously unseen specs, though\n      if (!priorEntry) {\n        priorEntry = prev;\n        for (const s of newSpecs) {\n          priorEntry.addSpec(s);\n          this.entries.set(s, priorEntry);\n        }\n        newSpecs.length = 0;\n        continue;\n      }\n\n      // have a prior entry matching n, and matching the prev we just saw\n      // add the spec to it\n      priorEntry.addSpec(s);\n      this.entries.set(s, priorEntry);\n    }\n\n    // if we never found a matching prior, then this is a whole new thing\n    if (!priorEntry) {\n      const entry = Object.assign(new YarnLockEntry(newSpecs), n);\n      for (const s of newSpecs) {\n        this.entries.set(s, entry);\n      }\n    } else {\n      // pick up any new info that we got for this node, so that we can\n      // decorate with integrity/resolved/etc.\n      Object.assign(priorEntry, n);\n    }\n  }\n  entryDataFromNode(node) {\n    const n = {};\n    if (node.package.dependencies) {\n      n.dependencies = node.package.dependencies;\n    }\n    if (node.package.optionalDependencies) {\n      n.optionalDependencies = node.package.optionalDependencies;\n    }\n    if (node.version) {\n      n.version = node.version;\n    }\n    if (node.resolved) {\n      n.resolved = consistentResolve(node.resolved, node.isLink ? dirname(node.path) : node.path, node.root.path, true);\n    }\n    if (node.integrity) {\n      n.integrity = node.integrity;\n    }\n    return n;\n  }\n  static get Entry() {\n    return YarnLockEntry;\n  }\n}\nconst _specs = Symbol('_specs');\nclass YarnLockEntry {\n  constructor(specs) {\n    this[_specs] = new Set(specs);\n    this.resolved = null;\n    this.version = null;\n    this.integrity = null;\n    this.dependencies = null;\n    this.optionalDependencies = null;\n  }\n  toString() {\n    // sort objects to the bottom, then alphabetical\n    return ([...this[_specs]].sort(localeCompare).map(JSON.stringify).join(', ') + ':\\n' + Object.getOwnPropertyNames(this).filter(prop => this[prop] !== null).sort((a, b) => /* istanbul ignore next - sort call order is unpredictable */\n    typeof this[a] === 'object' === (typeof this[b] === 'object') ? localeCompare(a, b) : typeof this[a] === 'object' ? 1 : -1).map(prop => typeof this[prop] !== 'object' ? `  ${JSON.stringify(prop)} ${JSON.stringify(this[prop])}\\n` : Object.keys(this[prop]).length === 0 ? '' : `  ${prop}:\\n` + sortKV(this[prop]) + '\\n').join('')).trim();\n  }\n  addSpec(spec) {\n    this[_specs].add(spec);\n  }\n}\nmodule.exports = YarnLock;","map":{"version":3,"names":["localeCompare","require","consistentResolve","dirname","breadth","sortKV","obj","Object","keys","sort","map","k","JSON","stringify","join","match","p","n","integrity","resolved","version","prefix","nullSymbol","Symbol","YarnLock","parse","data","fromTree","tree","constructor","entries","endCurrent","current","subkey","ENTRY_START","SUBKEY","SUBVAL","METADATA","Map","linere","lineNum","test","exec","line","charAt","specs","splitQuoted","slice","YarnLockEntry","forEach","spec","set","subval","trimLeft","length","metadata","replace","assign","Error","position","index","content","str","delim","split","out","o","i","chunk","trim","collect","trimRight","toString","Set","values","e","visit","node","addEntryFromNode","getChildren","children","fsChildren","a","b","depth","name","edgesIn","entryDataFromNode","priorEntry","newSpecs","s","prev","get","addSpec","push","m","entry","package","dependencies","optionalDependencies","isLink","path","root","Entry","_specs","getOwnPropertyNames","filter","prop","add","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/yarn-lock.js"],"sourcesContent":["// parse a yarn lock file\n// basic format\n//\n// <request spec>[, <request spec> ...]:\n//   <key> <value>\n//   <subkey>:\n//     <key> <value>\n//\n// Assume that any key or value might be quoted, though that's only done\n// in practice if certain chars are in the string.  Quoting unnecessarily\n// does not cause problems for yarn, so that's what we do when we write\n// it back.\n//\n// The data format would support nested objects, but at this time, it\n// appears that yarn does not use that for anything, so in the interest\n// of a simpler parser algorithm, this implementation only supports a\n// single layer of sub objects.\n//\n// This doesn't deterministically define the shape of the tree, and so\n// cannot be used (on its own) for Arborist.loadVirtual.\n// But it can give us resolved, integrity, and version, which is useful\n// for Arborist.loadActual and for building the ideal tree.\n//\n// At the very least, when a yarn.lock file is present, we update it\n// along the way, and save it back in Shrinkwrap.save()\n//\n// NIHing this rather than using @yarnpkg/lockfile because that module\n// is an impenetrable 10kloc of webpack flow output, which is overkill\n// for something relatively simple and tailored to Arborist's use case.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst consistentResolve = require('./consistent-resolve.js')\nconst {dirname} = require('path')\nconst {breadth} = require('treeverse')\n\n// sort a key/value object into a string of JSON stringified keys and vals\nconst sortKV = obj => Object.keys(obj)\n  .sort(localeCompare)\n  .map(k => `    ${JSON.stringify(k)} ${JSON.stringify(obj[k])}`)\n  .join('\\n')\n\n// for checking against previous entries\nconst match = (p, n) =>\n  p.integrity && n.integrity ? p.integrity === n.integrity\n  : p.resolved && n.resolved ? p.resolved === n.resolved\n  : p.version && n.version ? p.version === n.version\n  : true\n\nconst prefix =\n`# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# yarn lockfile v1\n\n\n`\n\nconst nullSymbol = Symbol('null')\nclass YarnLock {\n  static parse (data) {\n    return new YarnLock().parse(data)\n  }\n\n  static fromTree (tree) {\n    return new YarnLock().fromTree(tree)\n  }\n\n  constructor () {\n    this.entries = null\n    this.endCurrent()\n  }\n\n  endCurrent () {\n    this.current = null\n    this.subkey = nullSymbol\n  }\n\n  parse (data) {\n    const ENTRY_START = /^[^\\s].*:$/\n    const SUBKEY = /^ {2}[^\\s]+:$/\n    const SUBVAL = /^ {4}[^\\s]+ .+$/\n    const METADATA = /^ {2}[^\\s]+ .+$/\n    this.entries = new Map()\n    this.current = null\n    const linere = /([^\\r\\n]*)\\r?\\n/gm\n    let match\n    let lineNum = 0\n    if (!/\\n$/.test(data)) {\n      data += '\\n'\n    }\n    while (match = linere.exec(data)) {\n      const line = match[1]\n      lineNum++\n      if (line.charAt(0) === '#') {\n        continue\n      }\n      if (line === '') {\n        this.endCurrent()\n        continue\n      }\n      if (ENTRY_START.test(line)) {\n        this.endCurrent()\n        const specs = this.splitQuoted(line.slice(0, -1), /, */)\n        this.current = new YarnLockEntry(specs)\n        specs.forEach(spec => this.entries.set(spec, this.current))\n        continue\n      }\n      if (SUBKEY.test(line)) {\n        this.subkey = line.slice(2, -1)\n        this.current[this.subkey] = {}\n        continue\n      }\n      if (SUBVAL.test(line) && this.current && this.current[this.subkey]) {\n        const subval = this.splitQuoted(line.trimLeft(), ' ')\n        if (subval.length === 2) {\n          this.current[this.subkey][subval[0]] = subval[1]\n          continue\n        }\n      }\n      // any other metadata\n      if (METADATA.test(line) && this.current) {\n        const metadata = this.splitQuoted(line.trimLeft(), ' ')\n        if (metadata.length === 2) {\n          // strip off the legacy shasum hashes\n          if (metadata[0] === 'resolved') {\n            metadata[1] = metadata[1].replace(/#.*/, '')\n          }\n          this.current[metadata[0]] = metadata[1]\n          continue\n        }\n      }\n\n      throw Object.assign(new Error('invalid or corrupted yarn.lock file'), {\n        position: match.index,\n        content: match[0],\n        line: lineNum,\n      })\n    }\n    this.endCurrent()\n    return this\n  }\n\n  splitQuoted (str, delim) {\n    // a,\"b,c\",d\"e,f => ['a','\"b','c\"','d\"e','f'] => ['a','b,c','d\"e','f']\n    const split = str.split(delim)\n    const out = []\n    let o = 0\n    for (let i = 0; i < split.length; i++) {\n      const chunk = split[i]\n      if (/^\".*\"$/.test(chunk)) {\n        out[o++] = chunk.trim().slice(1, -1)\n      } else if (/^\"/.test(chunk)) {\n        let collect = chunk.trimLeft().slice(1)\n        while (++i < split.length) {\n          const n = split[i]\n          // something that is not a slash, followed by an even number\n          // of slashes then a \" then end => ending on an unescaped \"\n          if (/[^\\\\](\\\\\\\\)*\"$/.test(n)) {\n            collect += n.trimRight().slice(0, -1)\n            break\n          } else {\n            collect += n\n          }\n        }\n        out[o++] = collect\n      } else {\n        out[o++] = chunk.trim()\n      }\n    }\n    return out\n  }\n\n  toString () {\n    return prefix + [...new Set([...this.entries.values()])]\n      .map(e => e.toString())\n      .sort(localeCompare).join('\\n\\n') + '\\n'\n  }\n\n  fromTree (tree) {\n    this.entries = new Map()\n    // walk the tree in a deterministic order, breadth-first, alphabetical\n    breadth({\n      tree,\n      visit: node => this.addEntryFromNode(node),\n      getChildren: node => [...node.children.values(), ...node.fsChildren]\n        .sort((a, b) => a.depth - b.depth || localeCompare(a.name, b.name)),\n    })\n    return this\n  }\n\n  addEntryFromNode (node) {\n    const specs = [...node.edgesIn]\n      .map(e => `${node.name}@${e.spec}`)\n      .sort(localeCompare)\n\n    // Note:\n    // yarn will do excessive duplication in a case like this:\n    // root -> (x@1.x, y@1.x, z@1.x)\n    // y@1.x -> (x@1.1, z@2.x)\n    // z@1.x -> ()\n    // z@2.x -> (x@1.x)\n    //\n    // where x@1.2 exists, because the \"x@1.x\" spec will *always* resolve\n    // to x@1.2, which doesn't work for y's dep on x@1.1, so you'll get this:\n    //\n    // root\n    // +-- x@1.2.0\n    // +-- y\n    // |   +-- x@1.1.0\n    // |   +-- z@2\n    // |       +-- x@1.2.0\n    // +-- z@1\n    //\n    // instead of this more deduped tree that arborist builds by default:\n    //\n    // root\n    // +-- x@1.2.0 (dep is x@1.x, from root)\n    // +-- y\n    // |   +-- x@1.1.0\n    // |   +-- z@2 (dep on x@1.x deduped to x@1.1.0 under y)\n    // +-- z@1\n    //\n    // In order to not create an invalid yarn.lock file with conflicting\n    // entries, AND not tell yarn to create an invalid tree, we need to\n    // ignore the x@1.x spec coming from z, since it's already in the entries.\n    //\n    // So, if the integrity and resolved don't match a previous entry, skip it.\n    // We call this method on shallower nodes first, so this is fine.\n    const n = this.entryDataFromNode(node)\n    let priorEntry = null\n    const newSpecs = []\n    for (const s of specs) {\n      const prev = this.entries.get(s)\n      // no previous entry for this spec at all, so it's new\n      if (!prev) {\n        // if we saw a match already, then assign this spec to it as well\n        if (priorEntry) {\n          priorEntry.addSpec(s)\n        } else {\n          newSpecs.push(s)\n        }\n        continue\n      }\n\n      const m = match(prev, n)\n      // there was a prior entry, but a different thing.  skip this one\n      if (!m) {\n        continue\n      }\n\n      // previous matches, but first time seeing it, so already has this spec.\n      // go ahead and add all the previously unseen specs, though\n      if (!priorEntry) {\n        priorEntry = prev\n        for (const s of newSpecs) {\n          priorEntry.addSpec(s)\n          this.entries.set(s, priorEntry)\n        }\n        newSpecs.length = 0\n        continue\n      }\n\n      // have a prior entry matching n, and matching the prev we just saw\n      // add the spec to it\n      priorEntry.addSpec(s)\n      this.entries.set(s, priorEntry)\n    }\n\n    // if we never found a matching prior, then this is a whole new thing\n    if (!priorEntry) {\n      const entry = Object.assign(new YarnLockEntry(newSpecs), n)\n      for (const s of newSpecs) {\n        this.entries.set(s, entry)\n      }\n    } else {\n      // pick up any new info that we got for this node, so that we can\n      // decorate with integrity/resolved/etc.\n      Object.assign(priorEntry, n)\n    }\n  }\n\n  entryDataFromNode (node) {\n    const n = {}\n    if (node.package.dependencies) {\n      n.dependencies = node.package.dependencies\n    }\n    if (node.package.optionalDependencies) {\n      n.optionalDependencies = node.package.optionalDependencies\n    }\n    if (node.version) {\n      n.version = node.version\n    }\n    if (node.resolved) {\n      n.resolved = consistentResolve(\n        node.resolved,\n        node.isLink ? dirname(node.path) : node.path,\n        node.root.path,\n        true\n      )\n    }\n    if (node.integrity) {\n      n.integrity = node.integrity\n    }\n\n    return n\n  }\n\n  static get Entry () {\n    return YarnLockEntry\n  }\n}\n\nconst _specs = Symbol('_specs')\nclass YarnLockEntry {\n  constructor (specs) {\n    this[_specs] = new Set(specs)\n    this.resolved = null\n    this.version = null\n    this.integrity = null\n    this.dependencies = null\n    this.optionalDependencies = null\n  }\n\n  toString () {\n    // sort objects to the bottom, then alphabetical\n    return ([...this[_specs]]\n      .sort(localeCompare)\n      .map(JSON.stringify).join(', ') +\n      ':\\n' +\n      Object.getOwnPropertyNames(this)\n        .filter(prop => this[prop] !== null)\n        .sort(\n          (a, b) =>\n          /* istanbul ignore next - sort call order is unpredictable */\n            (typeof this[a] === 'object') === (typeof this[b] === 'object')\n              ? localeCompare(a, b)\n              : typeof this[a] === 'object' ? 1 : -1)\n        .map(prop =>\n          typeof this[prop] !== 'object'\n            ? `  ${JSON.stringify(prop)} ${JSON.stringify(this[prop])}\\n`\n            : Object.keys(this[prop]).length === 0 ? ''\n            : `  ${prop}:\\n` + sortKV(this[prop]) + '\\n')\n        .join('')).trim()\n  }\n\n  addSpec (spec) {\n    this[_specs].add(spec)\n  }\n}\n\nmodule.exports = YarnLock\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,aAAa,GAAGC,OAAO,CAAC,+BAA+B,CAAC,CAAC,IAAI,CAAC;AACpE,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,yBAAyB,CAAC;AAC5D,MAAM;EAACE;AAAO,CAAC,GAAGF,OAAO,CAAC,MAAM,CAAC;AACjC,MAAM;EAACG;AAAO,CAAC,GAAGH,OAAO,CAAC,WAAW,CAAC;;AAEtC;AACA,MAAMI,MAAM,GAAGC,GAAG,IAAIC,MAAM,CAACC,IAAI,CAACF,GAAG,CAAC,CACnCG,IAAI,CAACT,aAAa,CAAC,CACnBU,GAAG,CAACC,CAAC,IAAI,OAAOC,IAAI,CAACC,SAAS,CAACF,CAAC,CAAC,IAAIC,IAAI,CAACC,SAAS,CAACP,GAAG,CAACK,CAAC,CAAC,CAAC,EAAE,CAAC,CAC9DG,IAAI,CAAC,IAAI,CAAC;;AAEb;AACA,MAAMC,KAAK,GAAGA,CAACC,CAAC,EAAEC,CAAC,KACjBD,CAAC,CAACE,SAAS,IAAID,CAAC,CAACC,SAAS,GAAGF,CAAC,CAACE,SAAS,KAAKD,CAAC,CAACC,SAAS,GACtDF,CAAC,CAACG,QAAQ,IAAIF,CAAC,CAACE,QAAQ,GAAGH,CAAC,CAACG,QAAQ,KAAKF,CAAC,CAACE,QAAQ,GACpDH,CAAC,CAACI,OAAO,IAAIH,CAAC,CAACG,OAAO,GAAGJ,CAAC,CAACI,OAAO,KAAKH,CAAC,CAACG,OAAO,GAChD,IAAI;AAER,MAAMC,MAAM,GACZ;AACA;AACA;AACA;AACA,CAAC;AAED,MAAMC,UAAU,GAAGC,MAAM,CAAC,MAAM,CAAC;AACjC,MAAMC,QAAQ,CAAC;EACb,OAAOC,KAAKA,CAAEC,IAAI,EAAE;IAClB,OAAO,IAAIF,QAAQ,CAAC,CAAC,CAACC,KAAK,CAACC,IAAI,CAAC;EACnC;EAEA,OAAOC,QAAQA,CAAEC,IAAI,EAAE;IACrB,OAAO,IAAIJ,QAAQ,CAAC,CAAC,CAACG,QAAQ,CAACC,IAAI,CAAC;EACtC;EAEAC,WAAWA,CAAA,EAAI;IACb,IAAI,CAACC,OAAO,GAAG,IAAI;IACnB,IAAI,CAACC,UAAU,CAAC,CAAC;EACnB;EAEAA,UAAUA,CAAA,EAAI;IACZ,IAAI,CAACC,OAAO,GAAG,IAAI;IACnB,IAAI,CAACC,MAAM,GAAGX,UAAU;EAC1B;EAEAG,KAAKA,CAAEC,IAAI,EAAE;IACX,MAAMQ,WAAW,GAAG,YAAY;IAChC,MAAMC,MAAM,GAAG,eAAe;IAC9B,MAAMC,MAAM,GAAG,iBAAiB;IAChC,MAAMC,QAAQ,GAAG,iBAAiB;IAClC,IAAI,CAACP,OAAO,GAAG,IAAIQ,GAAG,CAAC,CAAC;IACxB,IAAI,CAACN,OAAO,GAAG,IAAI;IACnB,MAAMO,MAAM,GAAG,mBAAmB;IAClC,IAAIxB,KAAK;IACT,IAAIyB,OAAO,GAAG,CAAC;IACf,IAAI,CAAC,KAAK,CAACC,IAAI,CAACf,IAAI,CAAC,EAAE;MACrBA,IAAI,IAAI,IAAI;IACd;IACA,OAAOX,KAAK,GAAGwB,MAAM,CAACG,IAAI,CAAChB,IAAI,CAAC,EAAE;MAChC,MAAMiB,IAAI,GAAG5B,KAAK,CAAC,CAAC,CAAC;MACrByB,OAAO,EAAE;MACT,IAAIG,IAAI,CAACC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC1B;MACF;MACA,IAAID,IAAI,KAAK,EAAE,EAAE;QACf,IAAI,CAACZ,UAAU,CAAC,CAAC;QACjB;MACF;MACA,IAAIG,WAAW,CAACO,IAAI,CAACE,IAAI,CAAC,EAAE;QAC1B,IAAI,CAACZ,UAAU,CAAC,CAAC;QACjB,MAAMc,KAAK,GAAG,IAAI,CAACC,WAAW,CAACH,IAAI,CAACI,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;QACxD,IAAI,CAACf,OAAO,GAAG,IAAIgB,aAAa,CAACH,KAAK,CAAC;QACvCA,KAAK,CAACI,OAAO,CAACC,IAAI,IAAI,IAAI,CAACpB,OAAO,CAACqB,GAAG,CAACD,IAAI,EAAE,IAAI,CAAClB,OAAO,CAAC,CAAC;QAC3D;MACF;MACA,IAAIG,MAAM,CAACM,IAAI,CAACE,IAAI,CAAC,EAAE;QACrB,IAAI,CAACV,MAAM,GAAGU,IAAI,CAACI,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/B,IAAI,CAACf,OAAO,CAAC,IAAI,CAACC,MAAM,CAAC,GAAG,CAAC,CAAC;QAC9B;MACF;MACA,IAAIG,MAAM,CAACK,IAAI,CAACE,IAAI,CAAC,IAAI,IAAI,CAACX,OAAO,IAAI,IAAI,CAACA,OAAO,CAAC,IAAI,CAACC,MAAM,CAAC,EAAE;QAClE,MAAMmB,MAAM,GAAG,IAAI,CAACN,WAAW,CAACH,IAAI,CAACU,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;QACrD,IAAID,MAAM,CAACE,MAAM,KAAK,CAAC,EAAE;UACvB,IAAI,CAACtB,OAAO,CAAC,IAAI,CAACC,MAAM,CAAC,CAACmB,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC;UAChD;QACF;MACF;MACA;MACA,IAAIf,QAAQ,CAACI,IAAI,CAACE,IAAI,CAAC,IAAI,IAAI,CAACX,OAAO,EAAE;QACvC,MAAMuB,QAAQ,GAAG,IAAI,CAACT,WAAW,CAACH,IAAI,CAACU,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;QACvD,IAAIE,QAAQ,CAACD,MAAM,KAAK,CAAC,EAAE;UACzB;UACA,IAAIC,QAAQ,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;YAC9BA,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;UAC9C;UACA,IAAI,CAACxB,OAAO,CAACuB,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC;UACvC;QACF;MACF;MAEA,MAAMhD,MAAM,CAACkD,MAAM,CAAC,IAAIC,KAAK,CAAC,qCAAqC,CAAC,EAAE;QACpEC,QAAQ,EAAE5C,KAAK,CAAC6C,KAAK;QACrBC,OAAO,EAAE9C,KAAK,CAAC,CAAC,CAAC;QACjB4B,IAAI,EAAEH;MACR,CAAC,CAAC;IACJ;IACA,IAAI,CAACT,UAAU,CAAC,CAAC;IACjB,OAAO,IAAI;EACb;EAEAe,WAAWA,CAAEgB,GAAG,EAAEC,KAAK,EAAE;IACvB;IACA,MAAMC,KAAK,GAAGF,GAAG,CAACE,KAAK,CAACD,KAAK,CAAC;IAC9B,MAAME,GAAG,GAAG,EAAE;IACd,IAAIC,CAAC,GAAG,CAAC;IACT,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACV,MAAM,EAAEa,CAAC,EAAE,EAAE;MACrC,MAAMC,KAAK,GAAGJ,KAAK,CAACG,CAAC,CAAC;MACtB,IAAI,QAAQ,CAAC1B,IAAI,CAAC2B,KAAK,CAAC,EAAE;QACxBH,GAAG,CAACC,CAAC,EAAE,CAAC,GAAGE,KAAK,CAACC,IAAI,CAAC,CAAC,CAACtB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACtC,CAAC,MAAM,IAAI,IAAI,CAACN,IAAI,CAAC2B,KAAK,CAAC,EAAE;QAC3B,IAAIE,OAAO,GAAGF,KAAK,CAACf,QAAQ,CAAC,CAAC,CAACN,KAAK,CAAC,CAAC,CAAC;QACvC,OAAO,EAAEoB,CAAC,GAAGH,KAAK,CAACV,MAAM,EAAE;UACzB,MAAMrC,CAAC,GAAG+C,KAAK,CAACG,CAAC,CAAC;UAClB;UACA;UACA,IAAI,gBAAgB,CAAC1B,IAAI,CAACxB,CAAC,CAAC,EAAE;YAC5BqD,OAAO,IAAIrD,CAAC,CAACsD,SAAS,CAAC,CAAC,CAACxB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YACrC;UACF,CAAC,MAAM;YACLuB,OAAO,IAAIrD,CAAC;UACd;QACF;QACAgD,GAAG,CAACC,CAAC,EAAE,CAAC,GAAGI,OAAO;MACpB,CAAC,MAAM;QACLL,GAAG,CAACC,CAAC,EAAE,CAAC,GAAGE,KAAK,CAACC,IAAI,CAAC,CAAC;MACzB;IACF;IACA,OAAOJ,GAAG;EACZ;EAEAO,QAAQA,CAAA,EAAI;IACV,OAAOnD,MAAM,GAAG,CAAC,GAAG,IAAIoD,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC3C,OAAO,CAAC4C,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CACrDhE,GAAG,CAACiE,CAAC,IAAIA,CAAC,CAACH,QAAQ,CAAC,CAAC,CAAC,CACtB/D,IAAI,CAACT,aAAa,CAAC,CAACc,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI;EAC5C;EAEAa,QAAQA,CAAEC,IAAI,EAAE;IACd,IAAI,CAACE,OAAO,GAAG,IAAIQ,GAAG,CAAC,CAAC;IACxB;IACAlC,OAAO,CAAC;MACNwB,IAAI;MACJgD,KAAK,EAAEC,IAAI,IAAI,IAAI,CAACC,gBAAgB,CAACD,IAAI,CAAC;MAC1CE,WAAW,EAAEF,IAAI,IAAI,CAAC,GAAGA,IAAI,CAACG,QAAQ,CAACN,MAAM,CAAC,CAAC,EAAE,GAAGG,IAAI,CAACI,UAAU,CAAC,CACjExE,IAAI,CAAC,CAACyE,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACE,KAAK,GAAGD,CAAC,CAACC,KAAK,IAAIpF,aAAa,CAACkF,CAAC,CAACG,IAAI,EAAEF,CAAC,CAACE,IAAI,CAAC;IACtE,CAAC,CAAC;IACF,OAAO,IAAI;EACb;EAEAP,gBAAgBA,CAAED,IAAI,EAAE;IACtB,MAAMhC,KAAK,GAAG,CAAC,GAAGgC,IAAI,CAACS,OAAO,CAAC,CAC5B5E,GAAG,CAACiE,CAAC,IAAI,GAAGE,IAAI,CAACQ,IAAI,IAAIV,CAAC,CAACzB,IAAI,EAAE,CAAC,CAClCzC,IAAI,CAACT,aAAa,CAAC;;IAEtB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,MAAMiB,CAAC,GAAG,IAAI,CAACsE,iBAAiB,CAACV,IAAI,CAAC;IACtC,IAAIW,UAAU,GAAG,IAAI;IACrB,MAAMC,QAAQ,GAAG,EAAE;IACnB,KAAK,MAAMC,CAAC,IAAI7C,KAAK,EAAE;MACrB,MAAM8C,IAAI,GAAG,IAAI,CAAC7D,OAAO,CAAC8D,GAAG,CAACF,CAAC,CAAC;MAChC;MACA,IAAI,CAACC,IAAI,EAAE;QACT;QACA,IAAIH,UAAU,EAAE;UACdA,UAAU,CAACK,OAAO,CAACH,CAAC,CAAC;QACvB,CAAC,MAAM;UACLD,QAAQ,CAACK,IAAI,CAACJ,CAAC,CAAC;QAClB;QACA;MACF;MAEA,MAAMK,CAAC,GAAGhF,KAAK,CAAC4E,IAAI,EAAE1E,CAAC,CAAC;MACxB;MACA,IAAI,CAAC8E,CAAC,EAAE;QACN;MACF;;MAEA;MACA;MACA,IAAI,CAACP,UAAU,EAAE;QACfA,UAAU,GAAGG,IAAI;QACjB,KAAK,MAAMD,CAAC,IAAID,QAAQ,EAAE;UACxBD,UAAU,CAACK,OAAO,CAACH,CAAC,CAAC;UACrB,IAAI,CAAC5D,OAAO,CAACqB,GAAG,CAACuC,CAAC,EAAEF,UAAU,CAAC;QACjC;QACAC,QAAQ,CAACnC,MAAM,GAAG,CAAC;QACnB;MACF;;MAEA;MACA;MACAkC,UAAU,CAACK,OAAO,CAACH,CAAC,CAAC;MACrB,IAAI,CAAC5D,OAAO,CAACqB,GAAG,CAACuC,CAAC,EAAEF,UAAU,CAAC;IACjC;;IAEA;IACA,IAAI,CAACA,UAAU,EAAE;MACf,MAAMQ,KAAK,GAAGzF,MAAM,CAACkD,MAAM,CAAC,IAAIT,aAAa,CAACyC,QAAQ,CAAC,EAAExE,CAAC,CAAC;MAC3D,KAAK,MAAMyE,CAAC,IAAID,QAAQ,EAAE;QACxB,IAAI,CAAC3D,OAAO,CAACqB,GAAG,CAACuC,CAAC,EAAEM,KAAK,CAAC;MAC5B;IACF,CAAC,MAAM;MACL;MACA;MACAzF,MAAM,CAACkD,MAAM,CAAC+B,UAAU,EAAEvE,CAAC,CAAC;IAC9B;EACF;EAEAsE,iBAAiBA,CAAEV,IAAI,EAAE;IACvB,MAAM5D,CAAC,GAAG,CAAC,CAAC;IACZ,IAAI4D,IAAI,CAACoB,OAAO,CAACC,YAAY,EAAE;MAC7BjF,CAAC,CAACiF,YAAY,GAAGrB,IAAI,CAACoB,OAAO,CAACC,YAAY;IAC5C;IACA,IAAIrB,IAAI,CAACoB,OAAO,CAACE,oBAAoB,EAAE;MACrClF,CAAC,CAACkF,oBAAoB,GAAGtB,IAAI,CAACoB,OAAO,CAACE,oBAAoB;IAC5D;IACA,IAAItB,IAAI,CAACzD,OAAO,EAAE;MAChBH,CAAC,CAACG,OAAO,GAAGyD,IAAI,CAACzD,OAAO;IAC1B;IACA,IAAIyD,IAAI,CAAC1D,QAAQ,EAAE;MACjBF,CAAC,CAACE,QAAQ,GAAGjB,iBAAiB,CAC5B2E,IAAI,CAAC1D,QAAQ,EACb0D,IAAI,CAACuB,MAAM,GAAGjG,OAAO,CAAC0E,IAAI,CAACwB,IAAI,CAAC,GAAGxB,IAAI,CAACwB,IAAI,EAC5CxB,IAAI,CAACyB,IAAI,CAACD,IAAI,EACd,IACF,CAAC;IACH;IACA,IAAIxB,IAAI,CAAC3D,SAAS,EAAE;MAClBD,CAAC,CAACC,SAAS,GAAG2D,IAAI,CAAC3D,SAAS;IAC9B;IAEA,OAAOD,CAAC;EACV;EAEA,WAAWsF,KAAKA,CAAA,EAAI;IAClB,OAAOvD,aAAa;EACtB;AACF;AAEA,MAAMwD,MAAM,GAAGjF,MAAM,CAAC,QAAQ,CAAC;AAC/B,MAAMyB,aAAa,CAAC;EAClBnB,WAAWA,CAAEgB,KAAK,EAAE;IAClB,IAAI,CAAC2D,MAAM,CAAC,GAAG,IAAI/B,GAAG,CAAC5B,KAAK,CAAC;IAC7B,IAAI,CAAC1B,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,OAAO,GAAG,IAAI;IACnB,IAAI,CAACF,SAAS,GAAG,IAAI;IACrB,IAAI,CAACgF,YAAY,GAAG,IAAI;IACxB,IAAI,CAACC,oBAAoB,GAAG,IAAI;EAClC;EAEA3B,QAAQA,CAAA,EAAI;IACV;IACA,OAAO,CAAC,CAAC,GAAG,IAAI,CAACgC,MAAM,CAAC,CAAC,CACtB/F,IAAI,CAACT,aAAa,CAAC,CACnBU,GAAG,CAACE,IAAI,CAACC,SAAS,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,GAC/B,KAAK,GACLP,MAAM,CAACkG,mBAAmB,CAAC,IAAI,CAAC,CAC7BC,MAAM,CAACC,IAAI,IAAI,IAAI,CAACA,IAAI,CAAC,KAAK,IAAI,CAAC,CACnClG,IAAI,CACH,CAACyE,CAAC,EAAEC,CAAC,KACL;IACG,OAAO,IAAI,CAACD,CAAC,CAAC,KAAK,QAAQ,MAAO,OAAO,IAAI,CAACC,CAAC,CAAC,KAAK,QAAQ,CAAC,GAC3DnF,aAAa,CAACkF,CAAC,EAAEC,CAAC,CAAC,GACnB,OAAO,IAAI,CAACD,CAAC,CAAC,KAAK,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAC5CxE,GAAG,CAACiG,IAAI,IACP,OAAO,IAAI,CAACA,IAAI,CAAC,KAAK,QAAQ,GAC1B,KAAK/F,IAAI,CAACC,SAAS,CAAC8F,IAAI,CAAC,IAAI/F,IAAI,CAACC,SAAS,CAAC,IAAI,CAAC8F,IAAI,CAAC,CAAC,IAAI,GAC3DpG,MAAM,CAACC,IAAI,CAAC,IAAI,CAACmG,IAAI,CAAC,CAAC,CAACrD,MAAM,KAAK,CAAC,GAAG,EAAE,GACzC,KAAKqD,IAAI,KAAK,GAAGtG,MAAM,CAAC,IAAI,CAACsG,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAChD7F,IAAI,CAAC,EAAE,CAAC,EAAEuD,IAAI,CAAC,CAAC;EACvB;EAEAwB,OAAOA,CAAE3C,IAAI,EAAE;IACb,IAAI,CAACsD,MAAM,CAAC,CAACI,GAAG,CAAC1D,IAAI,CAAC;EACxB;AACF;AAEA2D,MAAM,CAACC,OAAO,GAAGtF,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}