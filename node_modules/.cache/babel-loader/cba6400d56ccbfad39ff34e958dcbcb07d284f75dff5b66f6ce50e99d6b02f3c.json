{"ast":null,"code":"// a class to manage an inventory and set of indexes of\n// a set of objects based on specific fields.\n// primary is the primary index key.\n// keys is the set of fields to be able to query.\nconst _primaryKey = Symbol('_primaryKey');\nconst _index = Symbol('_index');\nconst defaultKeys = ['name', 'license', 'funding', 'realpath', 'packageName'];\nconst {\n  hasOwnProperty\n} = Object.prototype;\nconst debug = require('./debug.js');\n\n// handling for the outdated \"licenses\" array, just pick the first one\n// also support the alternative spelling \"licence\"\nconst getLicense = pkg => {\n  if (pkg) {\n    const lic = pkg.license || pkg.licence;\n    if (lic) {\n      return lic;\n    }\n    const lics = pkg.licenses || pkg.licences;\n    if (Array.isArray(lics)) {\n      return lics[0];\n    }\n  }\n};\nclass Inventory extends Map {\n  constructor(opt = {}) {\n    const {\n      primary,\n      keys\n    } = opt;\n    super();\n    this[_primaryKey] = primary || 'location';\n    this[_index] = (keys || defaultKeys).reduce((index, i) => {\n      index.set(i, new Map());\n      return index;\n    }, new Map());\n  }\n  get primaryKey() {\n    return this[_primaryKey];\n  }\n  get indexes() {\n    return [...this[_index].keys()];\n  }\n  *filter(fn) {\n    for (const node of this.values()) {\n      if (fn(node)) {\n        yield node;\n      }\n    }\n  }\n  add(node) {\n    const root = super.get('');\n    if (root && node.root !== root && node.root !== root.root) {\n      debug(() => {\n        throw Object.assign(new Error('adding external node to inventory'), {\n          root: root.path,\n          node: node.path,\n          nodeRoot: node.root.path\n        });\n      });\n      return;\n    }\n    const current = super.get(node[this.primaryKey]);\n    if (current) {\n      if (current === node) {\n        return;\n      }\n      this.delete(current);\n    }\n    super.set(node[this.primaryKey], node);\n    for (const [key, map] of this[_index].entries()) {\n      // if the node has the value, but it's false, then use that\n      const val_ = hasOwnProperty.call(node, key) ? node[key] : key === 'license' ? getLicense(node.package) : node[key] ? node[key] : node.package && node.package[key];\n      const val = typeof val_ === 'string' ? val_ : !val_ || typeof val_ !== 'object' ? val_ : key === 'license' ? val_.type : key === 'funding' ? val_.url : /* istanbul ignore next - not used */val_;\n      const set = map.get(val) || new Set();\n      set.add(node);\n      map.set(val, set);\n    }\n  }\n  delete(node) {\n    if (!this.has(node)) {\n      return;\n    }\n    super.delete(node[this.primaryKey]);\n    for (const [key, map] of this[_index].entries()) {\n      const val = node[key] !== undefined ? node[key] : node[key] || node.package && node.package[key];\n      const set = map.get(val);\n      if (set) {\n        set.delete(node);\n        if (set.size === 0) {\n          map.delete(node[key]);\n        }\n      }\n    }\n  }\n  query(key, val) {\n    const map = this[_index].get(key);\n    return map && (arguments.length === 2 ? map.get(val) : map.keys()) || new Set();\n  }\n  has(node) {\n    return super.get(node[this.primaryKey]) === node;\n  }\n  set(k, v) {\n    throw new Error('direct set() not supported, use inventory.add(node)');\n  }\n}\nmodule.exports = Inventory;","map":{"version":3,"names":["_primaryKey","Symbol","_index","defaultKeys","hasOwnProperty","Object","prototype","debug","require","getLicense","pkg","lic","license","licence","lics","licenses","licences","Array","isArray","Inventory","Map","constructor","opt","primary","keys","reduce","index","i","set","primaryKey","indexes","filter","fn","node","values","add","root","get","assign","Error","path","nodeRoot","current","delete","key","map","entries","val_","call","package","val","type","url","Set","has","undefined","size","query","arguments","length","k","v","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/inventory.js"],"sourcesContent":["// a class to manage an inventory and set of indexes of\n// a set of objects based on specific fields.\n// primary is the primary index key.\n// keys is the set of fields to be able to query.\nconst _primaryKey = Symbol('_primaryKey')\nconst _index = Symbol('_index')\nconst defaultKeys = ['name', 'license', 'funding', 'realpath', 'packageName']\nconst { hasOwnProperty } = Object.prototype\nconst debug = require('./debug.js')\n\n// handling for the outdated \"licenses\" array, just pick the first one\n// also support the alternative spelling \"licence\"\nconst getLicense = pkg => {\n  if (pkg) {\n    const lic = pkg.license || pkg.licence\n    if (lic) {\n      return lic\n    }\n    const lics = pkg.licenses || pkg.licences\n    if (Array.isArray(lics)) {\n      return lics[0]\n    }\n  }\n}\n\nclass Inventory extends Map {\n  constructor (opt = {}) {\n    const { primary, keys } = opt\n    super()\n    this[_primaryKey] = primary || 'location'\n    this[_index] = (keys || defaultKeys).reduce((index, i) => {\n      index.set(i, new Map())\n      return index\n    }, new Map())\n  }\n\n  get primaryKey () {\n    return this[_primaryKey]\n  }\n\n  get indexes () {\n    return [...this[_index].keys()]\n  }\n\n  * filter (fn) {\n    for (const node of this.values()) {\n      if (fn(node)) {\n        yield node\n      }\n    }\n  }\n\n  add (node) {\n    const root = super.get('')\n    if (root && node.root !== root && node.root !== root.root) {\n      debug(() => {\n        throw Object.assign(new Error('adding external node to inventory'), {\n          root: root.path,\n          node: node.path,\n          nodeRoot: node.root.path,\n        })\n      })\n      return\n    }\n\n    const current = super.get(node[this.primaryKey])\n    if (current) {\n      if (current === node) {\n        return\n      }\n      this.delete(current)\n    }\n    super.set(node[this.primaryKey], node)\n    for (const [key, map] of this[_index].entries()) {\n      // if the node has the value, but it's false, then use that\n      const val_ = hasOwnProperty.call(node, key) ? node[key]\n        : key === 'license' ? getLicense(node.package)\n        : node[key] ? node[key]\n        : node.package && node.package[key]\n      const val = typeof val_ === 'string' ? val_\n        : !val_ || typeof val_ !== 'object' ? val_\n        : key === 'license' ? val_.type\n        : key === 'funding' ? val_.url\n        : /* istanbul ignore next - not used */ val_\n      const set = map.get(val) || new Set()\n      set.add(node)\n      map.set(val, set)\n    }\n  }\n\n  delete (node) {\n    if (!this.has(node)) {\n      return\n    }\n\n    super.delete(node[this.primaryKey])\n    for (const [key, map] of this[_index].entries()) {\n      const val = node[key] !== undefined ? node[key]\n        : (node[key] || (node.package && node.package[key]))\n      const set = map.get(val)\n      if (set) {\n        set.delete(node)\n        if (set.size === 0) {\n          map.delete(node[key])\n        }\n      }\n    }\n  }\n\n  query (key, val) {\n    const map = this[_index].get(key)\n    return map && (arguments.length === 2 ? map.get(val) : map.keys()) ||\n      new Set()\n  }\n\n  has (node) {\n    return super.get(node[this.primaryKey]) === node\n  }\n\n  set (k, v) {\n    throw new Error('direct set() not supported, use inventory.add(node)')\n  }\n}\n\nmodule.exports = Inventory\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}