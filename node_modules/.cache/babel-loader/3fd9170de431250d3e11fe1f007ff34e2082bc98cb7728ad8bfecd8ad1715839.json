{"ast":null,"code":"const debug = require('./debug.js');\nconst checkTree = (tree, checkUnreachable = true) => {\n  const log = [['START TREE CHECK', tree.path]];\n\n  // this can only happen in tests where we have a \"tree\" object\n  // that isn't actually a tree.\n  if (!tree.root || !tree.root.inventory) {\n    return tree;\n  }\n  const {\n    inventory\n  } = tree.root;\n  const seen = new Set();\n  const check = (node, via = tree, viaType = 'self') => {\n    log.push(['CHECK', node && node.location, via && via.location, viaType, 'seen=' + seen.has(node), 'promise=' + !!(node && node.then), 'root=' + !!(node && node.isRoot)]);\n    if (!node || seen.has(node) || node.then) {\n      return;\n    }\n    seen.add(node);\n    if (node.isRoot && node !== tree.root) {\n      throw Object.assign(new Error('double root'), {\n        node: node.path,\n        realpath: node.realpath,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log\n      });\n    }\n    if (node.root !== tree.root) {\n      throw Object.assign(new Error('node from other root in tree'), {\n        node: node.path,\n        realpath: node.realpath,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        otherRoot: node.root && node.root.path,\n        log\n      });\n    }\n    if (!node.isRoot && node.inventory.size !== 0) {\n      throw Object.assign(new Error('non-root has non-zero inventory'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        inventory: [...node.inventory.values()].map(node => [node.path, node.location]),\n        log\n      });\n    }\n    if (!node.isRoot && !inventory.has(node) && !node.dummy) {\n      throw Object.assign(new Error('not in inventory'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log\n      });\n    }\n    const devEdges = [...node.edgesOut.values()].filter(e => e.dev);\n    if (!node.isTop && devEdges.length) {\n      throw Object.assign(new Error('dev edges on non-top node'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        devEdges: devEdges.map(e => [e.type, e.name, e.spec, e.error]),\n        log\n      });\n    }\n    if (node.path === tree.root.path && node !== tree.root) {\n      throw Object.assign(new Error('node with same path as root'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log\n      });\n    }\n    if (!node.isLink && node.path !== node.realpath) {\n      throw Object.assign(new Error('non-link with mismatched path/realpath'), {\n        node: node.path,\n        tree: tree.path,\n        realpath: node.realpath,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log\n      });\n    }\n    const {\n      parent,\n      fsParent,\n      target\n    } = node;\n    check(parent, node, 'parent');\n    check(fsParent, node, 'fsParent');\n    check(target, node, 'target');\n    log.push(['CHILDREN', node.location, ...node.children.keys()]);\n    for (const kid of node.children.values()) {\n      check(kid, node, 'children');\n    }\n    for (const kid of node.fsChildren) {\n      check(kid, node, 'fsChildren');\n    }\n    for (const link of node.linksIn) {\n      check(link, node, 'linksIn');\n    }\n    for (const top of node.tops) {\n      check(top, node, 'tops');\n    }\n    log.push(['DONE', node.location]);\n  };\n  check(tree);\n  if (checkUnreachable) {\n    for (const node of inventory.values()) {\n      if (!seen.has(node) && node !== tree.root) {\n        throw Object.assign(new Error('unreachable in inventory'), {\n          node: node.path,\n          realpath: node.realpath,\n          location: node.location,\n          root: tree.root.path,\n          tree: tree.path,\n          log\n        });\n      }\n    }\n  }\n  return tree;\n};\n\n// should only ever run this check in debug mode\nmodule.exports = tree => tree;\ndebug(() => module.exports = checkTree);","map":{"version":3,"names":["debug","require","checkTree","tree","checkUnreachable","log","path","root","inventory","seen","Set","check","node","via","viaType","push","location","has","then","isRoot","add","Object","assign","Error","realpath","otherRoot","size","values","map","dummy","devEdges","edgesOut","filter","e","dev","isTop","length","type","name","spec","error","isLink","parent","fsParent","target","children","keys","kid","fsChildren","link","linksIn","top","tops","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/tree-check.js"],"sourcesContent":["const debug = require('./debug.js')\n\nconst checkTree = (tree, checkUnreachable = true) => {\n  const log = [['START TREE CHECK', tree.path]]\n\n  // this can only happen in tests where we have a \"tree\" object\n  // that isn't actually a tree.\n  if (!tree.root || !tree.root.inventory) {\n    return tree\n  }\n\n  const { inventory } = tree.root\n  const seen = new Set()\n  const check = (node, via = tree, viaType = 'self') => {\n    log.push([\n      'CHECK',\n      node && node.location,\n      via && via.location,\n      viaType,\n      'seen=' + seen.has(node),\n      'promise=' + !!(node && node.then),\n      'root=' + !!(node && node.isRoot),\n    ])\n\n    if (!node || seen.has(node) || node.then) {\n      return\n    }\n\n    seen.add(node)\n\n    if (node.isRoot && node !== tree.root) {\n      throw Object.assign(new Error('double root'), {\n        node: node.path,\n        realpath: node.realpath,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log,\n      })\n    }\n\n    if (node.root !== tree.root) {\n      throw Object.assign(new Error('node from other root in tree'), {\n        node: node.path,\n        realpath: node.realpath,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        otherRoot: node.root && node.root.path,\n        log,\n      })\n    }\n\n    if (!node.isRoot && node.inventory.size !== 0) {\n      throw Object.assign(new Error('non-root has non-zero inventory'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        inventory: [...node.inventory.values()].map(node =>\n          [node.path, node.location]),\n        log,\n      })\n    }\n\n    if (!node.isRoot && !inventory.has(node) && !node.dummy) {\n      throw Object.assign(new Error('not in inventory'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log,\n      })\n    }\n\n    const devEdges = [...node.edgesOut.values()].filter(e => e.dev)\n    if (!node.isTop && devEdges.length) {\n      throw Object.assign(new Error('dev edges on non-top node'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        devEdges: devEdges.map(e => [e.type, e.name, e.spec, e.error]),\n        log,\n      })\n    }\n\n    if (node.path === tree.root.path && node !== tree.root) {\n      throw Object.assign(new Error('node with same path as root'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log,\n      })\n    }\n\n    if (!node.isLink && node.path !== node.realpath) {\n      throw Object.assign(new Error('non-link with mismatched path/realpath'), {\n        node: node.path,\n        tree: tree.path,\n        realpath: node.realpath,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log,\n      })\n    }\n\n    const { parent, fsParent, target } = node\n    check(parent, node, 'parent')\n    check(fsParent, node, 'fsParent')\n    check(target, node, 'target')\n    log.push(['CHILDREN', node.location, ...node.children.keys()])\n    for (const kid of node.children.values()) {\n      check(kid, node, 'children')\n    }\n    for (const kid of node.fsChildren) {\n      check(kid, node, 'fsChildren')\n    }\n    for (const link of node.linksIn) {\n      check(link, node, 'linksIn')\n    }\n    for (const top of node.tops) {\n      check(top, node, 'tops')\n    }\n    log.push(['DONE', node.location])\n  }\n  check(tree)\n  if (checkUnreachable) {\n    for (const node of inventory.values()) {\n      if (!seen.has(node) && node !== tree.root) {\n        throw Object.assign(new Error('unreachable in inventory'), {\n          node: node.path,\n          realpath: node.realpath,\n          location: node.location,\n          root: tree.root.path,\n          tree: tree.path,\n          log,\n        })\n      }\n    }\n  }\n  return tree\n}\n\n// should only ever run this check in debug mode\nmodule.exports = tree => tree\ndebug(() => module.exports = checkTree)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}