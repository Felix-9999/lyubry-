{"ast":null,"code":"// Internal methods used by buildIdealTree.\n// Answer the question: \"can I put this dep here?\"\n//\n// IMPORTANT: *nothing* in this class should *ever* modify or mutate the tree\n// at all.  The contract here is strictly limited to read operations.  We call\n// this in the process of walking through the ideal tree checking many\n// different potential placement targets for a given node.  If a change is made\n// to the tree along the way, that can cause serious problems!\n//\n// In order to enforce this restriction, in debug mode, canPlaceDep() will\n// snapshot the tree at the start of the process, and then at the end, will\n// verify that it still matches the snapshot, and throw an error if any changes\n// occurred.\n//\n// The algorithm is roughly like this:\n// - check the node itself:\n//   - if there is no version present, and no conflicting edges from target,\n//     OK, provided all peers can be placed at or above the target.\n//   - if the current version matches, KEEP\n//   - if there is an older version present, which can be replaced, then\n//     - if satisfying and preferDedupe? KEEP\n//     - else: REPLACE\n//   - if there is a newer version present, and preferDedupe, REPLACE\n//   - if the version present satisfies the edge, KEEP\n//   - else: CONFLICT\n// - if the node is not in conflict, check each of its peers:\n//   - if the peer can be placed in the target, continue\n//   - else if the peer can be placed in a parent, and there is no other\n//     conflicting version shadowing it, continue\n//   - else CONFLICT\n// - If the peers are not in conflict, return the original node's value\n//\n// An exception to this logic is that if the target is the deepest location\n// that a node can be placed, and the conflicting node can be placed deeper,\n// then we will return REPLACE rather than CONFLICT, and Arborist will queue\n// the replaced node for resolution elsewhere.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\nconst semver = require('semver');\nconst debug = require('./debug.js');\nconst peerEntrySets = require('./peer-entry-sets.js');\nconst deepestNestingTarget = require('./deepest-nesting-target.js');\nconst CONFLICT = Symbol('CONFLICT');\nconst OK = Symbol('OK');\nconst REPLACE = Symbol('REPLACE');\nconst KEEP = Symbol('KEEP');\nclass CanPlaceDep {\n  // dep is a dep that we're trying to place.  it should already live in\n  // a virtual tree where its peer set is loaded as children of the root.\n  // target is the actual place where we're trying to place this dep\n  // in a node_modules folder.\n  // edge is the edge that we're trying to satisfy with this placement.\n  // parent is the CanPlaceDep object of the entry node when placing a peer.\n  constructor(options) {\n    const {\n      dep,\n      target,\n      edge,\n      preferDedupe,\n      parent = null,\n      peerPath = [],\n      explicitRequest = false\n    } = options;\n    debug(() => {\n      if (!dep) {\n        throw new Error('no dep provided to CanPlaceDep');\n      }\n      if (!target) {\n        throw new Error('no target provided to CanPlaceDep');\n      }\n      if (!edge) {\n        throw new Error('no edge provided to CanPlaceDep');\n      }\n      this._treeSnapshot = JSON.stringify([...target.root.inventory.entries()].map(([loc, {\n        packageName,\n        version,\n        resolved\n      }]) => {\n        return [loc, packageName, version, resolved];\n      }).sort(([a], [b]) => localeCompare(a, b)));\n    });\n\n    // the result of whether we can place it or not\n    this.canPlace = null;\n    // if peers conflict, but this one doesn't, then that is useful info\n    this.canPlaceSelf = null;\n    this.dep = dep;\n    this.target = target;\n    this.edge = edge;\n    this.explicitRequest = explicitRequest;\n\n    // preventing cycles when we check peer sets\n    this.peerPath = peerPath;\n    // we always prefer to dedupe peers, because they are trying\n    // a bit harder to be singletons.\n    this.preferDedupe = !!preferDedupe || edge.peer;\n    this.parent = parent;\n    this.children = [];\n    this.isSource = target === this.peerSetSource;\n    this.name = edge.name;\n    this.current = target.children.get(this.name);\n    this.targetEdge = target.edgesOut.get(this.name);\n    this.conflicts = new Map();\n\n    // check if this dep was already subject to a peerDep override while\n    // building the peerSet.\n    this.edgeOverride = !dep.satisfies(edge);\n    this.canPlace = this.checkCanPlace();\n    if (!this.canPlaceSelf) {\n      this.canPlaceSelf = this.canPlace;\n    }\n    debug(() => {\n      const treeSnapshot = JSON.stringify([...target.root.inventory.entries()].map(([loc, {\n        packageName,\n        version,\n        resolved\n      }]) => {\n        return [loc, packageName, version, resolved];\n      }).sort(([a], [b]) => localeCompare(a, b)));\n      /* istanbul ignore if */\n      if (this._treeSnapshot !== treeSnapshot) {\n        throw Object.assign(new Error('tree changed in CanPlaceDep'), {\n          expect: this._treeSnapshot,\n          actual: treeSnapshot\n        });\n      }\n    });\n  }\n  checkCanPlace() {\n    const {\n      target,\n      targetEdge,\n      current,\n      dep\n    } = this;\n\n    // if the dep failed to load, we're going to fail the build or\n    // prune it out anyway, so just move forward placing/replacing it.\n    if (dep.errors.length) {\n      return current ? REPLACE : OK;\n    }\n\n    // cannot place peers inside their dependents, except for tops\n    if (targetEdge && targetEdge.peer && !target.isTop) {\n      return CONFLICT;\n    }\n    if (targetEdge && !dep.satisfies(targetEdge) && targetEdge !== this.edge) {\n      return CONFLICT;\n    }\n    return current ? this.checkCanPlaceCurrent() : this.checkCanPlaceNoCurrent();\n  }\n\n  // we know that the target has a dep by this name in its node_modules\n  // already.  Can return KEEP, REPLACE, or CONFLICT.\n  checkCanPlaceCurrent() {\n    const {\n      preferDedupe,\n      explicitRequest,\n      current,\n      target,\n      edge,\n      dep\n    } = this;\n    if (dep.matches(current)) {\n      if (current.satisfies(edge) || this.edgeOverride) {\n        return explicitRequest ? REPLACE : KEEP;\n      }\n    }\n    const {\n      version: curVer\n    } = current;\n    const {\n      version: newVer\n    } = dep;\n    const tryReplace = curVer && newVer && semver.gte(newVer, curVer);\n    if (tryReplace && dep.canReplace(current)) {\n      /* XXX-istanbul ignore else - It's extremely rare that a replaceable\n       * node would be a conflict, if the current one wasn't a conflict,\n       * but it is theoretically possible if peer deps are pinned.  In\n       * that case we treat it like any other conflict, and keep trying */\n      const cpp = this.canPlacePeers(REPLACE);\n      if (cpp !== CONFLICT) {\n        return cpp;\n      }\n    }\n\n    // ok, can't replace the current with new one, but maybe current is ok?\n    if (current.satisfies(edge) && (!explicitRequest || preferDedupe)) {\n      return KEEP;\n    }\n\n    // if we prefer deduping, then try replacing newer with older\n    if (preferDedupe && !tryReplace && dep.canReplace(current)) {\n      const cpp = this.canPlacePeers(REPLACE);\n      if (cpp !== CONFLICT) {\n        return cpp;\n      }\n    }\n\n    // Check for interesting cases!\n    // First, is this the deepest place that this thing can go, and NOT the\n    // deepest place where the conflicting dep can go?  If so, replace it,\n    // and let it re-resolve deeper in the tree.\n    const myDeepest = this.deepestNestingTarget;\n\n    // ok, i COULD be placed deeper, so leave the current one alone.\n    if (target !== myDeepest) {\n      return CONFLICT;\n    }\n\n    // if we are not checking a peerDep, then we MUST place it here, in the\n    // target that has a non-peer dep on it.\n    if (!edge.peer && target === edge.from) {\n      return this.canPlacePeers(REPLACE);\n    }\n\n    // if we aren't placing a peer in a set, then we're done here.\n    // This is ignored because it SHOULD be redundant, as far as I can tell,\n    // with the deepest target and target===edge.from tests.  But until we\n    // can prove that isn't possible, this condition is here for safety.\n    /* istanbul ignore if - allegedly impossible */\n    if (!this.parent && !edge.peer) {\n      return CONFLICT;\n    }\n\n    // check the deps in the peer group for each edge into that peer group\n    // if ALL of them can be pushed deeper, or if it's ok to replace its\n    // members with the contents of the new peer group, then we're good.\n    let canReplace = true;\n    for (const [entryEdge, currentPeers] of peerEntrySets(current)) {\n      if (entryEdge === this.edge || entryEdge === this.peerEntryEdge) {\n        continue;\n      }\n\n      // First, see if it's ok to just replace the peerSet entirely.\n      // we do this by walking out from the entryEdge, because in a case like\n      // this:\n      //\n      // v -> PEER(a@1||2)\n      // a@1 -> PEER(b@1)\n      // a@2 -> PEER(b@2)\n      // b@1 -> PEER(a@1)\n      // b@2 -> PEER(a@2)\n      //\n      // root\n      // +-- v\n      // +-- a@2\n      // +-- b@2\n      //\n      // Trying to place a peer group of (a@1, b@1) would fail to note that\n      // they can be replaced, if we did it by looping 1 by 1.  If we are\n      // replacing something, we don't have to check its peer deps, because\n      // the peerDeps in the placed peerSet will presumably satisfy.\n      const entryNode = entryEdge.to;\n      const entryRep = dep.parent.children.get(entryNode.name);\n      if (entryRep) {\n        if (entryRep.canReplace(entryNode, dep.parent.children.keys())) {\n          continue;\n        }\n      }\n      let canClobber = !entryRep;\n      if (!entryRep) {\n        const peerReplacementWalk = new Set([entryNode]);\n        OUTER: for (const currentPeer of peerReplacementWalk) {\n          for (const edge of currentPeer.edgesOut.values()) {\n            if (!edge.peer || !edge.valid) {\n              continue;\n            }\n            const rep = dep.parent.children.get(edge.name);\n            if (!rep) {\n              if (edge.to) {\n                peerReplacementWalk.add(edge.to);\n              }\n              continue;\n            }\n            if (!rep.satisfies(edge)) {\n              canClobber = false;\n              break OUTER;\n            }\n          }\n        }\n      }\n      if (canClobber) {\n        continue;\n      }\n\n      // ok, we can't replace, but maybe we can nest the current set deeper?\n      let canNestCurrent = true;\n      for (const currentPeer of currentPeers) {\n        if (!canNestCurrent) {\n          break;\n        }\n\n        // still possible to nest this peerSet\n        const curDeep = deepestNestingTarget(entryEdge.from, currentPeer.name);\n        if (curDeep === target || target.isDescendantOf(curDeep)) {\n          canNestCurrent = false;\n          canReplace = false;\n        }\n        if (canNestCurrent) {\n          continue;\n        }\n      }\n    }\n\n    // if we can nest or replace all the current peer groups, we can replace.\n    if (canReplace) {\n      return this.canPlacePeers(REPLACE);\n    }\n    return CONFLICT;\n  }\n  checkCanPlaceNoCurrent() {\n    const {\n      target,\n      peerEntryEdge,\n      dep,\n      name\n    } = this;\n\n    // check to see what that name resolves to here, and who may depend on\n    // being able to reach it by crawling up past the parent.  we know\n    // that it's not the target's direct child node, and if it was a direct\n    // dep of the target, we would have conflicted earlier.\n    const current = target !== peerEntryEdge.from && target.resolve(name);\n    if (current) {\n      for (const edge of current.edgesIn.values()) {\n        if (edge.from.isDescendantOf(target) && edge.valid) {\n          if (!dep.satisfies(edge)) {\n            return CONFLICT;\n          }\n        }\n      }\n    }\n\n    // no objections, so this is fine as long as peers are ok here.\n    return this.canPlacePeers(OK);\n  }\n  get deepestNestingTarget() {\n    const start = this.parent ? this.parent.deepestNestingTarget : this.edge.from;\n    return deepestNestingTarget(start, this.name);\n  }\n  get conflictChildren() {\n    return this.allChildren.filter(c => c.canPlace === CONFLICT);\n  }\n  get allChildren() {\n    const set = new Set(this.children);\n    for (const child of set) {\n      for (const grandchild of child.children) {\n        set.add(grandchild);\n      }\n    }\n    return [...set];\n  }\n  get top() {\n    return this.parent ? this.parent.top : this;\n  }\n\n  // check if peers can go here.  returns state or CONFLICT\n  canPlacePeers(state) {\n    this.canPlaceSelf = state;\n    if (this._canPlacePeers) {\n      return this._canPlacePeers;\n    }\n\n    // TODO: represent peerPath in ERESOLVE error somehow?\n    const peerPath = [...this.peerPath, this.dep];\n    let sawConflict = false;\n    for (const peerEdge of this.dep.edgesOut.values()) {\n      if (!peerEdge.peer || !peerEdge.to || peerPath.includes(peerEdge.to)) {\n        continue;\n      }\n      const peer = peerEdge.to;\n      // it may be the case that the *initial* dep can be nested, but a peer\n      // of that dep needs to be placed shallower, because the target has\n      // a peer dep on the peer as well.\n      const target = deepestNestingTarget(this.target, peer.name);\n      const cpp = new CanPlaceDep({\n        dep: peer,\n        target,\n        parent: this,\n        edge: peerEdge,\n        peerPath,\n        // always place peers in preferDedupe mode\n        preferDedupe: true\n      });\n      /* istanbul ignore next */\n      debug(() => {\n        if (this.children.some(c => c.dep === cpp.dep)) {\n          throw new Error('checking same dep repeatedly');\n        }\n      });\n      this.children.push(cpp);\n      if (cpp.canPlace === CONFLICT) {\n        sawConflict = true;\n      }\n    }\n    this._canPlacePeers = sawConflict ? CONFLICT : state;\n    return this._canPlacePeers;\n  }\n\n  // what is the node that is causing this peerSet to be placed?\n  get peerSetSource() {\n    return this.parent ? this.parent.peerSetSource : this.edge.from;\n  }\n  get peerEntryEdge() {\n    return this.top.edge;\n  }\n  static get CONFLICT() {\n    return CONFLICT;\n  }\n  static get OK() {\n    return OK;\n  }\n  static get REPLACE() {\n    return REPLACE;\n  }\n  static get KEEP() {\n    return KEEP;\n  }\n  get description() {\n    const {\n      canPlace\n    } = this;\n    return canPlace && canPlace.description || /* istanbul ignore next - old node affordance */canPlace;\n  }\n}\nmodule.exports = CanPlaceDep;","map":{"version":3,"names":["localeCompare","require","semver","debug","peerEntrySets","deepestNestingTarget","CONFLICT","Symbol","OK","REPLACE","KEEP","CanPlaceDep","constructor","options","dep","target","edge","preferDedupe","parent","peerPath","explicitRequest","Error","_treeSnapshot","JSON","stringify","root","inventory","entries","map","loc","packageName","version","resolved","sort","a","b","canPlace","canPlaceSelf","peer","children","isSource","peerSetSource","name","current","get","targetEdge","edgesOut","conflicts","Map","edgeOverride","satisfies","checkCanPlace","treeSnapshot","Object","assign","expect","actual","errors","length","isTop","checkCanPlaceCurrent","checkCanPlaceNoCurrent","matches","curVer","newVer","tryReplace","gte","canReplace","cpp","canPlacePeers","myDeepest","from","entryEdge","currentPeers","peerEntryEdge","entryNode","to","entryRep","keys","canClobber","peerReplacementWalk","Set","OUTER","currentPeer","values","valid","rep","add","canNestCurrent","curDeep","isDescendantOf","resolve","edgesIn","start","conflictChildren","allChildren","filter","c","set","child","grandchild","top","state","_canPlacePeers","sawConflict","peerEdge","includes","some","push","description","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/can-place-dep.js"],"sourcesContent":["// Internal methods used by buildIdealTree.\n// Answer the question: \"can I put this dep here?\"\n//\n// IMPORTANT: *nothing* in this class should *ever* modify or mutate the tree\n// at all.  The contract here is strictly limited to read operations.  We call\n// this in the process of walking through the ideal tree checking many\n// different potential placement targets for a given node.  If a change is made\n// to the tree along the way, that can cause serious problems!\n//\n// In order to enforce this restriction, in debug mode, canPlaceDep() will\n// snapshot the tree at the start of the process, and then at the end, will\n// verify that it still matches the snapshot, and throw an error if any changes\n// occurred.\n//\n// The algorithm is roughly like this:\n// - check the node itself:\n//   - if there is no version present, and no conflicting edges from target,\n//     OK, provided all peers can be placed at or above the target.\n//   - if the current version matches, KEEP\n//   - if there is an older version present, which can be replaced, then\n//     - if satisfying and preferDedupe? KEEP\n//     - else: REPLACE\n//   - if there is a newer version present, and preferDedupe, REPLACE\n//   - if the version present satisfies the edge, KEEP\n//   - else: CONFLICT\n// - if the node is not in conflict, check each of its peers:\n//   - if the peer can be placed in the target, continue\n//   - else if the peer can be placed in a parent, and there is no other\n//     conflicting version shadowing it, continue\n//   - else CONFLICT\n// - If the peers are not in conflict, return the original node's value\n//\n// An exception to this logic is that if the target is the deepest location\n// that a node can be placed, and the conflicting node can be placed deeper,\n// then we will return REPLACE rather than CONFLICT, and Arborist will queue\n// the replaced node for resolution elsewhere.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst semver = require('semver')\nconst debug = require('./debug.js')\nconst peerEntrySets = require('./peer-entry-sets.js')\nconst deepestNestingTarget = require('./deepest-nesting-target.js')\n\nconst CONFLICT = Symbol('CONFLICT')\nconst OK = Symbol('OK')\nconst REPLACE = Symbol('REPLACE')\nconst KEEP = Symbol('KEEP')\n\nclass CanPlaceDep {\n  // dep is a dep that we're trying to place.  it should already live in\n  // a virtual tree where its peer set is loaded as children of the root.\n  // target is the actual place where we're trying to place this dep\n  // in a node_modules folder.\n  // edge is the edge that we're trying to satisfy with this placement.\n  // parent is the CanPlaceDep object of the entry node when placing a peer.\n  constructor (options) {\n    const {\n      dep,\n      target,\n      edge,\n      preferDedupe,\n      parent = null,\n      peerPath = [],\n      explicitRequest = false,\n    } = options\n\n    debug(() => {\n      if (!dep) {\n        throw new Error('no dep provided to CanPlaceDep')\n      }\n\n      if (!target) {\n        throw new Error('no target provided to CanPlaceDep')\n      }\n\n      if (!edge) {\n        throw new Error('no edge provided to CanPlaceDep')\n      }\n\n      this._treeSnapshot = JSON.stringify([...target.root.inventory.entries()]\n        .map(([loc, {packageName, version, resolved}]) => {\n          return [loc, packageName, version, resolved]\n        }).sort(([a], [b]) => localeCompare(a, b)))\n    })\n\n    // the result of whether we can place it or not\n    this.canPlace = null\n    // if peers conflict, but this one doesn't, then that is useful info\n    this.canPlaceSelf = null\n\n    this.dep = dep\n    this.target = target\n    this.edge = edge\n    this.explicitRequest = explicitRequest\n\n    // preventing cycles when we check peer sets\n    this.peerPath = peerPath\n    // we always prefer to dedupe peers, because they are trying\n    // a bit harder to be singletons.\n    this.preferDedupe = !!preferDedupe || edge.peer\n    this.parent = parent\n    this.children = []\n\n    this.isSource = target === this.peerSetSource\n    this.name = edge.name\n    this.current = target.children.get(this.name)\n    this.targetEdge = target.edgesOut.get(this.name)\n    this.conflicts = new Map()\n\n    // check if this dep was already subject to a peerDep override while\n    // building the peerSet.\n    this.edgeOverride = !dep.satisfies(edge)\n\n    this.canPlace = this.checkCanPlace()\n    if (!this.canPlaceSelf) {\n      this.canPlaceSelf = this.canPlace\n    }\n\n    debug(() => {\n      const treeSnapshot = JSON.stringify([...target.root.inventory.entries()]\n        .map(([loc, {packageName, version, resolved}]) => {\n          return [loc, packageName, version, resolved]\n        }).sort(([a], [b]) => localeCompare(a, b)))\n      /* istanbul ignore if */\n      if (this._treeSnapshot !== treeSnapshot) {\n        throw Object.assign(new Error('tree changed in CanPlaceDep'), {\n          expect: this._treeSnapshot,\n          actual: treeSnapshot,\n        })\n      }\n    })\n  }\n\n  checkCanPlace () {\n    const { target, targetEdge, current, dep } = this\n\n    // if the dep failed to load, we're going to fail the build or\n    // prune it out anyway, so just move forward placing/replacing it.\n    if (dep.errors.length) {\n      return current ? REPLACE : OK\n    }\n\n    // cannot place peers inside their dependents, except for tops\n    if (targetEdge && targetEdge.peer && !target.isTop) {\n      return CONFLICT\n    }\n\n    if (targetEdge && !dep.satisfies(targetEdge) && targetEdge !== this.edge) {\n      return CONFLICT\n    }\n\n    return current ? this.checkCanPlaceCurrent() : this.checkCanPlaceNoCurrent()\n  }\n\n  // we know that the target has a dep by this name in its node_modules\n  // already.  Can return KEEP, REPLACE, or CONFLICT.\n  checkCanPlaceCurrent () {\n    const { preferDedupe, explicitRequest, current, target, edge, dep } = this\n\n    if (dep.matches(current)) {\n      if (current.satisfies(edge) || this.edgeOverride) {\n        return explicitRequest ? REPLACE : KEEP\n      }\n    }\n\n    const { version: curVer } = current\n    const { version: newVer } = dep\n    const tryReplace = curVer && newVer && semver.gte(newVer, curVer)\n    if (tryReplace && dep.canReplace(current)) {\n      /* XXX-istanbul ignore else - It's extremely rare that a replaceable\n       * node would be a conflict, if the current one wasn't a conflict,\n       * but it is theoretically possible if peer deps are pinned.  In\n       * that case we treat it like any other conflict, and keep trying */\n      const cpp = this.canPlacePeers(REPLACE)\n      if (cpp !== CONFLICT) {\n        return cpp\n      }\n    }\n\n    // ok, can't replace the current with new one, but maybe current is ok?\n    if (current.satisfies(edge) && (!explicitRequest || preferDedupe)) {\n      return KEEP\n    }\n\n    // if we prefer deduping, then try replacing newer with older\n    if (preferDedupe && !tryReplace && dep.canReplace(current)) {\n      const cpp = this.canPlacePeers(REPLACE)\n      if (cpp !== CONFLICT) {\n        return cpp\n      }\n    }\n\n    // Check for interesting cases!\n    // First, is this the deepest place that this thing can go, and NOT the\n    // deepest place where the conflicting dep can go?  If so, replace it,\n    // and let it re-resolve deeper in the tree.\n    const myDeepest = this.deepestNestingTarget\n\n    // ok, i COULD be placed deeper, so leave the current one alone.\n    if (target !== myDeepest) {\n      return CONFLICT\n    }\n\n    // if we are not checking a peerDep, then we MUST place it here, in the\n    // target that has a non-peer dep on it.\n    if (!edge.peer && target === edge.from) {\n      return this.canPlacePeers(REPLACE)\n    }\n\n    // if we aren't placing a peer in a set, then we're done here.\n    // This is ignored because it SHOULD be redundant, as far as I can tell,\n    // with the deepest target and target===edge.from tests.  But until we\n    // can prove that isn't possible, this condition is here for safety.\n    /* istanbul ignore if - allegedly impossible */\n    if (!this.parent && !edge.peer) {\n      return CONFLICT\n    }\n\n    // check the deps in the peer group for each edge into that peer group\n    // if ALL of them can be pushed deeper, or if it's ok to replace its\n    // members with the contents of the new peer group, then we're good.\n    let canReplace = true\n    for (const [entryEdge, currentPeers] of peerEntrySets(current)) {\n      if (entryEdge === this.edge || entryEdge === this.peerEntryEdge) {\n        continue\n      }\n\n      // First, see if it's ok to just replace the peerSet entirely.\n      // we do this by walking out from the entryEdge, because in a case like\n      // this:\n      //\n      // v -> PEER(a@1||2)\n      // a@1 -> PEER(b@1)\n      // a@2 -> PEER(b@2)\n      // b@1 -> PEER(a@1)\n      // b@2 -> PEER(a@2)\n      //\n      // root\n      // +-- v\n      // +-- a@2\n      // +-- b@2\n      //\n      // Trying to place a peer group of (a@1, b@1) would fail to note that\n      // they can be replaced, if we did it by looping 1 by 1.  If we are\n      // replacing something, we don't have to check its peer deps, because\n      // the peerDeps in the placed peerSet will presumably satisfy.\n      const entryNode = entryEdge.to\n      const entryRep = dep.parent.children.get(entryNode.name)\n      if (entryRep) {\n        if (entryRep.canReplace(entryNode, dep.parent.children.keys())) {\n          continue\n        }\n      }\n\n      let canClobber = !entryRep\n      if (!entryRep) {\n        const peerReplacementWalk = new Set([entryNode])\n        OUTER: for (const currentPeer of peerReplacementWalk) {\n          for (const edge of currentPeer.edgesOut.values()) {\n            if (!edge.peer || !edge.valid) {\n              continue\n            }\n            const rep = dep.parent.children.get(edge.name)\n            if (!rep) {\n              if (edge.to) {\n                peerReplacementWalk.add(edge.to)\n              }\n              continue\n            }\n            if (!rep.satisfies(edge)) {\n              canClobber = false\n              break OUTER\n            }\n          }\n        }\n      }\n      if (canClobber) {\n        continue\n      }\n\n      // ok, we can't replace, but maybe we can nest the current set deeper?\n      let canNestCurrent = true\n      for (const currentPeer of currentPeers) {\n        if (!canNestCurrent) {\n          break\n        }\n\n        // still possible to nest this peerSet\n        const curDeep = deepestNestingTarget(entryEdge.from, currentPeer.name)\n        if (curDeep === target || target.isDescendantOf(curDeep)) {\n          canNestCurrent = false\n          canReplace = false\n        }\n        if (canNestCurrent) {\n          continue\n        }\n      }\n    }\n\n    // if we can nest or replace all the current peer groups, we can replace.\n    if (canReplace) {\n      return this.canPlacePeers(REPLACE)\n    }\n\n    return CONFLICT\n  }\n\n  checkCanPlaceNoCurrent () {\n    const { target, peerEntryEdge, dep, name } = this\n\n    // check to see what that name resolves to here, and who may depend on\n    // being able to reach it by crawling up past the parent.  we know\n    // that it's not the target's direct child node, and if it was a direct\n    // dep of the target, we would have conflicted earlier.\n    const current = target !== peerEntryEdge.from && target.resolve(name)\n    if (current) {\n      for (const edge of current.edgesIn.values()) {\n        if (edge.from.isDescendantOf(target) && edge.valid) {\n          if (!dep.satisfies(edge)) {\n            return CONFLICT\n          }\n        }\n      }\n    }\n\n    // no objections, so this is fine as long as peers are ok here.\n    return this.canPlacePeers(OK)\n  }\n\n  get deepestNestingTarget () {\n    const start = this.parent ? this.parent.deepestNestingTarget\n      : this.edge.from\n    return deepestNestingTarget(start, this.name)\n  }\n\n  get conflictChildren () {\n    return this.allChildren.filter(c => c.canPlace === CONFLICT)\n  }\n\n  get allChildren () {\n    const set = new Set(this.children)\n    for (const child of set) {\n      for (const grandchild of child.children) {\n        set.add(grandchild)\n      }\n    }\n    return [...set]\n  }\n\n  get top () {\n    return this.parent ? this.parent.top : this\n  }\n\n  // check if peers can go here.  returns state or CONFLICT\n  canPlacePeers (state) {\n    this.canPlaceSelf = state\n    if (this._canPlacePeers) {\n      return this._canPlacePeers\n    }\n\n    // TODO: represent peerPath in ERESOLVE error somehow?\n    const peerPath = [...this.peerPath, this.dep]\n    let sawConflict = false\n    for (const peerEdge of this.dep.edgesOut.values()) {\n      if (!peerEdge.peer || !peerEdge.to || peerPath.includes(peerEdge.to)) {\n        continue\n      }\n      const peer = peerEdge.to\n      // it may be the case that the *initial* dep can be nested, but a peer\n      // of that dep needs to be placed shallower, because the target has\n      // a peer dep on the peer as well.\n      const target = deepestNestingTarget(this.target, peer.name)\n      const cpp = new CanPlaceDep({\n        dep: peer,\n        target,\n        parent: this,\n        edge: peerEdge,\n        peerPath,\n        // always place peers in preferDedupe mode\n        preferDedupe: true,\n      })\n      /* istanbul ignore next */\n      debug(() => {\n        if (this.children.some(c => c.dep === cpp.dep)) {\n          throw new Error('checking same dep repeatedly')\n        }\n      })\n      this.children.push(cpp)\n\n      if (cpp.canPlace === CONFLICT) {\n        sawConflict = true\n      }\n    }\n\n    this._canPlacePeers = sawConflict ? CONFLICT : state\n    return this._canPlacePeers\n  }\n\n  // what is the node that is causing this peerSet to be placed?\n  get peerSetSource () {\n    return this.parent ? this.parent.peerSetSource : this.edge.from\n  }\n\n  get peerEntryEdge () {\n    return this.top.edge\n  }\n\n  static get CONFLICT () {\n    return CONFLICT\n  }\n\n  static get OK () {\n    return OK\n  }\n\n  static get REPLACE () {\n    return REPLACE\n  }\n\n  static get KEEP () {\n    return KEEP\n  }\n\n  get description () {\n    const { canPlace } = this\n    return canPlace && canPlace.description ||\n    /* istanbul ignore next - old node affordance */ canPlace\n  }\n}\n\nmodule.exports = CanPlaceDep\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}