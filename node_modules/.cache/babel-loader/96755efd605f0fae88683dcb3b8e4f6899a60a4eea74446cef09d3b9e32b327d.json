{"ast":null,"code":"// a module that manages a shrinkwrap file (npm-shrinkwrap.json or\n// package-lock.json).\n\n// Increment whenever the lockfile version updates\n// v1 - npm <=6\n// v2 - arborist v1, npm v7, backwards compatible with v1, add 'packages'\n// v3 will drop the 'dependencies' field, backwards comp with v2, not v1\n//\n// We cannot bump to v3 until npm v6 is out of common usage, and\n// definitely not before npm v8.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\nconst lockfileVersion = 2;\n\n// for comparing nodes to yarn.lock entries\nconst mismatch = (a, b) => a && b && a !== b;\n\n// this.tree => the root node for the tree (ie, same path as this)\n// - Set the first time we do `this.add(node)` for a path matching this.path\n//\n// this.add(node) =>\n// - decorate the node with the metadata we have, if we have it, and it matches\n// - add to the map of nodes needing to be committed, so that subsequent\n// changes are captured when we commit that location's metadata.\n//\n// this.commit() =>\n// - commit all nodes awaiting update to their metadata entries\n// - re-generate this.data and this.yarnLock based on this.tree\n//\n// Note that between this.add() and this.commit(), `this.data` will be out of\n// date!  Always call `commit()` before relying on it.\n//\n// After calling this.commit(), any nodes not present in the tree will have\n// been removed from the shrinkwrap data as well.\n\nconst procLog = require('proc-log');\nconst YarnLock = require('./yarn-lock.js');\nconst {\n  promisify\n} = require('util');\nconst rimraf = promisify(require('rimraf'));\nconst fs = require('fs');\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\nconst stat = promisify(fs.stat);\nconst readdir_ = promisify(fs.readdir);\nconst readlink = promisify(fs.readlink);\n\n// XXX remove when drop support for node v10\nconst lstat = promisify(fs.lstat);\n/* istanbul ignore next - version specific polyfill */\nconst readdir = async (path, opt) => {\n  if (!opt || !opt.withFileTypes) {\n    return readdir_(path, opt);\n  }\n  const ents = await readdir_(path, opt);\n  if (typeof ents[0] === 'string') {\n    return Promise.all(ents.map(async ent => {\n      return Object.assign(await lstat(path + '/' + ent), {\n        name: ent\n      });\n    }));\n  }\n  return ents;\n};\nconst {\n  resolve,\n  basename\n} = require('path');\nconst specFromLock = require('./spec-from-lock.js');\nconst versionFromTgz = require('./version-from-tgz.js');\nconst npa = require('npm-package-arg');\nconst rpj = require('read-package-json-fast');\nconst parseJSON = require('parse-conflict-json');\nconst stringify = require('json-stringify-nice');\nconst swKeyOrder = ['name', 'version', 'lockfileVersion', 'resolved', 'integrity', 'requires', 'packages', 'dependencies'];\n\n// used to rewrite from yarn registry to npm registry\nconst yarnRegRe = /^https?:\\/\\/registry.yarnpkg.com\\//;\nconst npmRegRe = /^https?:\\/\\/registry.npmjs.org\\//;\n\n// sometimes resolved: is weird or broken, or something npa can't handle\nconst specFromResolved = resolved => {\n  try {\n    return npa(resolved);\n  } catch (er) {\n    return {};\n  }\n};\nconst relpath = require('./relpath.js');\nconst consistentResolve = require('./consistent-resolve.js');\nconst maybeReadFile = file => {\n  return readFile(file, 'utf8').then(d => d, er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT') {\n      return '';\n    } else {\n      throw er;\n    }\n  });\n};\nconst maybeStatFile = file => {\n  return stat(file).then(st => st.isFile(), er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT') {\n      return null;\n    } else {\n      throw er;\n    }\n  });\n};\nconst pkgMetaKeys = [\n// note: name is included if necessary, for alias packages\n'version', 'dependencies', 'peerDependencies', 'peerDependenciesMeta', 'optionalDependencies', 'bundleDependencies', 'acceptDependencies', 'funding', 'engines', 'os', 'cpu', '_integrity', 'license', '_hasShrinkwrap', 'hasInstallScript', 'bin', 'deprecated', 'workspaces'];\nconst nodeMetaKeys = ['integrity', 'inBundle', 'hasShrinkwrap', 'hasInstallScript'];\nconst metaFieldFromPkg = (pkg, key) => {\n  const val = pkg[key];\n  // get the license type, not an object\n  return key === 'license' && val && typeof val === 'object' && val.type ? val.type\n  // skip empty objects and falsey values\n  : val && !(typeof val === 'object' && !Object.keys(val).length) ? val : null;\n};\n\n// check to make sure that there are no packages newer than the hidden lockfile\nconst assertNoNewer = async (path, data, lockTime, dir = path, seen = null) => {\n  const base = basename(dir);\n  const isNM = dir !== path && base === 'node_modules';\n  const isScope = dir !== path && !isNM && base.charAt(0) === '@';\n  const isParent = dir === path || isNM || isScope;\n  const rel = relpath(path, dir);\n  if (dir !== path) {\n    const dirTime = (await stat(dir)).mtime;\n    if (dirTime > lockTime) {\n      throw 'out of date, updated: ' + rel;\n    }\n    if (!isScope && !isNM && !data.packages[rel]) {\n      throw 'missing from lockfile: ' + rel;\n    }\n    seen.add(rel);\n  } else {\n    seen = new Set([rel]);\n  }\n  const parent = isParent ? dir : resolve(dir, 'node_modules');\n  const children = dir === path ? Promise.resolve([{\n    name: 'node_modules',\n    isDirectory: () => true\n  }]) : readdir(parent, {\n    withFileTypes: true\n  });\n  return children.catch(() => []).then(ents => Promise.all(ents.map(async ent => {\n    const child = resolve(parent, ent.name);\n    if (ent.isDirectory() && !/^\\./.test(ent.name)) {\n      await assertNoNewer(path, data, lockTime, child, seen);\n    } else if (ent.isSymbolicLink()) {\n      const target = resolve(parent, await readlink(child));\n      const tstat = await stat(target).catch( /* istanbul ignore next - windows */() => null);\n      seen.add(relpath(path, child));\n      /* istanbul ignore next - windows cannot do this */\n      if (tstat && tstat.isDirectory() && !seen.has(relpath(path, target))) {\n        await assertNoNewer(path, data, lockTime, target, seen);\n      }\n    }\n  }))).then(() => {\n    if (dir !== path) {\n      return;\n    }\n\n    // assert that all the entries in the lockfile were seen\n    for (const loc of new Set(Object.keys(data.packages))) {\n      if (!seen.has(loc)) {\n        throw 'missing from node_modules: ' + loc;\n      }\n    }\n  });\n};\nconst _awaitingUpdate = Symbol('_awaitingUpdate');\nconst _updateWaitingNode = Symbol('_updateWaitingNode');\nconst _lockFromLoc = Symbol('_lockFromLoc');\nconst _pathToLoc = Symbol('_pathToLoc');\nconst _loadAll = Symbol('_loadAll');\nconst _metaFromLock = Symbol('_metaFromLock');\nconst _resolveMetaNode = Symbol('_resolveMetaNode');\nconst _fixDependencies = Symbol('_fixDependencies');\nconst _buildLegacyLockfile = Symbol('_buildLegacyLockfile');\nconst _filenameSet = Symbol('_filenameSet');\nconst _maybeRead = Symbol('_maybeRead');\nconst _maybeStat = Symbol('_maybeStat');\nclass Shrinkwrap {\n  static load(options) {\n    return new Shrinkwrap(options).load();\n  }\n  static get keyOrder() {\n    return swKeyOrder;\n  }\n  static reset(options) {\n    // still need to know if it was loaded from the disk, but don't\n    // bother reading it if we're gonna just throw it away.\n    const s = new Shrinkwrap(options);\n    s.reset();\n    return s[_maybeStat]().then(([sw, lock]) => {\n      s.filename = resolve(s.path, (s.hiddenLockfile ? 'node_modules/.package-lock' : s.shrinkwrapOnly || sw ? 'npm-shrinkwrap' : 'package-lock') + '.json');\n      s.loadedFromDisk = !!(sw || lock);\n      s.type = basename(s.filename);\n      return s;\n    });\n  }\n  static metaFromNode(node, path) {\n    if (node.isLink) {\n      return {\n        resolved: relpath(path, node.realpath),\n        link: true\n      };\n    }\n    const meta = {};\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(node.package, key);\n      if (val) {\n        meta[key.replace(/^_/, '')] = val;\n      }\n    });\n    // we only include name if different from the node path name, and for the\n    // root to help prevent churn based on the name of the directory the\n    // project is in\n    const pname = node.packageName;\n    if (pname && (node === node.root || pname !== node.name)) {\n      meta.name = pname;\n    }\n    if (node.isTop && node.package.devDependencies) {\n      meta.devDependencies = node.package.devDependencies;\n    }\n    nodeMetaKeys.forEach(key => {\n      if (node[key]) {\n        meta[key] = node[key];\n      }\n    });\n    const resolved = consistentResolve(node.resolved, node.path, path, true);\n    if (resolved) {\n      meta.resolved = resolved;\n    }\n    if (node.extraneous) {\n      meta.extraneous = true;\n    } else {\n      if (node.peer) {\n        meta.peer = true;\n      }\n      if (node.dev) {\n        meta.dev = true;\n      }\n      if (node.optional) {\n        meta.optional = true;\n      }\n      if (node.devOptional && !node.dev && !node.optional) {\n        meta.devOptional = true;\n      }\n    }\n    return meta;\n  }\n  constructor(options = {}) {\n    const {\n      path,\n      indent = 2,\n      newline = '\\n',\n      shrinkwrapOnly = false,\n      hiddenLockfile = false,\n      log = procLog\n    } = options;\n    this.log = log;\n    this[_awaitingUpdate] = new Map();\n    this.tree = null;\n    this.path = resolve(path || '.');\n    this.filename = null;\n    this.data = null;\n    this.indent = indent;\n    this.newline = newline;\n    this.loadedFromDisk = false;\n    this.type = null;\n    this.yarnLock = null;\n    this.hiddenLockfile = hiddenLockfile;\n    this.loadingError = null;\n    // only load npm-shrinkwrap.json in dep trees, not package-lock\n    this.shrinkwrapOnly = shrinkwrapOnly;\n  }\n\n  // check to see if a spec is present in the yarn.lock file, and if so,\n  // if we should use it, and what it should resolve to.  This is only\n  // done when we did not load a shrinkwrap from disk.  Also, decorate\n  // the options object if provided with the resolved and integrity that\n  // we expect.\n  checkYarnLock(spec, options = {}) {\n    spec = npa(spec);\n    const {\n      yarnLock,\n      loadedFromDisk\n    } = this;\n    const useYarnLock = yarnLock && !loadedFromDisk;\n    const fromYarn = useYarnLock && yarnLock.entries.get(spec.raw);\n    if (fromYarn && fromYarn.version) {\n      // if it's the yarn or npm default registry, use the version as\n      // our effective spec.  if it's any other kind of thing, use that.\n      const {\n        resolved,\n        version,\n        integrity\n      } = fromYarn;\n      const isYarnReg = spec.registry && yarnRegRe.test(resolved);\n      const isnpmReg = spec.registry && !isYarnReg && npmRegRe.test(resolved);\n      const isReg = isnpmReg || isYarnReg;\n      // don't use the simple version if the \"registry\" url is\n      // something else entirely!\n      const tgz = isReg && versionFromTgz(spec.name, resolved) || {};\n      const yspec = tgz.name === spec.name && tgz.version === version ? version : isReg && tgz.name && tgz.version ? `npm:${tgz.name}@${tgz.version}` : resolved;\n      if (yspec) {\n        options.resolved = resolved.replace(yarnRegRe, 'https://registry.npmjs.org/');\n        options.integrity = integrity;\n        return npa(`${spec.name}@${yspec}`);\n      }\n    }\n    return spec;\n  }\n\n  // throw away the shrinkwrap data so we can start fresh\n  // still worth doing a load() first so we know which files to write.\n  reset() {\n    this.tree = null;\n    this[_awaitingUpdate] = new Map();\n    this.originalLockfileVersion = lockfileVersion;\n    this.data = {\n      lockfileVersion,\n      requires: true,\n      packages: {},\n      dependencies: {}\n    };\n  }\n  [_filenameSet]() {\n    return this.shrinkwrapOnly ? [this.path + '/npm-shrinkwrap.json'] : this.hiddenLockfile ? [null, this.path + '/node_modules/.package-lock.json'] : [this.path + '/npm-shrinkwrap.json', this.path + '/package-lock.json', this.path + '/yarn.lock'];\n  }\n  [_maybeRead]() {\n    return Promise.all(this[_filenameSet]().map(fn => fn && maybeReadFile(fn)));\n  }\n  [_maybeStat]() {\n    // throw away yarn, we only care about lock or shrinkwrap when checking\n    // this way, since we're not actually loading the full lock metadata\n    return Promise.all(this[_filenameSet]().slice(0, 2).map(fn => fn && maybeStatFile(fn)));\n  }\n  load() {\n    // we don't need to load package-lock.json except for top of tree nodes,\n    // only npm-shrinkwrap.json.\n    return this[_maybeRead]().then(([sw, lock, yarn]) => {\n      const data = sw || lock || '';\n\n      // use shrinkwrap only for deps, otherwise prefer package-lock\n      // and ignore npm-shrinkwrap if both are present.\n      // TODO: emit a warning here or something if both are present.\n      this.filename = resolve(this.path, (this.hiddenLockfile ? 'node_modules/.package-lock' : this.shrinkwrapOnly || sw ? 'npm-shrinkwrap' : 'package-lock') + '.json');\n      this.type = basename(this.filename);\n      this.loadedFromDisk = !!data;\n      if (yarn) {\n        this.yarnLock = new YarnLock();\n        // ignore invalid yarn data.  we'll likely clobber it later anyway.\n        try {\n          this.yarnLock.parse(yarn);\n        } catch (_) {}\n      }\n      return data ? parseJSON(data) : {};\n    }).then(async data => {\n      // don't use detect-indent, just pick the first line.\n      // if the file starts with {\" then we have an indent of '', ie, none\n      // which will default to 2 at save time.\n      const {\n        [Symbol.for('indent')]: indent,\n        [Symbol.for('newline')]: newline\n      } = data;\n      this.indent = indent !== undefined ? indent : this.indent;\n      this.newline = newline !== undefined ? newline : this.newline;\n      if (!this.hiddenLockfile || !data.packages) {\n        return data;\n      }\n\n      // add a few ms just to account for jitter\n      const lockTime = +(await stat(this.filename)).mtime + 10;\n      await assertNoNewer(this.path, data, lockTime);\n\n      // all good!  hidden lockfile is the newest thing in here.\n      return data;\n    }).catch(er => {\n      const rel = relpath(this.path, this.filename);\n      this.log.verbose('shrinkwrap', `failed to load ${rel}`, er);\n      this.loadingError = er;\n      this.loadedFromDisk = false;\n      this.ancientLockfile = false;\n      return {};\n    }).then(lock => {\n      this.data = {\n        ...lock,\n        lockfileVersion,\n        requires: true,\n        packages: lock.packages || {},\n        ...(this.hiddenLockfile ? {} : {\n          dependencies: lock.dependencies || {}\n        })\n      };\n      this.originalLockfileVersion = lock.lockfileVersion;\n      this.ancientLockfile = this.loadedFromDisk && !(lock.lockfileVersion >= 2) && !lock.requires;\n\n      // load old lockfile deps into the packages listing\n      if (lock.dependencies && !lock.packages) {\n        return rpj(this.path + '/package.json').then(pkg => pkg, er => ({})).then(pkg => {\n          this[_loadAll]('', null, this.data);\n          this[_fixDependencies](pkg);\n        });\n      }\n    }).then(() => this);\n  }\n  [_loadAll](location, name, lock) {\n    // migrate a v1 package lock to the new format.\n    const meta = this[_metaFromLock](location, name, lock);\n    // dependencies nested under a link are actually under the link target\n    if (meta.link) {\n      location = meta.resolved;\n    }\n    if (lock.dependencies) {\n      for (const [name, dep] of Object.entries(lock.dependencies)) {\n        const loc = location + (location ? '/' : '') + 'node_modules/' + name;\n        this[_loadAll](loc, name, dep);\n      }\n    }\n  }\n\n  // v1 lockfiles track the optional/dev flags, but they don't tell us\n  // which thing had what kind of dep on what other thing, so we need\n  // to correct that now, or every link will be considered prod\n  [_fixDependencies](pkg) {\n    // we need the root package.json because legacy shrinkwraps just\n    // have requires:true at the root level, which is even less useful\n    // than merging all dep types into one object.\n    const root = this.data.packages[''];\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(pkg, key);\n      const k = key.replace(/^_/, '');\n      if (val) {\n        root[k] = val;\n      }\n    });\n    for (const [loc, meta] of Object.entries(this.data.packages)) {\n      if (!meta.requires || !loc) {\n        continue;\n      }\n\n      // resolve each require to a meta entry\n      // if this node isn't optional, but the dep is, then it's an optionalDep\n      // likewise for dev deps.\n      // This isn't perfect, but it's a pretty good approximation, and at\n      // least gets us out of having all 'prod' edges, which throws off the\n      // buildIdealTree process\n      for (const [name, spec] of Object.entries(meta.requires)) {\n        const dep = this[_resolveMetaNode](loc, name);\n        // this overwrites the false value set above\n        const depType = dep && dep.optional && !meta.optional ? 'optionalDependencies' : /* istanbul ignore next - dev deps are only for the root level */\n        dep && dep.dev && !meta.dev ? 'devDependencies'\n        // also land here if the dep just isn't in the tree, which maybe\n        // should be an error, since it means that the shrinkwrap is\n        // invalid, but we can't do much better without any info.\n        : 'dependencies';\n        meta[depType] = meta[depType] || {};\n        meta[depType][name] = spec;\n      }\n      delete meta.requires;\n    }\n  }\n  [_resolveMetaNode](loc, name) {\n    for (let path = loc; true; path = path.replace(/(^|\\/)[^/]*$/, '')) {\n      const check = `${path}${path ? '/' : ''}node_modules/${name}`;\n      if (this.data.packages[check]) {\n        return this.data.packages[check];\n      }\n      if (!path) {\n        break;\n      }\n    }\n    return null;\n  }\n  [_lockFromLoc](lock, path, i = 0) {\n    if (!lock) {\n      return null;\n    }\n    if (path[i] === '') {\n      i++;\n    }\n    if (i >= path.length) {\n      return lock;\n    }\n    if (!lock.dependencies) {\n      return null;\n    }\n    return this[_lockFromLoc](lock.dependencies[path[i]], path, i + 1);\n  }\n\n  // pass in a path relative to the root path, or an absolute path,\n  // get back a /-normalized location based on root path.\n  [_pathToLoc](path) {\n    return relpath(this.path, resolve(this.path, path));\n  }\n  delete(nodePath) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data');\n    }\n    const location = this[_pathToLoc](nodePath);\n    this[_awaitingUpdate].delete(location);\n    delete this.data.packages[location];\n    const path = location.split(/(?:^|\\/)node_modules\\//);\n    const name = path.pop();\n    const pLock = this[_lockFromLoc](this.data, path);\n    if (pLock && pLock.dependencies) {\n      delete pLock.dependencies[name];\n    }\n  }\n  get(nodePath) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data');\n    }\n    const location = this[_pathToLoc](nodePath);\n    if (this[_awaitingUpdate].has(location)) {\n      this[_updateWaitingNode](location);\n    }\n\n    // first try to get from the newer spot, which we know has\n    // all the things we need.\n    if (this.data.packages[location]) {\n      return this.data.packages[location];\n    }\n\n    // otherwise, fall back to the legacy metadata, and hope for the best\n    // get the node in the shrinkwrap corresponding to this spot\n    const path = location.split(/(?:^|\\/)node_modules\\//);\n    const name = path[path.length - 1];\n    const lock = this[_lockFromLoc](this.data, path);\n    return this[_metaFromLock](location, name, lock);\n  }\n  [_metaFromLock](location, name, lock) {\n    // This function tries as hard as it can to figure out the metadata\n    // from a lockfile which may be outdated or incomplete.  Since v1\n    // lockfiles used the \"version\" field to contain a variety of\n    // different possible types of data, this gets a little complicated.\n    if (!lock) {\n      return {};\n    }\n\n    // try to figure out a npm-package-arg spec from the lockfile entry\n    // This will return null if we could not get anything valid out of it.\n    const spec = specFromLock(name, lock, this.path);\n    if (spec.type === 'directory') {\n      // the \"version\" was a file: url to a non-tarball path\n      // this is a symlink dep.  We don't store much metadata\n      // about symlinks, just the target.\n      const target = relpath(this.path, spec.fetchSpec);\n      this.data.packages[location] = {\n        link: true,\n        resolved: target\n      };\n      // also save the link target, omitting version since we don't know\n      // what it is, but we know it isn't a link to itself!\n      if (!this.data.packages[target]) {\n        this[_metaFromLock](target, name, {\n          ...lock,\n          version: null\n        });\n      }\n      return this.data.packages[location];\n    }\n    const meta = {};\n    // when calling loadAll we'll change these into proper dep objects\n    if (lock.requires && typeof lock.requires === 'object') {\n      meta.requires = lock.requires;\n    }\n    if (lock.optional) {\n      meta.optional = true;\n    }\n    if (lock.dev) {\n      meta.dev = true;\n    }\n\n    // the root will typically have a name from the root project's\n    // package.json file.\n    if (location === '') {\n      meta.name = lock.name;\n    }\n\n    // if we have integrity, save it now.\n    if (lock.integrity) {\n      meta.integrity = lock.integrity;\n    }\n    if (lock.version && !lock.integrity) {\n      // this is usually going to be a git url or symlink, but it could\n      // also be a registry dependency that did not have integrity at\n      // the time it was saved.\n      // Symlinks were already handled above, so that leaves git.\n      //\n      // For git, always save the full SSH url.  we'll actually fetch the\n      // tgz most of the time, since it's faster, but it won't work for\n      // private repos, and we can't get back to the ssh from the tgz,\n      // so we store the ssh instead.\n      // For unknown git hosts, just resolve to the raw spec in lock.version\n      if (spec.type === 'git') {\n        meta.resolved = consistentResolve(spec, this.path, this.path);\n\n        // return early because there is nothing else we can do with this\n        return this.data.packages[location] = meta;\n      } else if (spec.registry) {\n        // registry dep that didn't save integrity.  grab the version, and\n        // fall through to pick up the resolved and potentially name.\n        meta.version = lock.version;\n      }\n      // only other possible case is a tarball without integrity.\n      // fall through to do what we can with the filename later.\n    }\n\n    // at this point, we know that the spec is either a registry dep\n    // (ie, version, because locking, which means a resolved url),\n    // or a remote dep, or file: url.  Remote deps and file urls\n    // have a fetchSpec equal to the fully resolved thing.\n    // Registry deps, we take what's in the lockfile.\n    if (lock.resolved || spec.type && !spec.registry) {\n      if (spec.registry) {\n        meta.resolved = lock.resolved;\n      } else if (spec.type === 'file') {\n        meta.resolved = consistentResolve(spec, this.path, this.path, true);\n      } else if (spec.fetchSpec) {\n        meta.resolved = spec.fetchSpec;\n      }\n    }\n\n    // at this point, if still we don't have a version, do our best to\n    // infer it from the tarball url/file.  This works a surprising\n    // amount of the time, even though it's not guaranteed.\n    if (!meta.version) {\n      if (spec.type === 'file' || spec.type === 'remote') {\n        const fromTgz = versionFromTgz(spec.name, spec.fetchSpec) || versionFromTgz(spec.name, meta.resolved);\n        if (fromTgz) {\n          meta.version = fromTgz.version;\n          if (fromTgz.name !== name) {\n            meta.name = fromTgz.name;\n          }\n        }\n      } else if (spec.type === 'alias') {\n        meta.name = spec.subSpec.name;\n        meta.version = spec.subSpec.fetchSpec;\n      } else if (spec.type === 'version') {\n        meta.version = spec.fetchSpec;\n      }\n      // ok, I did my best!  good luck!\n    }\n    if (lock.bundled) {\n      meta.inBundle = true;\n    }\n\n    // save it for next time\n    return this.data.packages[location] = meta;\n  }\n  add(node) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data');\n    }\n\n    // will be actually updated on read\n    const loc = relpath(this.path, node.path);\n    if (node.path === this.path) {\n      this.tree = node;\n    }\n\n    // if we have metadata about this node, and it's a match, then\n    // try to decorate it.\n    if (node.resolved === null || node.integrity === null) {\n      const {\n        resolved,\n        integrity,\n        hasShrinkwrap,\n        version\n      } = this.get(node.path);\n      const pathFixed = !resolved ? null : !/^file:/.test(resolved) ? resolved\n      // resolve onto the metadata path\n      : `file:${resolve(this.path, resolved.substr(5))}`;\n\n      // if we have one, only set the other if it matches\n      // otherwise it could be for a completely different thing.\n      const resolvedOk = !resolved || !node.resolved || node.resolved === pathFixed;\n      const integrityOk = !integrity || !node.integrity || node.integrity === integrity;\n      const versionOk = !version || !node.version || version === node.version;\n      const allOk = (resolved || integrity || version) && resolvedOk && integrityOk && versionOk;\n      if (allOk) {\n        node.resolved = node.resolved || pathFixed || null;\n        node.integrity = node.integrity || integrity || null;\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false;\n      } else {\n        // try to read off the package or node itself\n        const {\n          resolved,\n          integrity,\n          hasShrinkwrap\n        } = Shrinkwrap.metaFromNode(node, this.path);\n        node.resolved = node.resolved || resolved || null;\n        node.integrity = node.integrity || integrity || null;\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false;\n      }\n    }\n    this[_awaitingUpdate].set(loc, node);\n  }\n  addEdge(edge) {\n    if (!this.yarnLock || !edge.valid) {\n      return;\n    }\n    const {\n      to: node\n    } = edge;\n\n    // if it's already set up, nothing to do\n    if (node.resolved !== null && node.integrity !== null) {\n      return;\n    }\n\n    // if the yarn lock is empty, nothing to do\n    if (!this.yarnLock.entries || !this.yarnLock.entries.size) {\n      return;\n    }\n\n    // we relativize the path here because that's how it shows up in the lock\n    // XXX how is this different from pathFixed above??\n    const pathFixed = !node.resolved ? null : !/file:/.test(node.resolved) ? node.resolved : consistentResolve(node.resolved, node.path, this.path, true);\n    const spec = npa(`${node.name}@${edge.spec}`);\n    const entry = this.yarnLock.entries.get(`${node.name}@${edge.spec}`);\n    if (!entry || mismatch(node.version, entry.version) || mismatch(node.integrity, entry.integrity) || mismatch(pathFixed, entry.resolved)) {\n      return;\n    }\n    if (entry.resolved && yarnRegRe.test(entry.resolved) && spec.registry) {\n      entry.resolved = entry.resolved.replace(yarnRegRe, 'https://registry.npmjs.org/');\n    }\n    node.integrity = node.integrity || entry.integrity || null;\n    node.resolved = node.resolved || consistentResolve(entry.resolved, this.path, node.path) || null;\n    this[_awaitingUpdate].set(relpath(this.path, node.path), node);\n  }\n  [_updateWaitingNode](loc) {\n    const node = this[_awaitingUpdate].get(loc);\n    this[_awaitingUpdate].delete(loc);\n    this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path);\n  }\n  commit() {\n    if (this.tree) {\n      if (this.yarnLock) {\n        this.yarnLock.fromTree(this.tree);\n      }\n      const root = Shrinkwrap.metaFromNode(this.tree.target, this.path);\n      this.data.packages = {};\n      if (Object.keys(root).length) {\n        this.data.packages[''] = root;\n      }\n      for (const node of this.tree.root.inventory.values()) {\n        // only way this.tree is not root is if the root is a link to it\n        if (node === this.tree || node.isRoot || node.location === '') {\n          continue;\n        }\n        const loc = relpath(this.path, node.path);\n        this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path);\n      }\n    } else if (this[_awaitingUpdate].size > 0) {\n      for (const loc of this[_awaitingUpdate].keys()) {\n        this[_updateWaitingNode](loc);\n      }\n    }\n\n    // hidden lockfiles don't include legacy metadata or a root entry\n    if (this.hiddenLockfile) {\n      delete this.data.packages[''];\n      delete this.data.dependencies;\n    } else if (this.tree) {\n      this[_buildLegacyLockfile](this.tree, this.data);\n    }\n    return this.data;\n  }\n  [_buildLegacyLockfile](node, lock, path = []) {\n    if (node === this.tree) {\n      // the root node\n      lock.name = node.packageName || node.name;\n      if (node.version) {\n        lock.version = node.version;\n      }\n    }\n\n    // npm v6 and before tracked 'from', meaning \"the request that led\n    // to this package being installed\".  However, that's inherently\n    // racey and non-deterministic in a world where deps are deduped\n    // ahead of fetch time.  In order to maintain backwards compatibility\n    // with v6 in the lockfile, we do this trick where we pick a valid\n    // dep link out of the edgesIn set.  Choose the edge with the fewest\n    // number of `node_modules` sections in the requestor path, and then\n    // lexically sort afterwards.\n    const edge = [...node.edgesIn].filter(e => e.valid).sort((a, b) => {\n      const aloc = a.from.location.split('node_modules');\n      const bloc = b.from.location.split('node_modules');\n      /* istanbul ignore next - sort calling order is indeterminate */\n      return aloc.length > bloc.length ? 1 : bloc.length > aloc.length ? -1 : localeCompare(aloc[aloc.length - 1], bloc[bloc.length - 1]);\n    })[0];\n    const res = consistentResolve(node.resolved, this.path, this.path, true);\n    const rSpec = specFromResolved(res);\n\n    // if we don't have anything (ie, it's extraneous) then use the resolved\n    // value as if that was where we got it from, since at least it's true.\n    // if we don't have either, just an empty object so nothing matches below.\n    // This will effectively just save the version and resolved, as if it's\n    // a standard version/range dep, which is a reasonable default.\n    const spec = !edge ? rSpec : npa.resolve(node.name, edge.spec, edge.from.realpath);\n    if (node.isLink) {\n      lock.version = `file:${relpath(this.path, node.realpath)}`;\n    } else if (spec && (spec.type === 'file' || spec.type === 'remote')) {\n      lock.version = spec.saveSpec;\n    } else if (spec && spec.type === 'git' || rSpec.type === 'git') {\n      lock.version = node.resolved;\n      /* istanbul ignore else - don't think there are any cases where a git\n       * spec (or indeed, ANY npa spec) doesn't have a .raw member */\n      if (spec.raw) {\n        lock.from = spec.raw;\n      }\n    } else if (!node.isRoot && node.package && node.packageName && node.packageName !== node.name) {\n      lock.version = `npm:${node.packageName}@${node.version}`;\n    } else if (node.package && node.version) {\n      lock.version = node.version;\n    }\n    if (node.inDepBundle) {\n      lock.bundled = true;\n    }\n\n    // when we didn't resolve to git, file, or dir, and didn't request\n    // git, file, dir, or remote, then the resolved value is necessary.\n    if (node.resolved && !node.isLink && rSpec.type !== 'git' && rSpec.type !== 'file' && rSpec.type !== 'directory' && spec.type !== 'directory' && spec.type !== 'git' && spec.type !== 'file' && spec.type !== 'remote') {\n      lock.resolved = node.resolved;\n    }\n    if (node.integrity) {\n      lock.integrity = node.integrity;\n    }\n    if (node.extraneous) {\n      lock.extraneous = true;\n    } else if (!node.isLink) {\n      if (node.peer) {\n        lock.peer = true;\n      }\n      if (node.devOptional && !node.dev && !node.optional) {\n        lock.devOptional = true;\n      }\n      if (node.dev) {\n        lock.dev = true;\n      }\n      if (node.optional) {\n        lock.optional = true;\n      }\n    }\n    const depender = node.target;\n    if (depender.edgesOut.size > 0) {\n      if (node !== this.tree) {\n        const entries = [...depender.edgesOut.entries()];\n        lock.requires = entries.reduce((set, [k, v]) => {\n          // omit peer deps from legacy lockfile requires field, because\n          // npm v6 doesn't handle peer deps, and this triggers some bad\n          // behavior if the dep can't be found in the dependencies list.\n          const {\n            spec,\n            peer\n          } = v;\n          if (peer) {\n            return set;\n          }\n          if (spec.startsWith('file:')) {\n            // turn absolute file: paths into relative paths from the node\n            // this especially shows up with workspace edges when the root\n            // node is also a workspace in the set.\n            const p = resolve(node.realpath, spec.substr('file:'.length));\n            set[k] = `file:${relpath(node.realpath, p)}`;\n          } else {\n            set[k] = spec;\n          }\n          return set;\n        }, {});\n      } else {\n        lock.requires = true;\n      }\n    }\n\n    // now we walk the children, putting them in the 'dependencies' object\n    const {\n      children\n    } = node.target;\n    if (!children.size) {\n      delete lock.dependencies;\n    } else {\n      const kidPath = [...path, node.realpath];\n      const dependencies = {};\n      // skip any that are already in the descent path, so cyclical link\n      // dependencies don't blow up with ELOOP.\n      let found = false;\n      for (const [name, kid] of children.entries()) {\n        if (path.includes(kid.realpath)) {\n          continue;\n        }\n        dependencies[name] = this[_buildLegacyLockfile](kid, {}, kidPath);\n        found = true;\n      }\n      if (found) {\n        lock.dependencies = dependencies;\n      }\n    }\n    return lock;\n  }\n  save(options = {}) {\n    if (!this.data) {\n      throw new Error('run load() before saving data');\n    }\n    const {\n      format = true\n    } = options;\n    const defaultIndent = this.indent || 2;\n    const indent = format === true ? defaultIndent : format || 0;\n    const eol = format ? this.newline || '\\n' : '';\n    const data = this.commit();\n    const json = stringify(data, swKeyOrder, indent).replace(/\\n/g, eol);\n    return Promise.all([writeFile(this.filename, json).catch(er => {\n      if (this.hiddenLockfile) {\n        // well, we did our best.\n        // if we reify, and there's nothing there, then it might be lacking\n        // a node_modules folder, but then the lockfile is not important.\n        // Remove the file, so that in case there WERE deps, but we just\n        // failed to update the file for some reason, it's not out of sync.\n        return rimraf(this.filename);\n      }\n      throw er;\n    }), this.yarnLock && this.yarnLock.entries.size && writeFile(this.path + '/yarn.lock', this.yarnLock.toString())]);\n  }\n}\nmodule.exports = Shrinkwrap;","map":{"version":3,"names":["localeCompare","require","lockfileVersion","mismatch","a","b","procLog","YarnLock","promisify","rimraf","fs","readFile","writeFile","stat","readdir_","readdir","readlink","lstat","path","opt","withFileTypes","ents","Promise","all","map","ent","Object","assign","name","resolve","basename","specFromLock","versionFromTgz","npa","rpj","parseJSON","stringify","swKeyOrder","yarnRegRe","npmRegRe","specFromResolved","resolved","er","relpath","consistentResolve","maybeReadFile","file","then","d","code","maybeStatFile","st","isFile","pkgMetaKeys","nodeMetaKeys","metaFieldFromPkg","pkg","key","val","type","keys","length","assertNoNewer","data","lockTime","dir","seen","base","isNM","isScope","charAt","isParent","rel","dirTime","mtime","packages","add","Set","parent","children","isDirectory","catch","child","test","isSymbolicLink","target","tstat","has","loc","_awaitingUpdate","Symbol","_updateWaitingNode","_lockFromLoc","_pathToLoc","_loadAll","_metaFromLock","_resolveMetaNode","_fixDependencies","_buildLegacyLockfile","_filenameSet","_maybeRead","_maybeStat","Shrinkwrap","load","options","keyOrder","reset","s","sw","lock","filename","hiddenLockfile","shrinkwrapOnly","loadedFromDisk","metaFromNode","node","isLink","realpath","link","meta","forEach","package","replace","pname","packageName","root","isTop","devDependencies","extraneous","peer","dev","optional","devOptional","constructor","indent","newline","log","Map","tree","yarnLock","loadingError","checkYarnLock","spec","useYarnLock","fromYarn","entries","get","raw","version","integrity","isYarnReg","registry","isnpmReg","isReg","tgz","yspec","originalLockfileVersion","requires","dependencies","fn","slice","yarn","parse","_","for","undefined","verbose","ancientLockfile","location","dep","k","depType","check","i","delete","nodePath","Error","split","pop","pLock","fetchSpec","fromTgz","subSpec","bundled","inBundle","hasShrinkwrap","pathFixed","substr","resolvedOk","integrityOk","versionOk","allOk","set","addEdge","edge","valid","to","size","entry","commit","fromTree","inventory","values","isRoot","edgesIn","filter","e","sort","aloc","from","bloc","res","rSpec","saveSpec","inDepBundle","depender","edgesOut","reduce","v","startsWith","p","kidPath","found","kid","includes","save","format","defaultIndent","eol","json","toString","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/shrinkwrap.js"],"sourcesContent":["// a module that manages a shrinkwrap file (npm-shrinkwrap.json or\n// package-lock.json).\n\n// Increment whenever the lockfile version updates\n// v1 - npm <=6\n// v2 - arborist v1, npm v7, backwards compatible with v1, add 'packages'\n// v3 will drop the 'dependencies' field, backwards comp with v2, not v1\n//\n// We cannot bump to v3 until npm v6 is out of common usage, and\n// definitely not before npm v8.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst lockfileVersion = 2\n\n// for comparing nodes to yarn.lock entries\nconst mismatch = (a, b) => a && b && a !== b\n\n// this.tree => the root node for the tree (ie, same path as this)\n// - Set the first time we do `this.add(node)` for a path matching this.path\n//\n// this.add(node) =>\n// - decorate the node with the metadata we have, if we have it, and it matches\n// - add to the map of nodes needing to be committed, so that subsequent\n// changes are captured when we commit that location's metadata.\n//\n// this.commit() =>\n// - commit all nodes awaiting update to their metadata entries\n// - re-generate this.data and this.yarnLock based on this.tree\n//\n// Note that between this.add() and this.commit(), `this.data` will be out of\n// date!  Always call `commit()` before relying on it.\n//\n// After calling this.commit(), any nodes not present in the tree will have\n// been removed from the shrinkwrap data as well.\n\nconst procLog = require('proc-log')\nconst YarnLock = require('./yarn-lock.js')\nconst {promisify} = require('util')\nconst rimraf = promisify(require('rimraf'))\nconst fs = require('fs')\nconst readFile = promisify(fs.readFile)\nconst writeFile = promisify(fs.writeFile)\nconst stat = promisify(fs.stat)\nconst readdir_ = promisify(fs.readdir)\nconst readlink = promisify(fs.readlink)\n\n// XXX remove when drop support for node v10\nconst lstat = promisify(fs.lstat)\n/* istanbul ignore next - version specific polyfill */\nconst readdir = async (path, opt) => {\n  if (!opt || !opt.withFileTypes) {\n    return readdir_(path, opt)\n  }\n  const ents = await readdir_(path, opt)\n  if (typeof ents[0] === 'string') {\n    return Promise.all(ents.map(async ent => {\n      return Object.assign(await lstat(path + '/' + ent), { name: ent })\n    }))\n  }\n  return ents\n}\n\nconst { resolve, basename } = require('path')\nconst specFromLock = require('./spec-from-lock.js')\nconst versionFromTgz = require('./version-from-tgz.js')\nconst npa = require('npm-package-arg')\nconst rpj = require('read-package-json-fast')\nconst parseJSON = require('parse-conflict-json')\n\nconst stringify = require('json-stringify-nice')\nconst swKeyOrder = [\n  'name',\n  'version',\n  'lockfileVersion',\n  'resolved',\n  'integrity',\n  'requires',\n  'packages',\n  'dependencies',\n]\n\n// used to rewrite from yarn registry to npm registry\nconst yarnRegRe = /^https?:\\/\\/registry.yarnpkg.com\\//\nconst npmRegRe = /^https?:\\/\\/registry.npmjs.org\\//\n\n// sometimes resolved: is weird or broken, or something npa can't handle\nconst specFromResolved = resolved => {\n  try {\n    return npa(resolved)\n  } catch (er) {\n    return {}\n  }\n}\n\nconst relpath = require('./relpath.js')\n\nconst consistentResolve = require('./consistent-resolve.js')\n\nconst maybeReadFile = file => {\n  return readFile(file, 'utf8').then(d => d, er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT') {\n      return ''\n    } else {\n      throw er\n    }\n  })\n}\n\nconst maybeStatFile = file => {\n  return stat(file).then(st => st.isFile(), er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT') {\n      return null\n    } else {\n      throw er\n    }\n  })\n}\n\nconst pkgMetaKeys = [\n  // note: name is included if necessary, for alias packages\n  'version',\n  'dependencies',\n  'peerDependencies',\n  'peerDependenciesMeta',\n  'optionalDependencies',\n  'bundleDependencies',\n  'acceptDependencies',\n  'funding',\n  'engines',\n  'os',\n  'cpu',\n  '_integrity',\n  'license',\n  '_hasShrinkwrap',\n  'hasInstallScript',\n  'bin',\n  'deprecated',\n  'workspaces',\n]\n\nconst nodeMetaKeys = [\n  'integrity',\n  'inBundle',\n  'hasShrinkwrap',\n  'hasInstallScript',\n]\n\nconst metaFieldFromPkg = (pkg, key) => {\n  const val = pkg[key]\n  // get the license type, not an object\n  return (key === 'license' && val && typeof val === 'object' && val.type)\n    ? val.type\n    // skip empty objects and falsey values\n    : (val && !(typeof val === 'object' && !Object.keys(val).length)) ? val\n    : null\n}\n\n// check to make sure that there are no packages newer than the hidden lockfile\nconst assertNoNewer = async (path, data, lockTime, dir = path, seen = null) => {\n  const base = basename(dir)\n  const isNM = dir !== path && base === 'node_modules'\n  const isScope = dir !== path && !isNM && base.charAt(0) === '@'\n  const isParent = dir === path || isNM || isScope\n\n  const rel = relpath(path, dir)\n  if (dir !== path) {\n    const dirTime = (await stat(dir)).mtime\n    if (dirTime > lockTime) {\n      throw 'out of date, updated: ' + rel\n    }\n    if (!isScope && !isNM && !data.packages[rel]) {\n      throw 'missing from lockfile: ' + rel\n    }\n    seen.add(rel)\n  } else {\n    seen = new Set([rel])\n  }\n\n  const parent = isParent ? dir : resolve(dir, 'node_modules')\n  const children = dir === path\n    ? Promise.resolve([{name: 'node_modules', isDirectory: () => true }])\n    : readdir(parent, { withFileTypes: true })\n\n  return children.catch(() => [])\n    .then(ents => Promise.all(ents.map(async ent => {\n      const child = resolve(parent, ent.name)\n      if (ent.isDirectory() && !/^\\./.test(ent.name)) {\n        await assertNoNewer(path, data, lockTime, child, seen)\n      } else if (ent.isSymbolicLink()) {\n        const target = resolve(parent, await readlink(child))\n        const tstat = await stat(target).catch(\n          /* istanbul ignore next - windows */ () => null)\n        seen.add(relpath(path, child))\n        /* istanbul ignore next - windows cannot do this */\n        if (tstat && tstat.isDirectory() && !seen.has(relpath(path, target))) {\n          await assertNoNewer(path, data, lockTime, target, seen)\n        }\n      }\n    })))\n    .then(() => {\n      if (dir !== path) {\n        return\n      }\n\n      // assert that all the entries in the lockfile were seen\n      for (const loc of new Set(Object.keys(data.packages))) {\n        if (!seen.has(loc)) {\n          throw 'missing from node_modules: ' + loc\n        }\n      }\n    })\n}\n\nconst _awaitingUpdate = Symbol('_awaitingUpdate')\nconst _updateWaitingNode = Symbol('_updateWaitingNode')\nconst _lockFromLoc = Symbol('_lockFromLoc')\nconst _pathToLoc = Symbol('_pathToLoc')\nconst _loadAll = Symbol('_loadAll')\nconst _metaFromLock = Symbol('_metaFromLock')\nconst _resolveMetaNode = Symbol('_resolveMetaNode')\nconst _fixDependencies = Symbol('_fixDependencies')\nconst _buildLegacyLockfile = Symbol('_buildLegacyLockfile')\nconst _filenameSet = Symbol('_filenameSet')\nconst _maybeRead = Symbol('_maybeRead')\nconst _maybeStat = Symbol('_maybeStat')\nclass Shrinkwrap {\n  static load (options) {\n    return new Shrinkwrap(options).load()\n  }\n\n  static get keyOrder () {\n    return swKeyOrder\n  }\n\n  static reset (options) {\n    // still need to know if it was loaded from the disk, but don't\n    // bother reading it if we're gonna just throw it away.\n    const s = new Shrinkwrap(options)\n    s.reset()\n\n    return s[_maybeStat]().then(([sw, lock]) => {\n      s.filename = resolve(s.path,\n        (s.hiddenLockfile ? 'node_modules/.package-lock'\n        : s.shrinkwrapOnly || sw ? 'npm-shrinkwrap'\n        : 'package-lock') + '.json')\n      s.loadedFromDisk = !!(sw || lock)\n      s.type = basename(s.filename)\n      return s\n    })\n  }\n\n  static metaFromNode (node, path) {\n    if (node.isLink) {\n      return {\n        resolved: relpath(path, node.realpath),\n        link: true,\n      }\n    }\n\n    const meta = {}\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(node.package, key)\n      if (val) {\n        meta[key.replace(/^_/, '')] = val\n      }\n    })\n    // we only include name if different from the node path name, and for the\n    // root to help prevent churn based on the name of the directory the\n    // project is in\n    const pname = node.packageName\n    if (pname && (node === node.root || pname !== node.name)) {\n      meta.name = pname\n    }\n\n    if (node.isTop && node.package.devDependencies) {\n      meta.devDependencies = node.package.devDependencies\n    }\n\n    nodeMetaKeys.forEach(key => {\n      if (node[key]) {\n        meta[key] = node[key]\n      }\n    })\n\n    const resolved = consistentResolve(node.resolved, node.path, path, true)\n    if (resolved) {\n      meta.resolved = resolved\n    }\n\n    if (node.extraneous) {\n      meta.extraneous = true\n    } else {\n      if (node.peer) {\n        meta.peer = true\n      }\n      if (node.dev) {\n        meta.dev = true\n      }\n      if (node.optional) {\n        meta.optional = true\n      }\n      if (node.devOptional && !node.dev && !node.optional) {\n        meta.devOptional = true\n      }\n    }\n    return meta\n  }\n\n  constructor (options = {}) {\n    const {\n      path,\n      indent = 2,\n      newline = '\\n',\n      shrinkwrapOnly = false,\n      hiddenLockfile = false,\n      log = procLog,\n    } = options\n\n    this.log = log\n    this[_awaitingUpdate] = new Map()\n    this.tree = null\n    this.path = resolve(path || '.')\n    this.filename = null\n    this.data = null\n    this.indent = indent\n    this.newline = newline\n    this.loadedFromDisk = false\n    this.type = null\n    this.yarnLock = null\n    this.hiddenLockfile = hiddenLockfile\n    this.loadingError = null\n    // only load npm-shrinkwrap.json in dep trees, not package-lock\n    this.shrinkwrapOnly = shrinkwrapOnly\n  }\n\n  // check to see if a spec is present in the yarn.lock file, and if so,\n  // if we should use it, and what it should resolve to.  This is only\n  // done when we did not load a shrinkwrap from disk.  Also, decorate\n  // the options object if provided with the resolved and integrity that\n  // we expect.\n  checkYarnLock (spec, options = {}) {\n    spec = npa(spec)\n    const { yarnLock, loadedFromDisk } = this\n    const useYarnLock = yarnLock && !loadedFromDisk\n    const fromYarn = useYarnLock && yarnLock.entries.get(spec.raw)\n    if (fromYarn && fromYarn.version) {\n      // if it's the yarn or npm default registry, use the version as\n      // our effective spec.  if it's any other kind of thing, use that.\n      const {resolved, version, integrity} = fromYarn\n      const isYarnReg = spec.registry && yarnRegRe.test(resolved)\n      const isnpmReg = spec.registry && !isYarnReg && npmRegRe.test(resolved)\n      const isReg = isnpmReg || isYarnReg\n      // don't use the simple version if the \"registry\" url is\n      // something else entirely!\n      const tgz = isReg && versionFromTgz(spec.name, resolved) || {}\n      const yspec = tgz.name === spec.name && tgz.version === version ? version\n        : isReg && tgz.name && tgz.version ? `npm:${tgz.name}@${tgz.version}`\n        : resolved\n      if (yspec) {\n        options.resolved = resolved.replace(yarnRegRe, 'https://registry.npmjs.org/')\n        options.integrity = integrity\n        return npa(`${spec.name}@${yspec}`)\n      }\n    }\n    return spec\n  }\n\n  // throw away the shrinkwrap data so we can start fresh\n  // still worth doing a load() first so we know which files to write.\n  reset () {\n    this.tree = null\n    this[_awaitingUpdate] = new Map()\n    this.originalLockfileVersion = lockfileVersion\n    this.data = {\n      lockfileVersion,\n      requires: true,\n      packages: {},\n      dependencies: {},\n    }\n  }\n\n  [_filenameSet] () {\n    return this.shrinkwrapOnly ? [\n      this.path + '/npm-shrinkwrap.json',\n    ] : this.hiddenLockfile ? [\n      null,\n      this.path + '/node_modules/.package-lock.json',\n    ] : [\n      this.path + '/npm-shrinkwrap.json',\n      this.path + '/package-lock.json',\n      this.path + '/yarn.lock',\n    ]\n  }\n\n  [_maybeRead] () {\n    return Promise.all(this[_filenameSet]().map(fn => fn && maybeReadFile(fn)))\n  }\n\n  [_maybeStat] () {\n    // throw away yarn, we only care about lock or shrinkwrap when checking\n    // this way, since we're not actually loading the full lock metadata\n    return Promise.all(this[_filenameSet]().slice(0, 2)\n      .map(fn => fn && maybeStatFile(fn)))\n  }\n\n  load () {\n    // we don't need to load package-lock.json except for top of tree nodes,\n    // only npm-shrinkwrap.json.\n    return this[_maybeRead]().then(([sw, lock, yarn]) => {\n      const data = sw || lock || ''\n\n      // use shrinkwrap only for deps, otherwise prefer package-lock\n      // and ignore npm-shrinkwrap if both are present.\n      // TODO: emit a warning here or something if both are present.\n      this.filename = resolve(this.path,\n        (this.hiddenLockfile ? 'node_modules/.package-lock'\n        : this.shrinkwrapOnly || sw ? 'npm-shrinkwrap'\n        : 'package-lock') + '.json')\n\n      this.type = basename(this.filename)\n      this.loadedFromDisk = !!data\n\n      if (yarn) {\n        this.yarnLock = new YarnLock()\n        // ignore invalid yarn data.  we'll likely clobber it later anyway.\n        try {\n          this.yarnLock.parse(yarn)\n        } catch (_) {}\n      }\n\n      return data ? parseJSON(data) : {}\n    }).then(async data => {\n      // don't use detect-indent, just pick the first line.\n      // if the file starts with {\" then we have an indent of '', ie, none\n      // which will default to 2 at save time.\n      const {\n        [Symbol.for('indent')]: indent,\n        [Symbol.for('newline')]: newline,\n      } = data\n      this.indent = indent !== undefined ? indent : this.indent\n      this.newline = newline !== undefined ? newline : this.newline\n\n      if (!this.hiddenLockfile || !data.packages) {\n        return data\n      }\n\n      // add a few ms just to account for jitter\n      const lockTime = +(await stat(this.filename)).mtime + 10\n      await assertNoNewer(this.path, data, lockTime)\n\n      // all good!  hidden lockfile is the newest thing in here.\n      return data\n    }).catch(er => {\n      const rel = relpath(this.path, this.filename)\n      this.log.verbose('shrinkwrap', `failed to load ${rel}`, er)\n      this.loadingError = er\n      this.loadedFromDisk = false\n      this.ancientLockfile = false\n      return {}\n    }).then(lock => {\n      this.data = {\n        ...lock,\n        lockfileVersion,\n        requires: true,\n        packages: lock.packages || {},\n        ...(this.hiddenLockfile ? {} : {dependencies: lock.dependencies || {}}),\n      }\n      this.originalLockfileVersion = lock.lockfileVersion\n      this.ancientLockfile = this.loadedFromDisk &&\n        !(lock.lockfileVersion >= 2) && !lock.requires\n\n      // load old lockfile deps into the packages listing\n      if (lock.dependencies && !lock.packages) {\n        return rpj(this.path + '/package.json').then(pkg => pkg, er => ({}))\n          .then(pkg => {\n            this[_loadAll]('', null, this.data)\n            this[_fixDependencies](pkg)\n          })\n      }\n    })\n      .then(() => this)\n  }\n\n  [_loadAll] (location, name, lock) {\n    // migrate a v1 package lock to the new format.\n    const meta = this[_metaFromLock](location, name, lock)\n    // dependencies nested under a link are actually under the link target\n    if (meta.link) {\n      location = meta.resolved\n    }\n    if (lock.dependencies) {\n      for (const [name, dep] of Object.entries(lock.dependencies)) {\n        const loc = location + (location ? '/' : '') + 'node_modules/' + name\n        this[_loadAll](loc, name, dep)\n      }\n    }\n  }\n\n  // v1 lockfiles track the optional/dev flags, but they don't tell us\n  // which thing had what kind of dep on what other thing, so we need\n  // to correct that now, or every link will be considered prod\n  [_fixDependencies] (pkg) {\n    // we need the root package.json because legacy shrinkwraps just\n    // have requires:true at the root level, which is even less useful\n    // than merging all dep types into one object.\n    const root = this.data.packages['']\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(pkg, key)\n      const k = key.replace(/^_/, '')\n      if (val) {\n        root[k] = val\n      }\n    })\n\n    for (const [loc, meta] of Object.entries(this.data.packages)) {\n      if (!meta.requires || !loc) {\n        continue\n      }\n\n      // resolve each require to a meta entry\n      // if this node isn't optional, but the dep is, then it's an optionalDep\n      // likewise for dev deps.\n      // This isn't perfect, but it's a pretty good approximation, and at\n      // least gets us out of having all 'prod' edges, which throws off the\n      // buildIdealTree process\n      for (const [name, spec] of Object.entries(meta.requires)) {\n        const dep = this[_resolveMetaNode](loc, name)\n        // this overwrites the false value set above\n        const depType = dep && dep.optional && !meta.optional\n          ? 'optionalDependencies'\n          : /* istanbul ignore next - dev deps are only for the root level */\n          dep && dep.dev && !meta.dev ? 'devDependencies'\n          // also land here if the dep just isn't in the tree, which maybe\n          // should be an error, since it means that the shrinkwrap is\n          // invalid, but we can't do much better without any info.\n          : 'dependencies'\n        meta[depType] = meta[depType] || {}\n        meta[depType][name] = spec\n      }\n      delete meta.requires\n    }\n  }\n\n  [_resolveMetaNode] (loc, name) {\n    for (let path = loc; true; path = path.replace(/(^|\\/)[^/]*$/, '')) {\n      const check = `${path}${path ? '/' : ''}node_modules/${name}`\n      if (this.data.packages[check]) {\n        return this.data.packages[check]\n      }\n\n      if (!path) {\n        break\n      }\n    }\n    return null\n  }\n\n  [_lockFromLoc] (lock, path, i = 0) {\n    if (!lock) {\n      return null\n    }\n\n    if (path[i] === '') {\n      i++\n    }\n\n    if (i >= path.length) {\n      return lock\n    }\n\n    if (!lock.dependencies) {\n      return null\n    }\n\n    return this[_lockFromLoc](lock.dependencies[path[i]], path, i + 1)\n  }\n\n  // pass in a path relative to the root path, or an absolute path,\n  // get back a /-normalized location based on root path.\n  [_pathToLoc] (path) {\n    return relpath(this.path, resolve(this.path, path))\n  }\n\n  delete (nodePath) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data')\n    }\n    const location = this[_pathToLoc](nodePath)\n    this[_awaitingUpdate].delete(location)\n\n    delete this.data.packages[location]\n    const path = location.split(/(?:^|\\/)node_modules\\//)\n    const name = path.pop()\n    const pLock = this[_lockFromLoc](this.data, path)\n    if (pLock && pLock.dependencies) {\n      delete pLock.dependencies[name]\n    }\n  }\n\n  get (nodePath) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data')\n    }\n\n    const location = this[_pathToLoc](nodePath)\n    if (this[_awaitingUpdate].has(location)) {\n      this[_updateWaitingNode](location)\n    }\n\n    // first try to get from the newer spot, which we know has\n    // all the things we need.\n    if (this.data.packages[location]) {\n      return this.data.packages[location]\n    }\n\n    // otherwise, fall back to the legacy metadata, and hope for the best\n    // get the node in the shrinkwrap corresponding to this spot\n    const path = location.split(/(?:^|\\/)node_modules\\//)\n    const name = path[path.length - 1]\n    const lock = this[_lockFromLoc](this.data, path)\n\n    return this[_metaFromLock](location, name, lock)\n  }\n\n  [_metaFromLock] (location, name, lock) {\n    // This function tries as hard as it can to figure out the metadata\n    // from a lockfile which may be outdated or incomplete.  Since v1\n    // lockfiles used the \"version\" field to contain a variety of\n    // different possible types of data, this gets a little complicated.\n    if (!lock) {\n      return {}\n    }\n\n    // try to figure out a npm-package-arg spec from the lockfile entry\n    // This will return null if we could not get anything valid out of it.\n    const spec = specFromLock(name, lock, this.path)\n\n    if (spec.type === 'directory') {\n      // the \"version\" was a file: url to a non-tarball path\n      // this is a symlink dep.  We don't store much metadata\n      // about symlinks, just the target.\n      const target = relpath(this.path, spec.fetchSpec)\n      this.data.packages[location] = {\n        link: true,\n        resolved: target,\n      }\n      // also save the link target, omitting version since we don't know\n      // what it is, but we know it isn't a link to itself!\n      if (!this.data.packages[target]) {\n        this[_metaFromLock](target, name, { ...lock, version: null })\n      }\n      return this.data.packages[location]\n    }\n\n    const meta = {}\n    // when calling loadAll we'll change these into proper dep objects\n    if (lock.requires && typeof lock.requires === 'object') {\n      meta.requires = lock.requires\n    }\n\n    if (lock.optional) {\n      meta.optional = true\n    }\n    if (lock.dev) {\n      meta.dev = true\n    }\n\n    // the root will typically have a name from the root project's\n    // package.json file.\n    if (location === '') {\n      meta.name = lock.name\n    }\n\n    // if we have integrity, save it now.\n    if (lock.integrity) {\n      meta.integrity = lock.integrity\n    }\n\n    if (lock.version && !lock.integrity) {\n      // this is usually going to be a git url or symlink, but it could\n      // also be a registry dependency that did not have integrity at\n      // the time it was saved.\n      // Symlinks were already handled above, so that leaves git.\n      //\n      // For git, always save the full SSH url.  we'll actually fetch the\n      // tgz most of the time, since it's faster, but it won't work for\n      // private repos, and we can't get back to the ssh from the tgz,\n      // so we store the ssh instead.\n      // For unknown git hosts, just resolve to the raw spec in lock.version\n      if (spec.type === 'git') {\n        meta.resolved = consistentResolve(spec, this.path, this.path)\n\n        // return early because there is nothing else we can do with this\n        return this.data.packages[location] = meta\n      } else if (spec.registry) {\n        // registry dep that didn't save integrity.  grab the version, and\n        // fall through to pick up the resolved and potentially name.\n        meta.version = lock.version\n      }\n      // only other possible case is a tarball without integrity.\n      // fall through to do what we can with the filename later.\n    }\n\n    // at this point, we know that the spec is either a registry dep\n    // (ie, version, because locking, which means a resolved url),\n    // or a remote dep, or file: url.  Remote deps and file urls\n    // have a fetchSpec equal to the fully resolved thing.\n    // Registry deps, we take what's in the lockfile.\n    if (lock.resolved || (spec.type && !spec.registry)) {\n      if (spec.registry) {\n        meta.resolved = lock.resolved\n      } else if (spec.type === 'file') {\n        meta.resolved = consistentResolve(spec, this.path, this.path, true)\n      } else if (spec.fetchSpec) {\n        meta.resolved = spec.fetchSpec\n      }\n    }\n\n    // at this point, if still we don't have a version, do our best to\n    // infer it from the tarball url/file.  This works a surprising\n    // amount of the time, even though it's not guaranteed.\n    if (!meta.version) {\n      if (spec.type === 'file' || spec.type === 'remote') {\n        const fromTgz = versionFromTgz(spec.name, spec.fetchSpec) ||\n          versionFromTgz(spec.name, meta.resolved)\n        if (fromTgz) {\n          meta.version = fromTgz.version\n          if (fromTgz.name !== name) {\n            meta.name = fromTgz.name\n          }\n        }\n      } else if (spec.type === 'alias') {\n        meta.name = spec.subSpec.name\n        meta.version = spec.subSpec.fetchSpec\n      } else if (spec.type === 'version') {\n        meta.version = spec.fetchSpec\n      }\n      // ok, I did my best!  good luck!\n    }\n\n    if (lock.bundled) {\n      meta.inBundle = true\n    }\n\n    // save it for next time\n    return this.data.packages[location] = meta\n  }\n\n  add (node) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data')\n    }\n\n    // will be actually updated on read\n    const loc = relpath(this.path, node.path)\n    if (node.path === this.path) {\n      this.tree = node\n    }\n\n    // if we have metadata about this node, and it's a match, then\n    // try to decorate it.\n    if (node.resolved === null || node.integrity === null) {\n      const {\n        resolved,\n        integrity,\n        hasShrinkwrap,\n        version,\n      } = this.get(node.path)\n\n      const pathFixed = !resolved ? null\n        : !/^file:/.test(resolved) ? resolved\n        // resolve onto the metadata path\n        : `file:${resolve(this.path, resolved.substr(5))}`\n\n      // if we have one, only set the other if it matches\n      // otherwise it could be for a completely different thing.\n      const resolvedOk = !resolved || !node.resolved ||\n        node.resolved === pathFixed\n      const integrityOk = !integrity || !node.integrity ||\n        node.integrity === integrity\n      const versionOk = !version || !node.version || version === node.version\n\n      const allOk = (resolved || integrity || version) &&\n        resolvedOk && integrityOk && versionOk\n\n      if (allOk) {\n        node.resolved = node.resolved || pathFixed || null\n        node.integrity = node.integrity || integrity || null\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false\n      } else {\n        // try to read off the package or node itself\n        const {\n          resolved,\n          integrity,\n          hasShrinkwrap,\n        } = Shrinkwrap.metaFromNode(node, this.path)\n        node.resolved = node.resolved || resolved || null\n        node.integrity = node.integrity || integrity || null\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false\n      }\n    }\n    this[_awaitingUpdate].set(loc, node)\n  }\n\n  addEdge (edge) {\n    if (!this.yarnLock || !edge.valid) {\n      return\n    }\n\n    const { to: node } = edge\n\n    // if it's already set up, nothing to do\n    if (node.resolved !== null && node.integrity !== null) {\n      return\n    }\n\n    // if the yarn lock is empty, nothing to do\n    if (!this.yarnLock.entries || !this.yarnLock.entries.size) {\n      return\n    }\n\n    // we relativize the path here because that's how it shows up in the lock\n    // XXX how is this different from pathFixed above??\n    const pathFixed = !node.resolved ? null\n      : !/file:/.test(node.resolved) ? node.resolved\n      : consistentResolve(node.resolved, node.path, this.path, true)\n\n    const spec = npa(`${node.name}@${edge.spec}`)\n    const entry = this.yarnLock.entries.get(`${node.name}@${edge.spec}`)\n\n    if (!entry ||\n        mismatch(node.version, entry.version) ||\n        mismatch(node.integrity, entry.integrity) ||\n        mismatch(pathFixed, entry.resolved)) {\n      return\n    }\n\n    if (entry.resolved && yarnRegRe.test(entry.resolved) && spec.registry) {\n      entry.resolved = entry.resolved.replace(yarnRegRe, 'https://registry.npmjs.org/')\n    }\n\n    node.integrity = node.integrity || entry.integrity || null\n    node.resolved = node.resolved ||\n      consistentResolve(entry.resolved, this.path, node.path) || null\n\n    this[_awaitingUpdate].set(relpath(this.path, node.path), node)\n  }\n\n  [_updateWaitingNode] (loc) {\n    const node = this[_awaitingUpdate].get(loc)\n    this[_awaitingUpdate].delete(loc)\n    this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path)\n  }\n\n  commit () {\n    if (this.tree) {\n      if (this.yarnLock) {\n        this.yarnLock.fromTree(this.tree)\n      }\n      const root = Shrinkwrap.metaFromNode(this.tree.target, this.path)\n      this.data.packages = {}\n      if (Object.keys(root).length) {\n        this.data.packages[''] = root\n      }\n      for (const node of this.tree.root.inventory.values()) {\n        // only way this.tree is not root is if the root is a link to it\n        if (node === this.tree || node.isRoot || node.location === '') {\n          continue\n        }\n        const loc = relpath(this.path, node.path)\n        this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path)\n      }\n    } else if (this[_awaitingUpdate].size > 0) {\n      for (const loc of this[_awaitingUpdate].keys()) {\n        this[_updateWaitingNode](loc)\n      }\n    }\n\n    // hidden lockfiles don't include legacy metadata or a root entry\n    if (this.hiddenLockfile) {\n      delete this.data.packages['']\n      delete this.data.dependencies\n    } else if (this.tree) {\n      this[_buildLegacyLockfile](this.tree, this.data)\n    }\n\n    return this.data\n  }\n\n  [_buildLegacyLockfile] (node, lock, path = []) {\n    if (node === this.tree) {\n      // the root node\n      lock.name = node.packageName || node.name\n      if (node.version) {\n        lock.version = node.version\n      }\n    }\n\n    // npm v6 and before tracked 'from', meaning \"the request that led\n    // to this package being installed\".  However, that's inherently\n    // racey and non-deterministic in a world where deps are deduped\n    // ahead of fetch time.  In order to maintain backwards compatibility\n    // with v6 in the lockfile, we do this trick where we pick a valid\n    // dep link out of the edgesIn set.  Choose the edge with the fewest\n    // number of `node_modules` sections in the requestor path, and then\n    // lexically sort afterwards.\n    const edge = [...node.edgesIn].filter(e => e.valid).sort((a, b) => {\n      const aloc = a.from.location.split('node_modules')\n      const bloc = b.from.location.split('node_modules')\n      /* istanbul ignore next - sort calling order is indeterminate */\n      return aloc.length > bloc.length ? 1\n        : bloc.length > aloc.length ? -1\n        : localeCompare(aloc[aloc.length - 1], bloc[bloc.length - 1])\n    })[0]\n\n    const res = consistentResolve(node.resolved, this.path, this.path, true)\n    const rSpec = specFromResolved(res)\n\n    // if we don't have anything (ie, it's extraneous) then use the resolved\n    // value as if that was where we got it from, since at least it's true.\n    // if we don't have either, just an empty object so nothing matches below.\n    // This will effectively just save the version and resolved, as if it's\n    // a standard version/range dep, which is a reasonable default.\n    const spec = !edge ? rSpec\n      : npa.resolve(node.name, edge.spec, edge.from.realpath)\n\n    if (node.isLink) {\n      lock.version = `file:${relpath(this.path, node.realpath)}`\n    } else if (spec && (spec.type === 'file' || spec.type === 'remote')) {\n      lock.version = spec.saveSpec\n    } else if (spec && spec.type === 'git' || rSpec.type === 'git') {\n      lock.version = node.resolved\n      /* istanbul ignore else - don't think there are any cases where a git\n       * spec (or indeed, ANY npa spec) doesn't have a .raw member */\n      if (spec.raw) {\n        lock.from = spec.raw\n      }\n    } else if (!node.isRoot &&\n        node.package &&\n        node.packageName &&\n        node.packageName !== node.name) {\n      lock.version = `npm:${node.packageName}@${node.version}`\n    } else if (node.package && node.version) {\n      lock.version = node.version\n    }\n\n    if (node.inDepBundle) {\n      lock.bundled = true\n    }\n\n    // when we didn't resolve to git, file, or dir, and didn't request\n    // git, file, dir, or remote, then the resolved value is necessary.\n    if (node.resolved &&\n        !node.isLink &&\n        rSpec.type !== 'git' &&\n        rSpec.type !== 'file' &&\n        rSpec.type !== 'directory' &&\n        spec.type !== 'directory' &&\n        spec.type !== 'git' &&\n        spec.type !== 'file' &&\n        spec.type !== 'remote') {\n      lock.resolved = node.resolved\n    }\n\n    if (node.integrity) {\n      lock.integrity = node.integrity\n    }\n\n    if (node.extraneous) {\n      lock.extraneous = true\n    } else if (!node.isLink) {\n      if (node.peer) {\n        lock.peer = true\n      }\n\n      if (node.devOptional && !node.dev && !node.optional) {\n        lock.devOptional = true\n      }\n\n      if (node.dev) {\n        lock.dev = true\n      }\n\n      if (node.optional) {\n        lock.optional = true\n      }\n    }\n\n    const depender = node.target\n    if (depender.edgesOut.size > 0) {\n      if (node !== this.tree) {\n        const entries = [...depender.edgesOut.entries()]\n        lock.requires = entries.reduce((set, [k, v]) => {\n          // omit peer deps from legacy lockfile requires field, because\n          // npm v6 doesn't handle peer deps, and this triggers some bad\n          // behavior if the dep can't be found in the dependencies list.\n          const { spec, peer } = v\n          if (peer) {\n            return set\n          }\n          if (spec.startsWith('file:')) {\n            // turn absolute file: paths into relative paths from the node\n            // this especially shows up with workspace edges when the root\n            // node is also a workspace in the set.\n            const p = resolve(node.realpath, spec.substr('file:'.length))\n            set[k] = `file:${relpath(node.realpath, p)}`\n          } else {\n            set[k] = spec\n          }\n          return set\n        }, {})\n      } else {\n        lock.requires = true\n      }\n    }\n\n    // now we walk the children, putting them in the 'dependencies' object\n    const {children} = node.target\n    if (!children.size) {\n      delete lock.dependencies\n    } else {\n      const kidPath = [...path, node.realpath]\n      const dependencies = {}\n      // skip any that are already in the descent path, so cyclical link\n      // dependencies don't blow up with ELOOP.\n      let found = false\n      for (const [name, kid] of children.entries()) {\n        if (path.includes(kid.realpath)) {\n          continue\n        }\n        dependencies[name] = this[_buildLegacyLockfile](kid, {}, kidPath)\n        found = true\n      }\n      if (found) {\n        lock.dependencies = dependencies\n      }\n    }\n    return lock\n  }\n\n  save (options = {}) {\n    if (!this.data) {\n      throw new Error('run load() before saving data')\n    }\n\n    const { format = true } = options\n    const defaultIndent = this.indent || 2\n    const indent = format === true ? defaultIndent\n      : format || 0\n    const eol = format ? this.newline || '\\n' : ''\n    const data = this.commit()\n    const json = stringify(data, swKeyOrder, indent).replace(/\\n/g, eol)\n    return Promise.all([\n      writeFile(this.filename, json).catch(er => {\n        if (this.hiddenLockfile) {\n          // well, we did our best.\n          // if we reify, and there's nothing there, then it might be lacking\n          // a node_modules folder, but then the lockfile is not important.\n          // Remove the file, so that in case there WERE deps, but we just\n          // failed to update the file for some reason, it's not out of sync.\n          return rimraf(this.filename)\n        }\n        throw er\n      }),\n      this.yarnLock && this.yarnLock.entries.size &&\n        writeFile(this.path + '/yarn.lock', this.yarnLock.toString()),\n    ])\n  }\n}\n\nmodule.exports = Shrinkwrap\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}