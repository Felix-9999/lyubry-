{"ast":null,"code":"// This is the base class that the other fetcher types in lib\n// all descend from.\n// It handles the unpacking and retry logic that is shared among\n// all of the other Fetcher types.\n\nconst npa = require('npm-package-arg');\nconst ssri = require('ssri');\nconst {\n  promisify\n} = require('util');\nconst {\n  basename,\n  dirname\n} = require('path');\nconst rimraf = promisify(require('rimraf'));\nconst tar = require('tar');\nconst procLog = require('./util/proc-log.js');\nconst retry = require('promise-retry');\nconst fsm = require('fs-minipass');\nconst cacache = require('cacache');\nconst isPackageBin = require('./util/is-package-bin.js');\nconst getContents = require('@npmcli/installed-package-contents');\n\n// we only change ownership on unix platforms, and only if uid is 0\nconst selfOwner = process.getuid && process.getuid() === 0 ? {\n  uid: 0,\n  gid: process.getgid()\n} : null;\nconst chownr = selfOwner ? promisify(require('chownr')) : null;\nconst inferOwner = selfOwner ? require('infer-owner') : null;\nconst mkdirp = require('mkdirp');\nconst cacheDir = require('./util/cache-dir.js');\n\n// Private methods.\n// Child classes should not have to override these.\n// Users should never call them.\nconst _chown = Symbol('_chown');\nconst _extract = Symbol('_extract');\nconst _mkdir = Symbol('_mkdir');\nconst _empty = Symbol('_empty');\nconst _toFile = Symbol('_toFile');\nconst _tarxOptions = Symbol('_tarxOptions');\nconst _entryMode = Symbol('_entryMode');\nconst _istream = Symbol('_istream');\nconst _assertType = Symbol('_assertType');\nconst _tarballFromCache = Symbol('_tarballFromCache');\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\nconst _cacheFetches = Symbol.for('pacote.Fetcher._cacheFetches');\nclass FetcherBase {\n  constructor(spec, opts) {\n    if (!opts || typeof opts !== 'object') throw new TypeError('options object is required');\n    this.spec = npa(spec, opts.where);\n    this.allowGitIgnore = !!opts.allowGitIgnore;\n\n    // a bit redundant because presumably the caller already knows this,\n    // but it makes it easier to not have to keep track of the requested\n    // spec when we're dispatching thousands of these at once, and normalizing\n    // is nice.  saveSpec is preferred if set, because it turns stuff like\n    // x/y#committish into github:x/y#committish.  use name@rawSpec for\n    // registry deps so that we turn xyz and xyz@ -> xyz@\n    this.from = this.spec.registry ? `${this.spec.name}@${this.spec.rawSpec}` : this.spec.saveSpec;\n    this[_assertType]();\n    // clone the opts object so that others aren't upset when we mutate it\n    // by adding/modifying the integrity value.\n    this.opts = {\n      ...opts\n    };\n    this.cache = opts.cache || cacheDir();\n    this.resolved = opts.resolved || null;\n\n    // default to caching/verifying with sha512, that's what we usually have\n    // need to change this default, or start overriding it, when sha512\n    // is no longer strong enough.\n    this.defaultIntegrityAlgorithm = opts.defaultIntegrityAlgorithm || 'sha512';\n    if (typeof opts.integrity === 'string') this.opts.integrity = ssri.parse(opts.integrity);\n    this.package = null;\n    this.type = this.constructor.name;\n    this.fmode = opts.fmode || 0o666;\n    this.dmode = opts.dmode || 0o777;\n    // we don't need a default umask, because we don't chmod files coming\n    // out of package tarballs.  they're forced to have a mode that is\n    // valid, regardless of what's in the tarball entry, and then we let\n    // the process's umask setting do its job.  but if configured, we do\n    // respect it.\n    this.umask = opts.umask || 0;\n    this.log = opts.log || procLog;\n    this.preferOnline = !!opts.preferOnline;\n    this.preferOffline = !!opts.preferOffline;\n    this.offline = !!opts.offline;\n    this.before = opts.before;\n    this.fullMetadata = this.before ? true : !!opts.fullMetadata;\n    this.defaultTag = opts.defaultTag || 'latest';\n    this.registry = (opts.registry || 'https://registry.npmjs.org').replace(/\\/+$/, '');\n\n    // command to run 'prepare' scripts on directories and git dirs\n    // To use pacote with yarn, for example, set npmBin to 'yarn'\n    // and npmCliConfig with yarn's equivalents.\n    this.npmBin = opts.npmBin || 'npm';\n\n    // command to install deps for preparing\n    this.npmInstallCmd = opts.npmInstallCmd || ['install', '--force'];\n\n    // XXX fill more of this in based on what we know from this.opts\n    // we explicitly DO NOT fill in --tag, though, since we are often\n    // going to be packing in the context of a publish, which may set\n    // a dist-tag, but certainly wants to keep defaulting to latest.\n    this.npmCliConfig = opts.npmCliConfig || [`--cache=${dirname(this.cache)}`, `--prefer-offline=${!!this.preferOffline}`, `--prefer-online=${!!this.preferOnline}`, `--offline=${!!this.offline}`, ...(this.before ? [`--before=${this.before.toISOString()}`] : []), '--no-progress', '--no-save', '--no-audit',\n    // override any omit settings from the environment\n    '--include=dev', '--include=peer', '--include=optional',\n    // we need the actual things, not just the lockfile\n    '--no-package-lock-only', '--no-dry-run'];\n  }\n  get integrity() {\n    return this.opts.integrity || null;\n  }\n  set integrity(i) {\n    if (!i) return;\n    i = ssri.parse(i);\n    const current = this.opts.integrity;\n\n    // do not ever update an existing hash value, but do\n    // merge in NEW algos and hashes that we don't already have.\n    if (current) current.merge(i);else this.opts.integrity = i;\n  }\n  get notImplementedError() {\n    return new Error('not implemented in this fetcher type: ' + this.type);\n  }\n\n  // override in child classes\n  // Returns a Promise that resolves to this.resolved string value\n  resolve() {\n    return this.resolved ? Promise.resolve(this.resolved) : Promise.reject(this.notImplementedError);\n  }\n  packument() {\n    return Promise.reject(this.notImplementedError);\n  }\n\n  // override in child class\n  // returns a manifest containing:\n  // - name\n  // - version\n  // - _resolved\n  // - _integrity\n  // - plus whatever else was in there (corgi, full metadata, or pj file)\n  manifest() {\n    return Promise.reject(this.notImplementedError);\n  }\n\n  // private, should be overridden.\n  // Note that they should *not* calculate or check integrity or cache,\n  // but *just*  return the raw tarball data stream.\n  [_tarballFromResolved]() {\n    throw this.notImplementedError;\n  }\n\n  // public, should not be overridden\n  tarball() {\n    return this.tarballStream(stream => stream.concat().then(data => {\n      data.integrity = this.integrity && String(this.integrity);\n      data.resolved = this.resolved;\n      data.from = this.from;\n      return data;\n    }));\n  }\n\n  // private\n  // Note: cacache will raise a EINTEGRITY error if the integrity doesn't match\n  [_tarballFromCache]() {\n    return cacache.get.stream.byDigest(this.cache, this.integrity, this.opts);\n  }\n  get [_cacheFetches]() {\n    return true;\n  }\n  [_istream](stream) {\n    // everyone will need one of these, either for verifying or calculating\n    // We always set it, because we have might only have a weak legacy hex\n    // sha1 in the packument, and this MAY upgrade it to a stronger algo.\n    // If we had an integrity, and it doesn't match, then this does not\n    // override that error; the istream will raise the error before it\n    // gets to the point of re-setting the integrity.\n    const istream = ssri.integrityStream(this.opts);\n    istream.on('integrity', i => this.integrity = i);\n    stream.on('error', er => istream.emit('error', er));\n\n    // if not caching this, just pipe through to the istream and return it\n    if (!this.opts.cache || !this[_cacheFetches]) return stream.pipe(istream);\n\n    // we have to return a stream that gets ALL the data, and proxies errors,\n    // but then pipe from the original tarball stream into the cache as well.\n    // To do this without losing any data, and since the cacache put stream\n    // is not a passthrough, we have to pipe from the original stream into\n    // the cache AFTER we pipe into the istream.  Since the cache stream\n    // has an asynchronous flush to write its contents to disk, we need to\n    // defer the istream end until the cache stream ends.\n    stream.pipe(istream, {\n      end: false\n    });\n    const cstream = cacache.put.stream(this.opts.cache, `pacote:tarball:${this.from}`, this.opts);\n    stream.pipe(cstream);\n    // defer istream end until after cstream\n    // cache write errors should not crash the fetch, this is best-effort.\n    cstream.promise().catch(() => {}).then(() => istream.end());\n    return istream;\n  }\n  pickIntegrityAlgorithm() {\n    return this.integrity ? this.integrity.pickAlgorithm(this.opts) : this.defaultIntegrityAlgorithm;\n  }\n\n  // TODO: check error class, once those are rolled out to our deps\n  isDataCorruptionError(er) {\n    return er.code === 'EINTEGRITY' || er.code === 'Z_DATA_ERROR';\n  }\n\n  // override the types getter\n  get types() {}\n  [_assertType]() {\n    if (this.types && !this.types.includes(this.spec.type)) {\n      throw new TypeError(`Wrong spec type (${this.spec.type}) for ${this.constructor.name}. Supported types: ${this.types.join(', ')}`);\n    }\n  }\n\n  // We allow ENOENTs from cacache, but not anywhere else.\n  // An ENOENT trying to read a tgz file, for example, is Right Out.\n  isRetriableError(er) {\n    // TODO: check error class, once those are rolled out to our deps\n    return this.isDataCorruptionError(er) || er.code === 'ENOENT' || er.code === 'EISDIR';\n  }\n\n  // Mostly internal, but has some uses\n  // Pass in a function which returns a promise\n  // Function will be called 1 or more times with streams that may fail.\n  // Retries:\n  // Function MUST handle errors on the stream by rejecting the promise,\n  // so that retry logic can pick it up and either retry or fail whatever\n  // promise it was making (ie, failing extraction, etc.)\n  //\n  // The return value of this method is a Promise that resolves the same\n  // as whatever the streamHandler resolves to.\n  //\n  // This should never be overridden by child classes, but it is public.\n  tarballStream(streamHandler) {\n    // Only short-circuit via cache if we have everything else we'll need,\n    // and the user has not expressed a preference for checking online.\n\n    const fromCache = !this.preferOnline && this.integrity && this.resolved ? streamHandler(this[_tarballFromCache]()).catch(er => {\n      if (this.isDataCorruptionError(er)) {\n        this.log.warn('tarball', `cached data for ${this.spec} (${this.integrity}) seems to be corrupted. Refreshing cache.`);\n        return this.cleanupCached().then(() => {\n          throw er;\n        });\n      } else {\n        throw er;\n      }\n    }) : null;\n    const fromResolved = er => {\n      if (er) {\n        if (!this.isRetriableError(er)) throw er;\n        this.log.silly('tarball', `no local data for ${this.spec}. Extracting by manifest.`);\n      }\n      return this.resolve().then(() => retry(tryAgain => streamHandler(this[_istream](this[_tarballFromResolved]())).catch(er => {\n        // Most likely data integrity.  A cache ENOENT error is unlikely\n        // here, since we're definitely not reading from the cache, but it\n        // IS possible that the fetch subsystem accessed the cache, and the\n        // entry got blown away or something.  Try one more time to be sure.\n        if (this.isRetriableError(er)) {\n          this.log.warn('tarball', `tarball data for ${this.spec} (${this.integrity}) seems to be corrupted. Trying again.`);\n          return this.cleanupCached().then(() => tryAgain(er));\n        }\n        throw er;\n      }), {\n        retries: 1,\n        minTimeout: 0,\n        maxTimeout: 0\n      }));\n    };\n    return fromCache ? fromCache.catch(fromResolved) : fromResolved();\n  }\n  cleanupCached() {\n    return cacache.rm.content(this.cache, this.integrity, this.opts);\n  }\n  async [_chown](path, uid, gid) {\n    return selfOwner && (selfOwner.gid !== gid || selfOwner.uid !== uid) ? chownr(path, uid, gid) : /* istanbul ignore next - we don't test in root-owned folders */null;\n  }\n  [_empty](path) {\n    return getContents({\n      path,\n      depth: 1\n    }).then(contents => Promise.all(contents.map(entry => rimraf(entry))));\n  }\n  [_mkdir](dest) {\n    // if we're bothering to do owner inference, then do it.\n    // otherwise just make the dir, and return an empty object.\n    // always empty the dir dir to start with, but do so\n    // _after_ inferring the owner, in case there's an existing folder\n    // there that we would want to preserve which differs from the\n    // parent folder (rare, but probably happens sometimes).\n    return !inferOwner ? this[_empty](dest).then(() => mkdirp(dest)).then(() => ({})) : inferOwner(dest).then(({\n      uid,\n      gid\n    }) => this[_empty](dest).then(() => mkdirp(dest)).then(made => {\n      // ignore the || dest part in coverage.  It's there to handle\n      // race conditions where the dir may be made by someone else\n      // after being removed by us.\n      const dir = made || /* istanbul ignore next */dest;\n      return this[_chown](dir, uid, gid);\n    }).then(() => ({\n      uid,\n      gid\n    })));\n  }\n\n  // extraction is always the same.  the only difference is where\n  // the tarball comes from.\n  extract(dest) {\n    return this[_mkdir](dest).then(({\n      uid,\n      gid\n    }) => this.tarballStream(tarball => this[_extract](dest, tarball, uid, gid)));\n  }\n  [_toFile](dest) {\n    return this.tarballStream(str => new Promise((res, rej) => {\n      const writer = new fsm.WriteStream(dest);\n      str.on('error', er => writer.emit('error', er));\n      writer.on('error', er => rej(er));\n      writer.on('close', () => res({\n        integrity: this.integrity && String(this.integrity),\n        resolved: this.resolved,\n        from: this.from\n      }));\n      str.pipe(writer);\n    }));\n  }\n\n  // don't use this[_mkdir] because we don't want to rimraf anything\n  tarballFile(dest) {\n    const dir = dirname(dest);\n    return !inferOwner ? mkdirp(dir).then(() => this[_toFile](dest)) : inferOwner(dest).then(({\n      uid,\n      gid\n    }) => mkdirp(dir).then(made => this[_toFile](dest).then(res => this[_chown](made || dir, uid, gid).then(() => res))));\n  }\n  [_extract](dest, tarball, uid, gid) {\n    const extractor = tar.x(this[_tarxOptions]({\n      cwd: dest,\n      uid,\n      gid\n    }));\n    const p = new Promise((resolve, reject) => {\n      extractor.on('end', () => {\n        resolve({\n          resolved: this.resolved,\n          integrity: this.integrity && String(this.integrity),\n          from: this.from\n        });\n      });\n      extractor.on('error', er => {\n        this.log.warn('tar', er.message);\n        this.log.silly('tar', er);\n        reject(er);\n      });\n      tarball.on('error', er => reject(er));\n    });\n    tarball.pipe(extractor);\n    return p;\n  }\n\n  // always ensure that entries are at least as permissive as our configured\n  // dmode/fmode, but never more permissive than the umask allows.\n  [_entryMode](path, mode, type) {\n    const m = /Directory|GNUDumpDir/.test(type) ? this.dmode : /File$/.test(type) ? this.fmode : /* istanbul ignore next - should never happen in a pkg */0;\n\n    // make sure package bins are executable\n    const exe = isPackageBin(this.package, path) ? 0o111 : 0;\n    // always ensure that files are read/writable by the owner\n    return (mode | m) & ~this.umask | exe | 0o600;\n  }\n  [_tarxOptions]({\n    cwd,\n    uid,\n    gid\n  }) {\n    const sawIgnores = new Set();\n    return {\n      cwd,\n      noChmod: true,\n      noMtime: true,\n      filter: (name, entry) => {\n        if (/Link$/.test(entry.type)) return false;\n        entry.mode = this[_entryMode](entry.path, entry.mode, entry.type);\n        // this replicates the npm pack behavior where .gitignore files\n        // are treated like .npmignore files, but only if a .npmignore\n        // file is not present.\n        if (/File$/.test(entry.type)) {\n          const base = basename(entry.path);\n          if (base === '.npmignore') sawIgnores.add(entry.path);else if (base === '.gitignore' && !this.allowGitIgnore) {\n            // rename, but only if there's not already a .npmignore\n            const ni = entry.path.replace(/\\.gitignore$/, '.npmignore');\n            if (sawIgnores.has(ni)) return false;\n            entry.path = ni;\n          }\n          return true;\n        }\n      },\n      strip: 1,\n      onwarn: /* istanbul ignore next - we can trust that tar logs */\n      (code, msg, data) => {\n        this.log.warn('tar', code, msg);\n        this.log.silly('tar', code, msg, data);\n      },\n      uid,\n      gid,\n      umask: this.umask\n    };\n  }\n}\nmodule.exports = FetcherBase;\n\n// Child classes\nconst GitFetcher = require('./git.js');\nconst RegistryFetcher = require('./registry.js');\nconst FileFetcher = require('./file.js');\nconst DirFetcher = require('./dir.js');\nconst RemoteFetcher = require('./remote.js');\n\n// Get an appropriate fetcher object from a spec and options\nFetcherBase.get = (rawSpec, opts = {}) => {\n  const spec = npa(rawSpec, opts.where);\n  switch (spec.type) {\n    case 'git':\n      return new GitFetcher(spec, opts);\n    case 'remote':\n      return new RemoteFetcher(spec, opts);\n    case 'version':\n    case 'range':\n    case 'tag':\n    case 'alias':\n      return new RegistryFetcher(spec.subSpec || spec, opts);\n    case 'file':\n      return new FileFetcher(spec, opts);\n    case 'directory':\n      return new DirFetcher(spec, opts);\n    default:\n      throw new TypeError('Unknown spec type: ' + spec.type);\n  }\n};","map":{"version":3,"names":["npa","require","ssri","promisify","basename","dirname","rimraf","tar","procLog","retry","fsm","cacache","isPackageBin","getContents","selfOwner","process","getuid","uid","gid","getgid","chownr","inferOwner","mkdirp","cacheDir","_chown","Symbol","_extract","_mkdir","_empty","_toFile","_tarxOptions","_entryMode","_istream","_assertType","_tarballFromCache","_tarballFromResolved","for","_cacheFetches","FetcherBase","constructor","spec","opts","TypeError","where","allowGitIgnore","from","registry","name","rawSpec","saveSpec","cache","resolved","defaultIntegrityAlgorithm","integrity","parse","package","type","fmode","dmode","umask","log","preferOnline","preferOffline","offline","before","fullMetadata","defaultTag","replace","npmBin","npmInstallCmd","npmCliConfig","toISOString","i","current","merge","notImplementedError","Error","resolve","Promise","reject","packument","manifest","tarball","tarballStream","stream","concat","then","data","String","get","byDigest","istream","integrityStream","on","er","emit","pipe","end","cstream","put","promise","catch","pickIntegrityAlgorithm","pickAlgorithm","isDataCorruptionError","code","types","includes","join","isRetriableError","streamHandler","fromCache","warn","cleanupCached","fromResolved","silly","tryAgain","retries","minTimeout","maxTimeout","rm","content","path","depth","contents","all","map","entry","dest","made","dir","extract","str","res","rej","writer","WriteStream","tarballFile","extractor","x","cwd","p","message","mode","m","test","exe","sawIgnores","Set","noChmod","noMtime","filter","base","add","ni","has","strip","onwarn","msg","module","exports","GitFetcher","RegistryFetcher","FileFetcher","DirFetcher","RemoteFetcher","subSpec"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/pacote/lib/fetcher.js"],"sourcesContent":["// This is the base class that the other fetcher types in lib\n// all descend from.\n// It handles the unpacking and retry logic that is shared among\n// all of the other Fetcher types.\n\nconst npa = require('npm-package-arg')\nconst ssri = require('ssri')\nconst { promisify } = require('util')\nconst { basename, dirname } = require('path')\nconst rimraf = promisify(require('rimraf'))\nconst tar = require('tar')\nconst procLog = require('./util/proc-log.js')\nconst retry = require('promise-retry')\nconst fsm = require('fs-minipass')\nconst cacache = require('cacache')\nconst isPackageBin = require('./util/is-package-bin.js')\nconst getContents = require('@npmcli/installed-package-contents')\n\n// we only change ownership on unix platforms, and only if uid is 0\nconst selfOwner = process.getuid && process.getuid() === 0 ? {\n  uid: 0,\n  gid: process.getgid(),\n} : null\nconst chownr = selfOwner ? promisify(require('chownr')) : null\nconst inferOwner = selfOwner ? require('infer-owner') : null\nconst mkdirp = require('mkdirp')\nconst cacheDir = require('./util/cache-dir.js')\n\n// Private methods.\n// Child classes should not have to override these.\n// Users should never call them.\nconst _chown = Symbol('_chown')\nconst _extract = Symbol('_extract')\nconst _mkdir = Symbol('_mkdir')\nconst _empty = Symbol('_empty')\nconst _toFile = Symbol('_toFile')\nconst _tarxOptions = Symbol('_tarxOptions')\nconst _entryMode = Symbol('_entryMode')\nconst _istream = Symbol('_istream')\nconst _assertType = Symbol('_assertType')\nconst _tarballFromCache = Symbol('_tarballFromCache')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst _cacheFetches = Symbol.for('pacote.Fetcher._cacheFetches')\n\nclass FetcherBase {\n  constructor (spec, opts) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('options object is required')\n    this.spec = npa(spec, opts.where)\n\n    this.allowGitIgnore = !!opts.allowGitIgnore\n\n    // a bit redundant because presumably the caller already knows this,\n    // but it makes it easier to not have to keep track of the requested\n    // spec when we're dispatching thousands of these at once, and normalizing\n    // is nice.  saveSpec is preferred if set, because it turns stuff like\n    // x/y#committish into github:x/y#committish.  use name@rawSpec for\n    // registry deps so that we turn xyz and xyz@ -> xyz@\n    this.from = this.spec.registry\n      ? `${this.spec.name}@${this.spec.rawSpec}` : this.spec.saveSpec\n\n    this[_assertType]()\n    // clone the opts object so that others aren't upset when we mutate it\n    // by adding/modifying the integrity value.\n    this.opts = {...opts}\n\n    this.cache = opts.cache || cacheDir()\n    this.resolved = opts.resolved || null\n\n    // default to caching/verifying with sha512, that's what we usually have\n    // need to change this default, or start overriding it, when sha512\n    // is no longer strong enough.\n    this.defaultIntegrityAlgorithm = opts.defaultIntegrityAlgorithm || 'sha512'\n\n    if (typeof opts.integrity === 'string')\n      this.opts.integrity = ssri.parse(opts.integrity)\n\n    this.package = null\n    this.type = this.constructor.name\n    this.fmode = opts.fmode || 0o666\n    this.dmode = opts.dmode || 0o777\n    // we don't need a default umask, because we don't chmod files coming\n    // out of package tarballs.  they're forced to have a mode that is\n    // valid, regardless of what's in the tarball entry, and then we let\n    // the process's umask setting do its job.  but if configured, we do\n    // respect it.\n    this.umask = opts.umask || 0\n    this.log = opts.log || procLog\n\n    this.preferOnline = !!opts.preferOnline\n    this.preferOffline = !!opts.preferOffline\n    this.offline = !!opts.offline\n\n    this.before = opts.before\n    this.fullMetadata = this.before ? true : !!opts.fullMetadata\n\n    this.defaultTag = opts.defaultTag || 'latest'\n    this.registry = (opts.registry || 'https://registry.npmjs.org')\n      .replace(/\\/+$/, '')\n\n    // command to run 'prepare' scripts on directories and git dirs\n    // To use pacote with yarn, for example, set npmBin to 'yarn'\n    // and npmCliConfig with yarn's equivalents.\n    this.npmBin = opts.npmBin || 'npm'\n\n    // command to install deps for preparing\n    this.npmInstallCmd = opts.npmInstallCmd || [ 'install', '--force' ]\n\n    // XXX fill more of this in based on what we know from this.opts\n    // we explicitly DO NOT fill in --tag, though, since we are often\n    // going to be packing in the context of a publish, which may set\n    // a dist-tag, but certainly wants to keep defaulting to latest.\n    this.npmCliConfig = opts.npmCliConfig || [\n      `--cache=${dirname(this.cache)}`,\n      `--prefer-offline=${!!this.preferOffline}`,\n      `--prefer-online=${!!this.preferOnline}`,\n      `--offline=${!!this.offline}`,\n      ...(this.before ? [`--before=${this.before.toISOString()}`] : []),\n      '--no-progress',\n      '--no-save',\n      '--no-audit',\n      // override any omit settings from the environment\n      '--include=dev',\n      '--include=peer',\n      '--include=optional',\n      // we need the actual things, not just the lockfile\n      '--no-package-lock-only',\n      '--no-dry-run',\n    ]\n  }\n\n  get integrity () {\n    return this.opts.integrity || null\n  }\n  set integrity (i) {\n    if (!i)\n      return\n\n    i = ssri.parse(i)\n    const current = this.opts.integrity\n\n    // do not ever update an existing hash value, but do\n    // merge in NEW algos and hashes that we don't already have.\n    if (current)\n      current.merge(i)\n    else\n      this.opts.integrity = i\n  }\n\n  get notImplementedError () {\n    return new Error('not implemented in this fetcher type: ' + this.type)\n  }\n\n  // override in child classes\n  // Returns a Promise that resolves to this.resolved string value\n  resolve () {\n    return this.resolved ? Promise.resolve(this.resolved)\n      : Promise.reject(this.notImplementedError)\n  }\n\n  packument () {\n    return Promise.reject(this.notImplementedError)\n  }\n\n  // override in child class\n  // returns a manifest containing:\n  // - name\n  // - version\n  // - _resolved\n  // - _integrity\n  // - plus whatever else was in there (corgi, full metadata, or pj file)\n  manifest () {\n    return Promise.reject(this.notImplementedError)\n  }\n\n  // private, should be overridden.\n  // Note that they should *not* calculate or check integrity or cache,\n  // but *just*  return the raw tarball data stream.\n  [_tarballFromResolved] () {\n    throw this.notImplementedError\n  }\n\n  // public, should not be overridden\n  tarball () {\n    return this.tarballStream(stream => stream.concat().then(data => {\n      data.integrity = this.integrity && String(this.integrity)\n      data.resolved = this.resolved\n      data.from = this.from\n      return data\n    }))\n  }\n\n  // private\n  // Note: cacache will raise a EINTEGRITY error if the integrity doesn't match\n  [_tarballFromCache] () {\n    return cacache.get.stream.byDigest(this.cache, this.integrity, this.opts)\n  }\n\n  get [_cacheFetches] () {\n    return true\n  }\n\n  [_istream] (stream) {\n    // everyone will need one of these, either for verifying or calculating\n    // We always set it, because we have might only have a weak legacy hex\n    // sha1 in the packument, and this MAY upgrade it to a stronger algo.\n    // If we had an integrity, and it doesn't match, then this does not\n    // override that error; the istream will raise the error before it\n    // gets to the point of re-setting the integrity.\n    const istream = ssri.integrityStream(this.opts)\n    istream.on('integrity', i => this.integrity = i)\n    stream.on('error', er => istream.emit('error', er))\n\n    // if not caching this, just pipe through to the istream and return it\n    if (!this.opts.cache || !this[_cacheFetches])\n      return stream.pipe(istream)\n\n    // we have to return a stream that gets ALL the data, and proxies errors,\n    // but then pipe from the original tarball stream into the cache as well.\n    // To do this without losing any data, and since the cacache put stream\n    // is not a passthrough, we have to pipe from the original stream into\n    // the cache AFTER we pipe into the istream.  Since the cache stream\n    // has an asynchronous flush to write its contents to disk, we need to\n    // defer the istream end until the cache stream ends.\n    stream.pipe(istream, { end: false })\n    const cstream = cacache.put.stream(\n      this.opts.cache,\n      `pacote:tarball:${this.from}`,\n      this.opts\n    )\n    stream.pipe(cstream)\n    // defer istream end until after cstream\n    // cache write errors should not crash the fetch, this is best-effort.\n    cstream.promise().catch(() => {}).then(() => istream.end())\n\n    return istream\n  }\n\n  pickIntegrityAlgorithm () {\n    return this.integrity ? this.integrity.pickAlgorithm(this.opts)\n      : this.defaultIntegrityAlgorithm\n  }\n\n  // TODO: check error class, once those are rolled out to our deps\n  isDataCorruptionError (er) {\n    return er.code === 'EINTEGRITY' || er.code === 'Z_DATA_ERROR'\n  }\n\n  // override the types getter\n  get types () {}\n  [_assertType] () {\n    if (this.types && !this.types.includes(this.spec.type)) {\n      throw new TypeError(`Wrong spec type (${\n        this.spec.type\n      }) for ${\n        this.constructor.name\n      }. Supported types: ${this.types.join(', ')}`)\n    }\n  }\n\n  // We allow ENOENTs from cacache, but not anywhere else.\n  // An ENOENT trying to read a tgz file, for example, is Right Out.\n  isRetriableError (er) {\n    // TODO: check error class, once those are rolled out to our deps\n    return this.isDataCorruptionError(er) ||\n      er.code === 'ENOENT' ||\n      er.code === 'EISDIR'\n  }\n\n  // Mostly internal, but has some uses\n  // Pass in a function which returns a promise\n  // Function will be called 1 or more times with streams that may fail.\n  // Retries:\n  // Function MUST handle errors on the stream by rejecting the promise,\n  // so that retry logic can pick it up and either retry or fail whatever\n  // promise it was making (ie, failing extraction, etc.)\n  //\n  // The return value of this method is a Promise that resolves the same\n  // as whatever the streamHandler resolves to.\n  //\n  // This should never be overridden by child classes, but it is public.\n  tarballStream (streamHandler) {\n    // Only short-circuit via cache if we have everything else we'll need,\n    // and the user has not expressed a preference for checking online.\n\n    const fromCache = (\n      !this.preferOnline &&\n      this.integrity &&\n      this.resolved\n    ) ? streamHandler(this[_tarballFromCache]()).catch(er => {\n      if (this.isDataCorruptionError(er)) {\n        this.log.warn('tarball', `cached data for ${\n          this.spec\n        } (${this.integrity}) seems to be corrupted. Refreshing cache.`)\n        return this.cleanupCached().then(() => { throw er })\n      } else {\n        throw er\n      }\n    }) : null\n\n    const fromResolved = er => {\n      if (er) {\n        if (!this.isRetriableError(er))\n          throw er\n        this.log.silly('tarball', `no local data for ${\n          this.spec\n        }. Extracting by manifest.`)\n      }\n      return this.resolve().then(() => retry(tryAgain =>\n        streamHandler(this[_istream](this[_tarballFromResolved]()))\n        .catch(er => {\n          // Most likely data integrity.  A cache ENOENT error is unlikely\n          // here, since we're definitely not reading from the cache, but it\n          // IS possible that the fetch subsystem accessed the cache, and the\n          // entry got blown away or something.  Try one more time to be sure.\n          if (this.isRetriableError(er)) {\n            this.log.warn('tarball', `tarball data for ${\n              this.spec\n            } (${this.integrity}) seems to be corrupted. Trying again.`)\n            return this.cleanupCached().then(() => tryAgain(er))\n          }\n          throw er\n        }), { retries: 1, minTimeout: 0, maxTimeout: 0 }))\n    }\n\n    return fromCache ? fromCache.catch(fromResolved) : fromResolved()\n  }\n\n  cleanupCached () {\n    return cacache.rm.content(this.cache, this.integrity, this.opts)\n  }\n\n  async [_chown] (path, uid, gid) {\n    return selfOwner && (selfOwner.gid !== gid || selfOwner.uid !== uid)\n      ? chownr(path, uid, gid)\n      : /* istanbul ignore next - we don't test in root-owned folders */ null\n  }\n\n  [_empty] (path) {\n    return getContents({path, depth: 1}).then(contents => Promise.all(\n      contents.map(entry => rimraf(entry))))\n  }\n\n  [_mkdir] (dest) {\n    // if we're bothering to do owner inference, then do it.\n    // otherwise just make the dir, and return an empty object.\n    // always empty the dir dir to start with, but do so\n    // _after_ inferring the owner, in case there's an existing folder\n    // there that we would want to preserve which differs from the\n    // parent folder (rare, but probably happens sometimes).\n    return !inferOwner\n      ? this[_empty](dest).then(() => mkdirp(dest)).then(() => ({}))\n      : inferOwner(dest).then(({uid, gid}) =>\n        this[_empty](dest)\n          .then(() => mkdirp(dest))\n          .then(made => {\n            // ignore the || dest part in coverage.  It's there to handle\n            // race conditions where the dir may be made by someone else\n            // after being removed by us.\n            const dir = made || /* istanbul ignore next */ dest\n            return this[_chown](dir, uid, gid)\n          })\n          .then(() => ({uid, gid})))\n  }\n\n  // extraction is always the same.  the only difference is where\n  // the tarball comes from.\n  extract (dest) {\n    return this[_mkdir](dest).then(({uid, gid}) =>\n      this.tarballStream(tarball => this[_extract](dest, tarball, uid, gid)))\n  }\n\n  [_toFile] (dest) {\n    return this.tarballStream(str => new Promise((res, rej) => {\n      const writer = new fsm.WriteStream(dest)\n      str.on('error', er => writer.emit('error', er))\n      writer.on('error', er => rej(er))\n      writer.on('close', () => res({\n        integrity: this.integrity && String(this.integrity),\n        resolved: this.resolved,\n        from: this.from,\n      }))\n      str.pipe(writer)\n    }))\n  }\n\n  // don't use this[_mkdir] because we don't want to rimraf anything\n  tarballFile (dest) {\n    const dir = dirname(dest)\n    return !inferOwner\n      ? mkdirp(dir).then(() => this[_toFile](dest))\n      : inferOwner(dest).then(({uid, gid}) =>\n        mkdirp(dir).then(made => this[_toFile](dest)\n          .then(res => this[_chown](made || dir, uid, gid)\n            .then(() => res))))\n  }\n\n  [_extract] (dest, tarball, uid, gid) {\n    const extractor = tar.x(this[_tarxOptions]({ cwd: dest, uid, gid }))\n    const p = new Promise((resolve, reject) => {\n      extractor.on('end', () => {\n        resolve({\n          resolved: this.resolved,\n          integrity: this.integrity && String(this.integrity),\n          from: this.from,\n        })\n      })\n\n      extractor.on('error', er => {\n        this.log.warn('tar', er.message)\n        this.log.silly('tar', er)\n        reject(er)\n      })\n\n      tarball.on('error', er => reject(er))\n    })\n\n    tarball.pipe(extractor)\n    return p\n  }\n\n  // always ensure that entries are at least as permissive as our configured\n  // dmode/fmode, but never more permissive than the umask allows.\n  [_entryMode] (path, mode, type) {\n    const m = /Directory|GNUDumpDir/.test(type) ? this.dmode\n      : /File$/.test(type) ? this.fmode\n      : /* istanbul ignore next - should never happen in a pkg */ 0\n\n    // make sure package bins are executable\n    const exe = isPackageBin(this.package, path) ? 0o111 : 0\n    // always ensure that files are read/writable by the owner\n    return ((mode | m) & ~this.umask) | exe | 0o600\n  }\n\n  [_tarxOptions] ({ cwd, uid, gid }) {\n    const sawIgnores = new Set()\n    return {\n      cwd,\n      noChmod: true,\n      noMtime: true,\n      filter: (name, entry) => {\n        if (/Link$/.test(entry.type))\n          return false\n        entry.mode = this[_entryMode](entry.path, entry.mode, entry.type)\n        // this replicates the npm pack behavior where .gitignore files\n        // are treated like .npmignore files, but only if a .npmignore\n        // file is not present.\n        if (/File$/.test(entry.type)) {\n          const base = basename(entry.path)\n          if (base === '.npmignore')\n            sawIgnores.add(entry.path)\n          else if (base === '.gitignore' && !this.allowGitIgnore) {\n            // rename, but only if there's not already a .npmignore\n            const ni = entry.path.replace(/\\.gitignore$/, '.npmignore')\n            if (sawIgnores.has(ni))\n              return false\n            entry.path = ni\n          }\n          return true\n        }\n      },\n      strip: 1,\n      onwarn: /* istanbul ignore next - we can trust that tar logs */\n      (code, msg, data) => {\n        this.log.warn('tar', code, msg)\n        this.log.silly('tar', code, msg, data)\n      },\n      uid,\n      gid,\n      umask: this.umask,\n    }\n  }\n}\n\nmodule.exports = FetcherBase\n\n// Child classes\nconst GitFetcher = require('./git.js')\nconst RegistryFetcher = require('./registry.js')\nconst FileFetcher = require('./file.js')\nconst DirFetcher = require('./dir.js')\nconst RemoteFetcher = require('./remote.js')\n\n// Get an appropriate fetcher object from a spec and options\nFetcherBase.get = (rawSpec, opts = {}) => {\n  const spec = npa(rawSpec, opts.where)\n  switch (spec.type) {\n    case 'git':\n      return new GitFetcher(spec, opts)\n\n    case 'remote':\n      return new RemoteFetcher(spec, opts)\n\n    case 'version':\n    case 'range':\n    case 'tag':\n    case 'alias':\n      return new RegistryFetcher(spec.subSpec || spec, opts)\n\n    case 'file':\n      return new FileFetcher(spec, opts)\n\n    case 'directory':\n      return new DirFetcher(spec, opts)\n\n    default:\n      throw new TypeError('Unknown spec type: ' + spec.type)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}