{"ast":null,"code":"// The goal here is to minimize both git workload and\n// the number of refs we download over the network.\n//\n// Every method ends up with the checked out working dir\n// at the specified ref, and resolves with the git sha.\n\n// Only certain whitelisted hosts get shallow cloning.\n// Many hosts (including GHE) don't always support it.\n// A failed shallow fetch takes a LOT longer than a full\n// fetch in most cases, so we skip it entirely.\n// Set opts.gitShallow = true/false to force this behavior\n// one way or the other.\nconst shallowHosts = new Set(['github.com', 'gist.github.com', 'gitlab.com', 'bitbucket.com', 'bitbucket.org']);\n// we have to use url.parse until we add the same shim that hosted-git-info has\n// to handle scp:// urls\nconst {\n  parse\n} = require('url'); // eslint-disable-line node/no-deprecated-api\nconst {\n  basename,\n  resolve\n} = require('path');\nconst revs = require('./revs.js');\nconst spawn = require('./spawn.js');\nconst {\n  isWindows\n} = require('./utils.js');\nconst pickManifest = require('npm-pick-manifest');\nconst fs = require('fs');\nconst mkdirp = require('mkdirp');\nmodule.exports = (repo, ref = 'HEAD', target = null, opts = {}) => revs(repo, opts).then(revs => clone(repo, revs, ref, resolveRef(revs, ref, opts), target || defaultTarget(repo, opts.cwd), opts));\nconst maybeShallow = (repo, opts) => {\n  if (opts.gitShallow === false || opts.gitShallow) {\n    return opts.gitShallow;\n  }\n  return shallowHosts.has(parse(repo).host);\n};\nconst defaultTarget = (repo, /* istanbul ignore next */cwd = process.cwd()) => resolve(cwd, basename(repo.replace(/[/\\\\]?\\.git$/, '')));\nconst clone = (repo, revs, ref, revDoc, target, opts) => {\n  if (!revDoc) {\n    return unresolved(repo, ref, target, opts);\n  }\n  if (revDoc.sha === revs.refs.HEAD.sha) {\n    return plain(repo, revDoc, target, opts);\n  }\n  if (revDoc.type === 'tag' || revDoc.type === 'branch') {\n    return branch(repo, revDoc, target, opts);\n  }\n  return other(repo, revDoc, target, opts);\n};\nconst resolveRef = (revs, ref, opts) => {\n  const {\n    spec = {}\n  } = opts;\n  ref = spec.gitCommittish || ref;\n  /* istanbul ignore next - will fail anyway, can't pull */\n  if (!revs) {\n    return null;\n  }\n  if (spec.gitRange) {\n    return pickManifest(revs, spec.gitRange, opts);\n  }\n  if (!ref) {\n    return revs.refs.HEAD;\n  }\n  if (revs.refs[ref]) {\n    return revs.refs[ref];\n  }\n  if (revs.shas[ref]) {\n    return revs.refs[revs.shas[ref][0]];\n  }\n  return null;\n};\n\n// pull request or some other kind of advertised ref\nconst other = (repo, revDoc, target, opts) => {\n  const shallow = maybeShallow(repo, opts);\n  const fetchOrigin = ['fetch', 'origin', revDoc.rawRef].concat(shallow ? ['--depth=1'] : []);\n  const git = args => spawn(args, {\n    ...opts,\n    cwd: target\n  });\n  return mkdirp(target).then(() => git(['init'])).then(() => isWindows(opts) ? git(['config', '--local', '--add', 'core.longpaths', 'true']) : null).then(() => git(['remote', 'add', 'origin', repo])).then(() => git(fetchOrigin)).then(() => git(['checkout', revDoc.sha])).then(() => updateSubmodules(target, opts)).then(() => revDoc.sha);\n};\n\n// tag or branches.  use -b\nconst branch = (repo, revDoc, target, opts) => {\n  const args = ['clone', '-b', revDoc.ref, repo, target, '--recurse-submodules'];\n  if (maybeShallow(repo, opts)) {\n    args.push('--depth=1');\n  }\n  if (isWindows(opts)) {\n    args.push('--config', 'core.longpaths=true');\n  }\n  return spawn(args, opts).then(() => revDoc.sha);\n};\n\n// just the head.  clone it\nconst plain = (repo, revDoc, target, opts) => {\n  const args = ['clone', repo, target, '--recurse-submodules'];\n  if (maybeShallow(repo, opts)) {\n    args.push('--depth=1');\n  }\n  if (isWindows(opts)) {\n    args.push('--config', 'core.longpaths=true');\n  }\n  return spawn(args, opts).then(() => revDoc.sha);\n};\nconst updateSubmodules = (target, opts) => new Promise(resolve => fs.stat(target + '/.gitmodules', er => {\n  if (er) {\n    return resolve(null);\n  }\n  return resolve(spawn(['submodule', 'update', '-q', '--init', '--recursive'], {\n    ...opts,\n    cwd: target\n  }));\n}));\nconst unresolved = (repo, ref, target, opts) => {\n  // can't do this one shallowly, because the ref isn't advertised\n  // but we can avoid checking out the working dir twice, at least\n  const lp = isWindows(opts) ? ['--config', 'core.longpaths=true'] : [];\n  const cloneArgs = ['clone', '--mirror', '-q', repo, target + '/.git'];\n  const git = args => spawn(args, {\n    ...opts,\n    cwd: target\n  });\n  return mkdirp(target).then(() => git(cloneArgs.concat(lp))).then(() => git(['init'])).then(() => git(['checkout', ref])).then(() => updateSubmodules(target, opts)).then(() => git(['rev-parse', '--revs-only', 'HEAD'])).then(({\n    stdout\n  }) => stdout.trim());\n};","map":{"version":3,"names":["shallowHosts","Set","parse","require","basename","resolve","revs","spawn","isWindows","pickManifest","fs","mkdirp","module","exports","repo","ref","target","opts","then","clone","resolveRef","defaultTarget","cwd","maybeShallow","gitShallow","has","host","process","replace","revDoc","unresolved","sha","refs","HEAD","plain","type","branch","other","spec","gitCommittish","gitRange","shas","shallow","fetchOrigin","rawRef","concat","git","args","updateSubmodules","push","Promise","stat","er","lp","cloneArgs","stdout","trim"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/git/lib/clone.js"],"sourcesContent":["// The goal here is to minimize both git workload and\n// the number of refs we download over the network.\n//\n// Every method ends up with the checked out working dir\n// at the specified ref, and resolves with the git sha.\n\n// Only certain whitelisted hosts get shallow cloning.\n// Many hosts (including GHE) don't always support it.\n// A failed shallow fetch takes a LOT longer than a full\n// fetch in most cases, so we skip it entirely.\n// Set opts.gitShallow = true/false to force this behavior\n// one way or the other.\nconst shallowHosts = new Set([\n  'github.com',\n  'gist.github.com',\n  'gitlab.com',\n  'bitbucket.com',\n  'bitbucket.org'\n])\n// we have to use url.parse until we add the same shim that hosted-git-info has\n// to handle scp:// urls\nconst { parse } = require('url') // eslint-disable-line node/no-deprecated-api\nconst { basename, resolve } = require('path')\n\nconst revs = require('./revs.js')\nconst spawn = require('./spawn.js')\nconst { isWindows } = require('./utils.js')\n\nconst pickManifest = require('npm-pick-manifest')\nconst fs = require('fs')\nconst mkdirp = require('mkdirp')\n\nmodule.exports = (repo, ref = 'HEAD', target = null, opts = {}) =>\n  revs(repo, opts).then(revs => clone(\n    repo,\n    revs,\n    ref,\n    resolveRef(revs, ref, opts),\n    target || defaultTarget(repo, opts.cwd),\n    opts\n  ))\n\nconst maybeShallow = (repo, opts) => {\n  if (opts.gitShallow === false || opts.gitShallow) {\n    return opts.gitShallow\n  }\n  return shallowHosts.has(parse(repo).host)\n}\n\nconst defaultTarget = (repo, /* istanbul ignore next */ cwd = process.cwd()) =>\n  resolve(cwd, basename(repo.replace(/[/\\\\]?\\.git$/, '')))\n\nconst clone = (repo, revs, ref, revDoc, target, opts) => {\n  if (!revDoc) {\n    return unresolved(repo, ref, target, opts)\n  }\n  if (revDoc.sha === revs.refs.HEAD.sha) {\n    return plain(repo, revDoc, target, opts)\n  }\n  if (revDoc.type === 'tag' || revDoc.type === 'branch') {\n    return branch(repo, revDoc, target, opts)\n  }\n  return other(repo, revDoc, target, opts)\n}\n\nconst resolveRef = (revs, ref, opts) => {\n  const { spec = {} } = opts\n  ref = spec.gitCommittish || ref\n  /* istanbul ignore next - will fail anyway, can't pull */\n  if (!revs) {\n    return null\n  }\n  if (spec.gitRange) {\n    return pickManifest(revs, spec.gitRange, opts)\n  }\n  if (!ref) {\n    return revs.refs.HEAD\n  }\n  if (revs.refs[ref]) {\n    return revs.refs[ref]\n  }\n  if (revs.shas[ref]) {\n    return revs.refs[revs.shas[ref][0]]\n  }\n  return null\n}\n\n// pull request or some other kind of advertised ref\nconst other = (repo, revDoc, target, opts) => {\n  const shallow = maybeShallow(repo, opts)\n\n  const fetchOrigin = ['fetch', 'origin', revDoc.rawRef]\n    .concat(shallow ? ['--depth=1'] : [])\n\n  const git = (args) => spawn(args, { ...opts, cwd: target })\n  return mkdirp(target)\n    .then(() => git(['init']))\n    .then(() => isWindows(opts)\n      ? git(['config', '--local', '--add', 'core.longpaths', 'true'])\n      : null)\n    .then(() => git(['remote', 'add', 'origin', repo]))\n    .then(() => git(fetchOrigin))\n    .then(() => git(['checkout', revDoc.sha]))\n    .then(() => updateSubmodules(target, opts))\n    .then(() => revDoc.sha)\n}\n\n// tag or branches.  use -b\nconst branch = (repo, revDoc, target, opts) => {\n  const args = [\n    'clone',\n    '-b',\n    revDoc.ref,\n    repo,\n    target,\n    '--recurse-submodules'\n  ]\n  if (maybeShallow(repo, opts)) { args.push('--depth=1') }\n  if (isWindows(opts)) { args.push('--config', 'core.longpaths=true') }\n  return spawn(args, opts).then(() => revDoc.sha)\n}\n\n// just the head.  clone it\nconst plain = (repo, revDoc, target, opts) => {\n  const args = [\n    'clone',\n    repo,\n    target,\n    '--recurse-submodules'\n  ]\n  if (maybeShallow(repo, opts)) { args.push('--depth=1') }\n  if (isWindows(opts)) { args.push('--config', 'core.longpaths=true') }\n  return spawn(args, opts).then(() => revDoc.sha)\n}\n\nconst updateSubmodules = (target, opts) => new Promise(resolve =>\n  fs.stat(target + '/.gitmodules', er => {\n    if (er) {\n      return resolve(null)\n    }\n    return resolve(spawn([\n      'submodule',\n      'update',\n      '-q',\n      '--init',\n      '--recursive'\n    ], { ...opts, cwd: target }))\n  }))\n\nconst unresolved = (repo, ref, target, opts) => {\n  // can't do this one shallowly, because the ref isn't advertised\n  // but we can avoid checking out the working dir twice, at least\n  const lp = isWindows(opts) ? ['--config', 'core.longpaths=true'] : []\n  const cloneArgs = ['clone', '--mirror', '-q', repo, target + '/.git']\n  const git = (args) => spawn(args, { ...opts, cwd: target })\n  return mkdirp(target)\n    .then(() => git(cloneArgs.concat(lp)))\n    .then(() => git(['init']))\n    .then(() => git(['checkout', ref]))\n    .then(() => updateSubmodules(target, opts))\n    .then(() => git(['rev-parse', '--revs-only', 'HEAD']))\n    .then(({ stdout }) => stdout.trim())\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}