{"ast":null,"code":"// add and remove dependency specs to/from pkg manifest\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\nconst add = ({\n  pkg,\n  add,\n  saveBundle,\n  saveType,\n  log\n}) => {\n  for (const spec of add) {\n    addSingle({\n      pkg,\n      spec,\n      saveBundle,\n      saveType,\n      log\n    });\n  }\n  return pkg;\n};\n\n// Canonical source of both the map between saveType and where it correlates to\n// in the package, and the names of all our dependencies attributes\nconst saveTypeMap = new Map([['dev', 'devDependencies'], ['optional', 'optionalDependencies'], ['prod', 'dependencies'], ['peerOptional', 'peerDependencies'], ['peer', 'peerDependencies']]);\nconst addSingle = ({\n  pkg,\n  spec,\n  saveBundle,\n  saveType,\n  log\n}) => {\n  const {\n    name,\n    rawSpec\n  } = spec;\n\n  // if the user does not give us a type, we infer which type(s)\n  // to keep based on the same order of priority we do when\n  // building the tree as defined in the _loadDeps method of\n  // the node class.\n  if (!saveType) {\n    saveType = inferSaveType(pkg, spec.name);\n  }\n  if (saveType === 'prod') {\n    // a production dependency can only exist as production (rpj ensures it\n    // doesn't coexist w/ optional)\n    deleteSubKey(pkg, 'devDependencies', name, 'dependencies', log);\n    deleteSubKey(pkg, 'peerDependencies', name, 'dependencies', log);\n  } else if (saveType === 'dev') {\n    // a dev dependency may co-exist as peer, or optional, but not production\n    deleteSubKey(pkg, 'dependencies', name, 'devDependencies', log);\n  } else if (saveType === 'optional') {\n    // an optional dependency may co-exist as dev (rpj ensures it doesn't\n    // coexist w/ prod)\n    deleteSubKey(pkg, 'peerDependencies', name, 'optionalDependencies', log);\n  } else {\n    // peer or peerOptional is all that's left\n    // a peer dependency may coexist as dev\n    deleteSubKey(pkg, 'dependencies', name, 'peerDependencies', log);\n    deleteSubKey(pkg, 'optionalDependencies', name, 'peerDependencies', log);\n  }\n  const depType = saveTypeMap.get(saveType);\n  pkg[depType] = pkg[depType] || {};\n  if (rawSpec !== '' || pkg[depType][name] === undefined) {\n    pkg[depType][name] = rawSpec || '*';\n  }\n  if (saveType === 'optional') {\n    // Affordance for previous npm versions that require this behaviour\n    pkg.dependencies = pkg.dependencies || {};\n    pkg.dependencies[name] = pkg.optionalDependencies[name];\n  }\n  if (saveType === 'peer' || saveType === 'peerOptional') {\n    const pdm = pkg.peerDependenciesMeta || {};\n    if (saveType === 'peer' && pdm[name] && pdm[name].optional) {\n      pdm[name].optional = false;\n    } else if (saveType === 'peerOptional') {\n      pdm[name] = pdm[name] || {};\n      pdm[name].optional = true;\n      pkg.peerDependenciesMeta = pdm;\n    }\n    // peerDeps are often also a devDep, so that they can be tested when\n    // using package managers that don't auto-install peer deps\n    if (pkg.devDependencies && pkg.devDependencies[name] !== undefined) {\n      pkg.devDependencies[name] = pkg.peerDependencies[name];\n    }\n  }\n  if (saveBundle && saveType !== 'peer' && saveType !== 'peerOptional') {\n    // keep it sorted, keep it unique\n    const bd = new Set(pkg.bundleDependencies || []);\n    bd.add(spec.name);\n    pkg.bundleDependencies = [...bd].sort(localeCompare);\n  }\n};\n\n// Finds where the package is already in the spec and infers saveType from that\nconst inferSaveType = (pkg, name) => {\n  for (const saveType of saveTypeMap.keys()) {\n    if (hasSubKey(pkg, saveTypeMap.get(saveType), name)) {\n      if (saveType === 'peerOptional' && (!hasSubKey(pkg, 'peerDependenciesMeta', name) || !pkg.peerDependenciesMeta[name].optional)) {\n        return 'peer';\n      }\n      return saveType;\n    }\n  }\n  return 'prod';\n};\nconst {\n  hasOwnProperty\n} = Object.prototype;\nconst hasSubKey = (pkg, depType, name) => {\n  return pkg[depType] && hasOwnProperty.call(pkg[depType], name);\n};\n\n// Removes a subkey and warns about it if it's being replaced\nconst deleteSubKey = (pkg, depType, name, replacedBy, log) => {\n  if (hasSubKey(pkg, depType, name)) {\n    if (replacedBy && log) {\n      log.warn('idealTree', `Removing ${depType}.${name} in favor of ${replacedBy}.${name}`);\n    }\n    delete pkg[depType][name];\n\n    // clean up peerDepsMeta if we are removing something from peerDependencies\n    if (depType === 'peerDependencies' && pkg.peerDependenciesMeta) {\n      delete pkg.peerDependenciesMeta[name];\n      if (!Object.keys(pkg.peerDependenciesMeta).length) {\n        delete pkg.peerDependenciesMeta;\n      }\n    }\n    if (!Object.keys(pkg[depType]).length) {\n      delete pkg[depType];\n    }\n  }\n};\nconst rm = (pkg, rm) => {\n  for (const depType of new Set(saveTypeMap.values())) {\n    for (const name of rm) {\n      deleteSubKey(pkg, depType, name);\n    }\n  }\n  if (pkg.bundleDependencies) {\n    pkg.bundleDependencies = pkg.bundleDependencies.filter(name => !rm.includes(name));\n    if (!pkg.bundleDependencies.length) {\n      delete pkg.bundleDependencies;\n    }\n  }\n  return pkg;\n};\nmodule.exports = {\n  add,\n  rm,\n  saveTypeMap,\n  hasSubKey\n};","map":{"version":3,"names":["localeCompare","require","add","pkg","saveBundle","saveType","log","spec","addSingle","saveTypeMap","Map","name","rawSpec","inferSaveType","deleteSubKey","depType","get","undefined","dependencies","optionalDependencies","pdm","peerDependenciesMeta","optional","devDependencies","peerDependencies","bd","Set","bundleDependencies","sort","keys","hasSubKey","hasOwnProperty","Object","prototype","call","replacedBy","warn","length","rm","values","filter","includes","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/add-rm-pkg-deps.js"],"sourcesContent":["// add and remove dependency specs to/from pkg manifest\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\n\nconst add = ({pkg, add, saveBundle, saveType, log}) => {\n  for (const spec of add) {\n    addSingle({pkg, spec, saveBundle, saveType, log})\n  }\n\n  return pkg\n}\n\n// Canonical source of both the map between saveType and where it correlates to\n// in the package, and the names of all our dependencies attributes\nconst saveTypeMap = new Map([\n  ['dev', 'devDependencies'],\n  ['optional', 'optionalDependencies'],\n  ['prod', 'dependencies'],\n  ['peerOptional', 'peerDependencies'],\n  ['peer', 'peerDependencies'],\n])\n\nconst addSingle = ({pkg, spec, saveBundle, saveType, log}) => {\n  const { name, rawSpec } = spec\n\n  // if the user does not give us a type, we infer which type(s)\n  // to keep based on the same order of priority we do when\n  // building the tree as defined in the _loadDeps method of\n  // the node class.\n  if (!saveType) {\n    saveType = inferSaveType(pkg, spec.name)\n  }\n\n  if (saveType === 'prod') {\n    // a production dependency can only exist as production (rpj ensures it\n    // doesn't coexist w/ optional)\n    deleteSubKey(pkg, 'devDependencies', name, 'dependencies', log)\n    deleteSubKey(pkg, 'peerDependencies', name, 'dependencies', log)\n  } else if (saveType === 'dev') {\n    // a dev dependency may co-exist as peer, or optional, but not production\n    deleteSubKey(pkg, 'dependencies', name, 'devDependencies', log)\n  } else if (saveType === 'optional') {\n    // an optional dependency may co-exist as dev (rpj ensures it doesn't\n    // coexist w/ prod)\n    deleteSubKey(pkg, 'peerDependencies', name, 'optionalDependencies', log)\n  } else { // peer or peerOptional is all that's left\n    // a peer dependency may coexist as dev\n    deleteSubKey(pkg, 'dependencies', name, 'peerDependencies', log)\n    deleteSubKey(pkg, 'optionalDependencies', name, 'peerDependencies', log)\n  }\n\n  const depType = saveTypeMap.get(saveType)\n\n  pkg[depType] = pkg[depType] || {}\n  if (rawSpec !== '' || pkg[depType][name] === undefined) {\n    pkg[depType][name] = rawSpec || '*'\n  }\n  if (saveType === 'optional') {\n    // Affordance for previous npm versions that require this behaviour\n    pkg.dependencies = pkg.dependencies || {}\n    pkg.dependencies[name] = pkg.optionalDependencies[name]\n  }\n\n  if (saveType === 'peer' || saveType === 'peerOptional') {\n    const pdm = pkg.peerDependenciesMeta || {}\n    if (saveType === 'peer' && pdm[name] && pdm[name].optional) {\n      pdm[name].optional = false\n    } else if (saveType === 'peerOptional') {\n      pdm[name] = pdm[name] || {}\n      pdm[name].optional = true\n      pkg.peerDependenciesMeta = pdm\n    }\n    // peerDeps are often also a devDep, so that they can be tested when\n    // using package managers that don't auto-install peer deps\n    if (pkg.devDependencies && pkg.devDependencies[name] !== undefined) {\n      pkg.devDependencies[name] = pkg.peerDependencies[name]\n    }\n  }\n\n  if (saveBundle && saveType !== 'peer' && saveType !== 'peerOptional') {\n    // keep it sorted, keep it unique\n    const bd = new Set(pkg.bundleDependencies || [])\n    bd.add(spec.name)\n    pkg.bundleDependencies = [...bd].sort(localeCompare)\n  }\n}\n\n// Finds where the package is already in the spec and infers saveType from that\nconst inferSaveType = (pkg, name) => {\n  for (const saveType of saveTypeMap.keys()) {\n    if (hasSubKey(pkg, saveTypeMap.get(saveType), name)) {\n      if (\n        saveType === 'peerOptional' &&\n        (!hasSubKey(pkg, 'peerDependenciesMeta', name) ||\n        !pkg.peerDependenciesMeta[name].optional)\n      ) {\n        return 'peer'\n      }\n      return saveType\n    }\n  }\n  return 'prod'\n}\n\nconst { hasOwnProperty } = Object.prototype\nconst hasSubKey = (pkg, depType, name) => {\n  return pkg[depType] && hasOwnProperty.call(pkg[depType], name)\n}\n\n// Removes a subkey and warns about it if it's being replaced\nconst deleteSubKey = (pkg, depType, name, replacedBy, log) => {\n  if (hasSubKey(pkg, depType, name)) {\n    if (replacedBy && log) {\n      log.warn('idealTree', `Removing ${depType}.${name} in favor of ${replacedBy}.${name}`)\n    }\n    delete pkg[depType][name]\n\n    // clean up peerDepsMeta if we are removing something from peerDependencies\n    if (depType === 'peerDependencies' && pkg.peerDependenciesMeta) {\n      delete pkg.peerDependenciesMeta[name]\n      if (!Object.keys(pkg.peerDependenciesMeta).length) {\n        delete pkg.peerDependenciesMeta\n      }\n    }\n\n    if (!Object.keys(pkg[depType]).length) {\n      delete pkg[depType]\n    }\n  }\n}\n\nconst rm = (pkg, rm) => {\n  for (const depType of new Set(saveTypeMap.values())) {\n    for (const name of rm) {\n      deleteSubKey(pkg, depType, name)\n    }\n  }\n  if (pkg.bundleDependencies) {\n    pkg.bundleDependencies = pkg.bundleDependencies\n      .filter(name => !rm.includes(name))\n    if (!pkg.bundleDependencies.length) {\n      delete pkg.bundleDependencies\n    }\n  }\n  return pkg\n}\n\nmodule.exports = { add, rm, saveTypeMap, hasSubKey }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}