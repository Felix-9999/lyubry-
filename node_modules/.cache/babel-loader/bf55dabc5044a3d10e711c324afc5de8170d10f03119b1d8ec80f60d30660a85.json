{"ast":null,"code":"'use strict';\n\nconst URL = require('url').URL;\nconst Arborist = require('@npmcli/arborist');\n\n// supports object funding and string shorthand, or an array of these\n// if original was an array, returns an array; else returns the lone item\nfunction normalizeFunding(funding) {\n  const normalizeItem = item => typeof item === 'string' ? {\n    url: item\n  } : item;\n  const sources = [].concat(funding || []).map(normalizeItem);\n  return Array.isArray(funding) ? sources : sources[0];\n}\n\n// Is the value of a `funding` property of a `package.json`\n// a valid type+url for `npm fund` to display?\nfunction isValidFunding(funding) {\n  if (!funding) return false;\n  if (Array.isArray(funding)) return funding.every(f => !Array.isArray(f) && isValidFunding(f));\n  try {\n    var parsed = new URL(funding.url || funding);\n  } catch (error) {\n    return false;\n  }\n  if (parsed.protocol !== 'https:' && parsed.protocol !== 'http:') return false;\n  return Boolean(parsed.host);\n}\nconst empty = () => Object.create(null);\nfunction readTree(tree, opts) {\n  let packageWithFundingCount = 0;\n  const seen = new Set();\n  const {\n    countOnly\n  } = opts || {};\n  const _trailingDependencies = Symbol('trailingDependencies');\n  let filterSet;\n  if (opts && opts.workspaces && opts.workspaces.length) {\n    const arb = new Arborist(opts);\n    filterSet = arb.workspaceDependencySet(tree, opts.workspaces);\n  }\n  function tracked(name, version) {\n    const key = String(name) + String(version);\n    if (seen.has(key)) return true;\n    seen.add(key);\n  }\n  function retrieveDependencies(dependencies) {\n    const trailing = dependencies[_trailingDependencies];\n    if (trailing) {\n      return Object.assign(empty(), dependencies, trailing);\n    }\n    return dependencies;\n  }\n  function hasDependencies(dependencies) {\n    return dependencies && (Object.keys(dependencies).length || dependencies[_trailingDependencies]);\n  }\n  function attachFundingInfo(target, funding) {\n    if (funding && isValidFunding(funding)) {\n      target.funding = normalizeFunding(funding);\n      packageWithFundingCount++;\n    }\n  }\n  function getFundingDependencies(tree) {\n    const edges = tree && tree.edgesOut && tree.edgesOut.values();\n    if (!edges) return empty();\n    const directDepsWithFunding = Array.from(edges).map(edge => {\n      if (!edge || !edge.to) return empty();\n      const node = edge.to.target || edge.to;\n      if (!node.package) return empty();\n      if (filterSet && filterSet.size > 0 && !filterSet.has(node)) return empty();\n      const {\n        name,\n        funding,\n        version\n      } = node.package;\n\n      // avoids duplicated items within the funding tree\n      if (tracked(name, version)) return empty();\n      const fundingItem = {};\n      if (version) fundingItem.version = version;\n      attachFundingInfo(fundingItem, funding);\n      return {\n        node,\n        fundingItem\n      };\n    });\n    return directDepsWithFunding.reduce((res, {\n      node,\n      fundingItem\n    }, i) => {\n      if (!fundingItem || fundingItem.length === 0 || !node) return res;\n\n      // recurse\n      const transitiveDependencies = node.edgesOut && node.edgesOut.size > 0 && getFundingDependencies(node);\n\n      // if we're only counting items there's no need\n      // to add all the data to the resulting object\n      if (countOnly) return null;\n      if (hasDependencies(transitiveDependencies)) {\n        fundingItem.dependencies = retrieveDependencies(transitiveDependencies);\n      }\n      if (isValidFunding(fundingItem.funding)) res[node.package.name] = fundingItem;else if (hasDependencies(fundingItem.dependencies)) {\n        res[_trailingDependencies] = Object.assign(empty(), res[_trailingDependencies], fundingItem.dependencies);\n      }\n      return res;\n    }, countOnly ? null : empty());\n  }\n  const treeDependencies = getFundingDependencies(tree);\n  const result = {\n    length: packageWithFundingCount\n  };\n  if (!countOnly) {\n    const name = tree && tree.package && tree.package.name || tree && tree.name;\n    result.name = name || tree && tree.path;\n    if (tree && tree.package && tree.package.version) result.version = tree.package.version;\n    if (tree && tree.package && tree.package.funding) result.funding = normalizeFunding(tree.package.funding);\n    result.dependencies = retrieveDependencies(treeDependencies);\n  }\n  return result;\n}\nasync function read(opts) {\n  const arb = new Arborist(opts);\n  const tree = await arb.loadActual(opts);\n  return readTree(tree, opts);\n}\nmodule.exports = {\n  read,\n  readTree,\n  normalizeFunding,\n  isValidFunding\n};","map":{"version":3,"names":["URL","require","Arborist","normalizeFunding","funding","normalizeItem","item","url","sources","concat","map","Array","isArray","isValidFunding","every","f","parsed","error","protocol","Boolean","host","empty","Object","create","readTree","tree","opts","packageWithFundingCount","seen","Set","countOnly","_trailingDependencies","Symbol","filterSet","workspaces","length","arb","workspaceDependencySet","tracked","name","version","key","String","has","add","retrieveDependencies","dependencies","trailing","assign","hasDependencies","keys","attachFundingInfo","target","getFundingDependencies","edges","edgesOut","values","directDepsWithFunding","from","edge","to","node","package","size","fundingItem","reduce","res","i","transitiveDependencies","treeDependencies","result","path","read","loadActual","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/libnpmfund/index.js"],"sourcesContent":["'use strict'\n\nconst URL = require('url').URL\nconst Arborist = require('@npmcli/arborist')\n\n// supports object funding and string shorthand, or an array of these\n// if original was an array, returns an array; else returns the lone item\nfunction normalizeFunding (funding) {\n  const normalizeItem = item =>\n    typeof item === 'string' ? { url: item } : item\n  const sources = [].concat(funding || []).map(normalizeItem)\n  return Array.isArray(funding) ? sources : sources[0]\n}\n\n// Is the value of a `funding` property of a `package.json`\n// a valid type+url for `npm fund` to display?\nfunction isValidFunding (funding) {\n  if (!funding)\n    return false\n\n  if (Array.isArray(funding))\n    return funding.every(f => !Array.isArray(f) && isValidFunding(f))\n\n  try {\n    var parsed = new URL(funding.url || funding)\n  } catch (error) {\n    return false\n  }\n\n  if (\n    parsed.protocol !== 'https:' &&\n    parsed.protocol !== 'http:'\n  )\n    return false\n\n  return Boolean(parsed.host)\n}\n\nconst empty = () => Object.create(null)\n\nfunction readTree (tree, opts) {\n  let packageWithFundingCount = 0\n  const seen = new Set()\n  const { countOnly } = opts || {}\n  const _trailingDependencies = Symbol('trailingDependencies')\n\n  let filterSet\n\n  if (opts && opts.workspaces && opts.workspaces.length) {\n    const arb = new Arborist(opts)\n    filterSet = arb.workspaceDependencySet(tree, opts.workspaces)\n  }\n\n  function tracked (name, version) {\n    const key = String(name) + String(version)\n    if (seen.has(key))\n      return true\n\n    seen.add(key)\n  }\n\n  function retrieveDependencies (dependencies) {\n    const trailing = dependencies[_trailingDependencies]\n\n    if (trailing) {\n      return Object.assign(\n        empty(),\n        dependencies,\n        trailing\n      )\n    }\n\n    return dependencies\n  }\n\n  function hasDependencies (dependencies) {\n    return dependencies && (\n      Object.keys(dependencies).length ||\n      dependencies[_trailingDependencies]\n    )\n  }\n\n  function attachFundingInfo (target, funding) {\n    if (funding && isValidFunding(funding)) {\n      target.funding = normalizeFunding(funding)\n      packageWithFundingCount++\n    }\n  }\n\n  function getFundingDependencies (tree) {\n    const edges = tree && tree.edgesOut && tree.edgesOut.values()\n    if (!edges)\n      return empty()\n\n    const directDepsWithFunding = Array.from(edges).map(edge => {\n      if (!edge || !edge.to)\n        return empty()\n\n      const node = edge.to.target || edge.to\n      if (!node.package)\n        return empty()\n\n      if (filterSet && filterSet.size > 0 && !filterSet.has(node))\n        return empty()\n\n      const { name, funding, version } = node.package\n\n      // avoids duplicated items within the funding tree\n      if (tracked(name, version))\n        return empty()\n\n      const fundingItem = {}\n\n      if (version)\n        fundingItem.version = version\n\n      attachFundingInfo(fundingItem, funding)\n\n      return {\n        node,\n        fundingItem,\n      }\n    })\n\n    return directDepsWithFunding.reduce(\n      (res, { node, fundingItem }, i) => {\n        if (!fundingItem ||\n          fundingItem.length === 0 ||\n          !node)\n          return res\n\n        // recurse\n        const transitiveDependencies = node.edgesOut &&\n          node.edgesOut.size > 0 &&\n          getFundingDependencies(node)\n\n        // if we're only counting items there's no need\n        // to add all the data to the resulting object\n        if (countOnly)\n          return null\n\n        if (hasDependencies(transitiveDependencies)) {\n          fundingItem.dependencies =\n            retrieveDependencies(transitiveDependencies)\n        }\n\n        if (isValidFunding(fundingItem.funding))\n          res[node.package.name] = fundingItem\n        else if (hasDependencies(fundingItem.dependencies)) {\n          res[_trailingDependencies] =\n            Object.assign(\n              empty(),\n              res[_trailingDependencies],\n              fundingItem.dependencies\n            )\n        }\n\n        return res\n      }, countOnly ? null : empty())\n  }\n\n  const treeDependencies = getFundingDependencies(tree)\n  const result = {\n    length: packageWithFundingCount,\n  }\n\n  if (!countOnly) {\n    const name =\n      (tree && tree.package && tree.package.name) ||\n      (tree && tree.name)\n    result.name = name || (tree && tree.path)\n\n    if (tree && tree.package && tree.package.version)\n      result.version = tree.package.version\n\n    if (tree && tree.package && tree.package.funding)\n      result.funding = normalizeFunding(tree.package.funding)\n\n    result.dependencies = retrieveDependencies(treeDependencies)\n  }\n\n  return result\n}\n\nasync function read (opts) {\n  const arb = new Arborist(opts)\n  const tree = await arb.loadActual(opts)\n  return readTree(tree, opts)\n}\n\nmodule.exports = {\n  read,\n  readTree,\n  normalizeFunding,\n  isValidFunding,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}