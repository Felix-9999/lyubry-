{"ast":null,"code":"// an object representing the set of vulnerabilities in a tree\n/* eslint camelcase: \"off\" */\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\nconst npa = require('npm-package-arg');\nconst pickManifest = require('npm-pick-manifest');\nconst Vuln = require('./vuln.js');\nconst Calculator = require('@npmcli/metavuln-calculator');\nconst _getReport = Symbol('getReport');\nconst _fixAvailable = Symbol('fixAvailable');\nconst _checkTopNode = Symbol('checkTopNode');\nconst _init = Symbol('init');\nconst _omit = Symbol('omit');\nconst procLog = require('proc-log');\nconst fetch = require('npm-registry-fetch');\nclass AuditReport extends Map {\n  static load(tree, opts) {\n    return new AuditReport(tree, opts).run();\n  }\n  get auditReportVersion() {\n    return 2;\n  }\n  toJSON() {\n    const obj = {\n      auditReportVersion: this.auditReportVersion,\n      vulnerabilities: {},\n      metadata: {\n        vulnerabilities: {\n          info: 0,\n          low: 0,\n          moderate: 0,\n          high: 0,\n          critical: 0,\n          total: this.size\n        },\n        dependencies: {\n          prod: 0,\n          dev: 0,\n          optional: 0,\n          peer: 0,\n          peerOptional: 0,\n          total: this.tree.inventory.size - 1\n        }\n      }\n    };\n    for (const node of this.tree.inventory.values()) {\n      const {\n        dependencies\n      } = obj.metadata;\n      let prod = true;\n      for (const type of ['dev', 'optional', 'peer', 'peerOptional']) {\n        if (node[type]) {\n          dependencies[type]++;\n          prod = false;\n        }\n      }\n      if (prod) {\n        dependencies.prod++;\n      }\n    }\n\n    // if it doesn't have any topVulns, then it's fixable with audit fix\n    // for each topVuln, figure out if it's fixable with audit fix --force,\n    // or if we have to just delete the thing, and if the fix --force will\n    // require a semver major update.\n    const vulnerabilities = [];\n    for (const [name, vuln] of this.entries()) {\n      vulnerabilities.push([name, vuln.toJSON()]);\n      obj.metadata.vulnerabilities[vuln.severity]++;\n    }\n    obj.vulnerabilities = vulnerabilities.sort(([a], [b]) => localeCompare(a, b)).reduce((set, [name, vuln]) => {\n      set[name] = vuln;\n      return set;\n    }, {});\n    return obj;\n  }\n  constructor(tree, opts = {}) {\n    super();\n    const {\n      omit\n    } = opts;\n    this[_omit] = new Set(omit || []);\n    this.topVulns = new Map();\n    this.calculator = new Calculator(opts);\n    this.error = null;\n    this.options = opts;\n    this.log = opts.log || procLog;\n    this.tree = tree;\n    this.filterSet = opts.filterSet;\n  }\n  async run() {\n    this.report = await this[_getReport]();\n    this.log.silly('audit report', this.report);\n    if (this.report) {\n      await this[_init]();\n    }\n    return this;\n  }\n  isVulnerable(node) {\n    const vuln = this.get(node.packageName);\n    return !!(vuln && vuln.isVulnerable(node));\n  }\n  async [_init]() {\n    process.emit('time', 'auditReport:init');\n    const promises = [];\n    for (const [name, advisories] of Object.entries(this.report)) {\n      for (const advisory of advisories) {\n        promises.push(this.calculator.calculate(name, advisory));\n      }\n    }\n\n    // now the advisories are calculated with a set of versions\n    // and the packument.  turn them into our style of vuln objects\n    // which also have the affected nodes, and also create entries\n    // for all the metavulns that we find from dependents.\n    const advisories = new Set(await Promise.all(promises));\n    const seen = new Set();\n    for (const advisory of advisories) {\n      const {\n        name,\n        range\n      } = advisory;\n\n      // don't flag the exact same name/range more than once\n      // adding multiple advisories with the same range is fine, but no\n      // need to search for nodes we already would have added.\n      const k = `${name}@${range}`;\n      if (seen.has(k)) {\n        continue;\n      }\n      seen.add(k);\n      const vuln = this.get(name) || new Vuln({\n        name,\n        advisory\n      });\n      if (this.has(name)) {\n        vuln.addAdvisory(advisory);\n      }\n      super.set(name, vuln);\n      const p = [];\n      for (const node of this.tree.inventory.query('packageName', name)) {\n        if (!shouldAudit(node, this[_omit], this.filterSet)) {\n          continue;\n        }\n\n        // if not vulnerable by this advisory, keep searching\n        if (!advisory.testVersion(node.version)) {\n          continue;\n        }\n\n        // we will have loaded the source already if this is a metavuln\n        if (advisory.type === 'metavuln') {\n          vuln.addVia(this.get(advisory.dependency));\n        }\n\n        // already marked this one, no need to do it again\n        if (vuln.nodes.has(node)) {\n          continue;\n        }\n\n        // haven't marked this one yet.  get its dependents.\n        vuln.nodes.add(node);\n        for (const {\n          from: dep,\n          spec\n        } of node.edgesIn) {\n          if (dep.isTop && !vuln.topNodes.has(dep)) {\n            this[_checkTopNode](dep, vuln, spec);\n          } else {\n            // calculate a metavuln, if necessary\n            const calc = this.calculator.calculate(dep.packageName, advisory);\n            p.push(calc.then(meta => {\n              if (meta.testVersion(dep.version, spec)) {\n                advisories.add(meta);\n              }\n            }));\n          }\n        }\n      }\n      await Promise.all(p);\n\n      // make sure we actually got something.  if not, remove it\n      // this can happen if you are loading from a lockfile created by\n      // npm v5, since it lists the current version of all deps,\n      // rather than the range that is actually depended upon,\n      // or if using --omit with the older audit endpoint.\n      if (this.get(name).nodes.size === 0) {\n        this.delete(name);\n        continue;\n      }\n\n      // if the vuln is valid, but THIS advisory doesn't apply to any of\n      // the nodes it references, then remove it from the advisory list.\n      // happens when using omit with old audit endpoint.\n      for (const advisory of vuln.advisories) {\n        const relevant = [...vuln.nodes].some(n => advisory.testVersion(n.version));\n        if (!relevant) {\n          vuln.deleteAdvisory(advisory);\n        }\n      }\n    }\n    process.emit('timeEnd', 'auditReport:init');\n  }\n  [_checkTopNode](topNode, vuln, spec) {\n    vuln.fixAvailable = this[_fixAvailable](topNode, vuln, spec);\n    if (vuln.fixAvailable !== true) {\n      // now we know the top node is vulnerable, and cannot be\n      // upgraded out of the bad place without --force.  But, there's\n      // no need to add it to the actual vulns list, because nothing\n      // depends on root.\n      this.topVulns.set(vuln.name, vuln);\n      vuln.topNodes.add(topNode);\n    }\n  }\n\n  // check whether the top node is vulnerable.\n  // check whether we can get out of the bad place with --force, and if\n  // so, whether that update is SemVer Major\n  [_fixAvailable](topNode, vuln, spec) {\n    // this will always be set to at least {name, versions:{}}\n    const paku = vuln.packument;\n    if (!vuln.testSpec(spec)) {\n      return true;\n    }\n\n    // similarly, even if we HAVE a packument, but we're looking for it\n    // somewhere other than the registry, and we got something vulnerable,\n    // then we're stuck with it.\n    const specObj = npa(spec);\n    if (!specObj.registry) {\n      return false;\n    }\n    if (specObj.subSpec) {\n      spec = specObj.subSpec.rawSpec;\n    }\n\n    // We don't provide fixes for top nodes other than root, but we\n    // still check to see if the node is fixable with a different version,\n    // and if that is a semver major bump.\n    try {\n      const {\n        _isSemVerMajor: isSemVerMajor,\n        version,\n        name\n      } = pickManifest(paku, spec, {\n        ...this.options,\n        before: null,\n        avoid: vuln.range,\n        avoidStrict: true\n      });\n      return {\n        name,\n        version,\n        isSemVerMajor\n      };\n    } catch (er) {\n      return false;\n    }\n  }\n  set() {\n    throw new Error('do not call AuditReport.set() directly');\n  }\n\n  // convert a quick-audit into a bulk advisory listing\n  static auditToBulk(report) {\n    if (!report.advisories) {\n      // tack on the report json where the response body would go\n      throw Object.assign(new Error('Invalid advisory report'), {\n        body: JSON.stringify(report)\n      });\n    }\n    const bulk = {};\n    const {\n      advisories\n    } = report;\n    for (const advisory of Object.values(advisories)) {\n      const {\n        id,\n        url,\n        title,\n        severity = 'high',\n        vulnerable_versions = '*',\n        module_name: name\n      } = advisory;\n      bulk[name] = bulk[name] || [];\n      bulk[name].push({\n        id,\n        url,\n        title,\n        severity,\n        vulnerable_versions\n      });\n    }\n    return bulk;\n  }\n  async [_getReport]() {\n    // if we're not auditing, just return false\n    if (this.options.audit === false || this.tree.inventory.size === 1) {\n      return null;\n    }\n    process.emit('time', 'auditReport:getReport');\n    try {\n      try {\n        // first try the super fast bulk advisory listing\n        const body = prepareBulkData(this.tree, this[_omit], this.filterSet);\n        this.log.silly('audit', 'bulk request', body);\n\n        // no sense asking if we don't have anything to audit,\n        // we know it'll be empty\n        if (!Object.keys(body).length) {\n          return null;\n        }\n        const res = await fetch('/-/npm/v1/security/advisories/bulk', {\n          ...this.options,\n          registry: this.options.auditRegistry || this.options.registry,\n          method: 'POST',\n          gzip: true,\n          body\n        });\n        return await res.json();\n      } catch (er) {\n        this.log.silly('audit', 'bulk request failed', String(er.body));\n        // that failed, try the quick audit endpoint\n        const body = prepareData(this.tree, this.options);\n        const res = await fetch('/-/npm/v1/security/audits/quick', {\n          ...this.options,\n          registry: this.options.auditRegistry || this.options.registry,\n          method: 'POST',\n          gzip: true,\n          body\n        });\n        return AuditReport.auditToBulk(await res.json());\n      }\n    } catch (er) {\n      this.log.verbose('audit error', er);\n      this.log.silly('audit error', String(er.body));\n      this.error = er;\n      return null;\n    } finally {\n      process.emit('timeEnd', 'auditReport:getReport');\n    }\n  }\n}\n\n// return true if we should audit this one\nconst shouldAudit = (node, omit, filterSet) => !node.version ? false : node.isRoot ? false : filterSet && filterSet.size !== 0 && !filterSet.has(node) ? false : omit.size === 0 ? true : !(\n// otherwise, just ensure we're not omitting this one\nnode.dev && omit.has('dev') || node.optional && omit.has('optional') || node.devOptional && omit.has('dev') && omit.has('optional') || node.peer && omit.has('peer'));\nconst prepareBulkData = (tree, omit, filterSet) => {\n  const payload = {};\n  for (const name of tree.inventory.query('packageName')) {\n    const set = new Set();\n    for (const node of tree.inventory.query('packageName', name)) {\n      if (!shouldAudit(node, omit, filterSet)) {\n        continue;\n      }\n      set.add(node.version);\n    }\n    if (set.size) {\n      payload[name] = [...set];\n    }\n  }\n  return payload;\n};\nconst prepareData = (tree, opts) => {\n  const {\n    npmVersion: npm_version\n  } = opts;\n  const node_version = process.version;\n  const {\n    platform,\n    arch\n  } = process;\n  const {\n    NODE_ENV: node_env\n  } = process.env;\n  const data = tree.meta.commit();\n  // the legacy audit endpoint doesn't support any kind of pre-filtering\n  // we just have to get the advisories and skip over them in the report\n  return {\n    name: data.name,\n    version: data.version,\n    requires: {\n      ...(tree.package.devDependencies || {}),\n      ...(tree.package.peerDependencies || {}),\n      ...(tree.package.optionalDependencies || {}),\n      ...(tree.package.dependencies || {})\n    },\n    dependencies: data.dependencies,\n    metadata: {\n      node_version,\n      npm_version,\n      platform,\n      arch,\n      node_env\n    }\n  };\n};\nmodule.exports = AuditReport;","map":{"version":3,"names":["localeCompare","require","npa","pickManifest","Vuln","Calculator","_getReport","Symbol","_fixAvailable","_checkTopNode","_init","_omit","procLog","fetch","AuditReport","Map","load","tree","opts","run","auditReportVersion","toJSON","obj","vulnerabilities","metadata","info","low","moderate","high","critical","total","size","dependencies","prod","dev","optional","peer","peerOptional","inventory","node","values","type","name","vuln","entries","push","severity","sort","a","b","reduce","set","constructor","omit","Set","topVulns","calculator","error","options","log","filterSet","report","silly","isVulnerable","get","packageName","process","emit","promises","advisories","Object","advisory","calculate","Promise","all","seen","range","k","has","add","addAdvisory","p","query","shouldAudit","testVersion","version","addVia","dependency","nodes","from","dep","spec","edgesIn","isTop","topNodes","calc","then","meta","delete","relevant","some","n","deleteAdvisory","topNode","fixAvailable","paku","packument","testSpec","specObj","registry","subSpec","rawSpec","_isSemVerMajor","isSemVerMajor","before","avoid","avoidStrict","er","Error","auditToBulk","assign","body","JSON","stringify","bulk","id","url","title","vulnerable_versions","module_name","audit","prepareBulkData","keys","length","res","auditRegistry","method","gzip","json","String","prepareData","verbose","isRoot","devOptional","payload","npmVersion","npm_version","node_version","platform","arch","NODE_ENV","node_env","env","data","commit","requires","package","devDependencies","peerDependencies","optionalDependencies","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/audit-report.js"],"sourcesContent":["// an object representing the set of vulnerabilities in a tree\n/* eslint camelcase: \"off\" */\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst npa = require('npm-package-arg')\nconst pickManifest = require('npm-pick-manifest')\n\nconst Vuln = require('./vuln.js')\nconst Calculator = require('@npmcli/metavuln-calculator')\n\nconst _getReport = Symbol('getReport')\nconst _fixAvailable = Symbol('fixAvailable')\nconst _checkTopNode = Symbol('checkTopNode')\nconst _init = Symbol('init')\nconst _omit = Symbol('omit')\nconst procLog = require('proc-log')\n\nconst fetch = require('npm-registry-fetch')\n\nclass AuditReport extends Map {\n  static load (tree, opts) {\n    return new AuditReport(tree, opts).run()\n  }\n\n  get auditReportVersion () {\n    return 2\n  }\n\n  toJSON () {\n    const obj = {\n      auditReportVersion: this.auditReportVersion,\n      vulnerabilities: {},\n      metadata: {\n        vulnerabilities: {\n          info: 0,\n          low: 0,\n          moderate: 0,\n          high: 0,\n          critical: 0,\n          total: this.size,\n        },\n        dependencies: {\n          prod: 0,\n          dev: 0,\n          optional: 0,\n          peer: 0,\n          peerOptional: 0,\n          total: this.tree.inventory.size - 1,\n        },\n      },\n    }\n\n    for (const node of this.tree.inventory.values()) {\n      const { dependencies } = obj.metadata\n      let prod = true\n      for (const type of [\n        'dev',\n        'optional',\n        'peer',\n        'peerOptional',\n      ]) {\n        if (node[type]) {\n          dependencies[type]++\n          prod = false\n        }\n      }\n      if (prod) {\n        dependencies.prod++\n      }\n    }\n\n    // if it doesn't have any topVulns, then it's fixable with audit fix\n    // for each topVuln, figure out if it's fixable with audit fix --force,\n    // or if we have to just delete the thing, and if the fix --force will\n    // require a semver major update.\n    const vulnerabilities = []\n    for (const [name, vuln] of this.entries()) {\n      vulnerabilities.push([name, vuln.toJSON()])\n      obj.metadata.vulnerabilities[vuln.severity]++\n    }\n\n    obj.vulnerabilities = vulnerabilities\n      .sort(([a], [b]) => localeCompare(a, b))\n      .reduce((set, [name, vuln]) => {\n        set[name] = vuln\n        return set\n      }, {})\n\n    return obj\n  }\n\n  constructor (tree, opts = {}) {\n    super()\n    const { omit } = opts\n    this[_omit] = new Set(omit || [])\n    this.topVulns = new Map()\n\n    this.calculator = new Calculator(opts)\n    this.error = null\n    this.options = opts\n    this.log = opts.log || procLog\n    this.tree = tree\n    this.filterSet = opts.filterSet\n  }\n\n  async run () {\n    this.report = await this[_getReport]()\n    this.log.silly('audit report', this.report)\n    if (this.report) {\n      await this[_init]()\n    }\n    return this\n  }\n\n  isVulnerable (node) {\n    const vuln = this.get(node.packageName)\n    return !!(vuln && vuln.isVulnerable(node))\n  }\n\n  async [_init] () {\n    process.emit('time', 'auditReport:init')\n\n    const promises = []\n    for (const [name, advisories] of Object.entries(this.report)) {\n      for (const advisory of advisories) {\n        promises.push(this.calculator.calculate(name, advisory))\n      }\n    }\n\n    // now the advisories are calculated with a set of versions\n    // and the packument.  turn them into our style of vuln objects\n    // which also have the affected nodes, and also create entries\n    // for all the metavulns that we find from dependents.\n    const advisories = new Set(await Promise.all(promises))\n    const seen = new Set()\n    for (const advisory of advisories) {\n      const { name, range } = advisory\n\n      // don't flag the exact same name/range more than once\n      // adding multiple advisories with the same range is fine, but no\n      // need to search for nodes we already would have added.\n      const k = `${name}@${range}`\n      if (seen.has(k)) {\n        continue\n      }\n\n      seen.add(k)\n\n      const vuln = this.get(name) || new Vuln({ name, advisory })\n      if (this.has(name)) {\n        vuln.addAdvisory(advisory)\n      }\n      super.set(name, vuln)\n\n      const p = []\n      for (const node of this.tree.inventory.query('packageName', name)) {\n        if (!shouldAudit(node, this[_omit], this.filterSet)) {\n          continue\n        }\n\n        // if not vulnerable by this advisory, keep searching\n        if (!advisory.testVersion(node.version)) {\n          continue\n        }\n\n        // we will have loaded the source already if this is a metavuln\n        if (advisory.type === 'metavuln') {\n          vuln.addVia(this.get(advisory.dependency))\n        }\n\n        // already marked this one, no need to do it again\n        if (vuln.nodes.has(node)) {\n          continue\n        }\n\n        // haven't marked this one yet.  get its dependents.\n        vuln.nodes.add(node)\n        for (const { from: dep, spec } of node.edgesIn) {\n          if (dep.isTop && !vuln.topNodes.has(dep)) {\n            this[_checkTopNode](dep, vuln, spec)\n          } else {\n            // calculate a metavuln, if necessary\n            const calc = this.calculator.calculate(dep.packageName, advisory)\n            p.push(calc.then(meta => {\n              if (meta.testVersion(dep.version, spec)) {\n                advisories.add(meta)\n              }\n            }))\n          }\n        }\n      }\n      await Promise.all(p)\n\n      // make sure we actually got something.  if not, remove it\n      // this can happen if you are loading from a lockfile created by\n      // npm v5, since it lists the current version of all deps,\n      // rather than the range that is actually depended upon,\n      // or if using --omit with the older audit endpoint.\n      if (this.get(name).nodes.size === 0) {\n        this.delete(name)\n        continue\n      }\n\n      // if the vuln is valid, but THIS advisory doesn't apply to any of\n      // the nodes it references, then remove it from the advisory list.\n      // happens when using omit with old audit endpoint.\n      for (const advisory of vuln.advisories) {\n        const relevant = [...vuln.nodes]\n          .some(n => advisory.testVersion(n.version))\n        if (!relevant) {\n          vuln.deleteAdvisory(advisory)\n        }\n      }\n    }\n    process.emit('timeEnd', 'auditReport:init')\n  }\n\n  [_checkTopNode] (topNode, vuln, spec) {\n    vuln.fixAvailable = this[_fixAvailable](topNode, vuln, spec)\n\n    if (vuln.fixAvailable !== true) {\n      // now we know the top node is vulnerable, and cannot be\n      // upgraded out of the bad place without --force.  But, there's\n      // no need to add it to the actual vulns list, because nothing\n      // depends on root.\n      this.topVulns.set(vuln.name, vuln)\n      vuln.topNodes.add(topNode)\n    }\n  }\n\n  // check whether the top node is vulnerable.\n  // check whether we can get out of the bad place with --force, and if\n  // so, whether that update is SemVer Major\n  [_fixAvailable] (topNode, vuln, spec) {\n    // this will always be set to at least {name, versions:{}}\n    const paku = vuln.packument\n\n    if (!vuln.testSpec(spec)) {\n      return true\n    }\n\n    // similarly, even if we HAVE a packument, but we're looking for it\n    // somewhere other than the registry, and we got something vulnerable,\n    // then we're stuck with it.\n    const specObj = npa(spec)\n    if (!specObj.registry) {\n      return false\n    }\n\n    if (specObj.subSpec) {\n      spec = specObj.subSpec.rawSpec\n    }\n\n    // We don't provide fixes for top nodes other than root, but we\n    // still check to see if the node is fixable with a different version,\n    // and if that is a semver major bump.\n    try {\n      const {\n        _isSemVerMajor: isSemVerMajor,\n        version,\n        name,\n      } = pickManifest(paku, spec, {\n        ...this.options,\n        before: null,\n        avoid: vuln.range,\n        avoidStrict: true,\n      })\n      return {name, version, isSemVerMajor}\n    } catch (er) {\n      return false\n    }\n  }\n\n  set () {\n    throw new Error('do not call AuditReport.set() directly')\n  }\n\n  // convert a quick-audit into a bulk advisory listing\n  static auditToBulk (report) {\n    if (!report.advisories) {\n      // tack on the report json where the response body would go\n      throw Object.assign(new Error('Invalid advisory report'), {\n        body: JSON.stringify(report),\n      })\n    }\n\n    const bulk = {}\n    const {advisories} = report\n    for (const advisory of Object.values(advisories)) {\n      const {\n        id,\n        url,\n        title,\n        severity = 'high',\n        vulnerable_versions = '*',\n        module_name: name,\n      } = advisory\n      bulk[name] = bulk[name] || []\n      bulk[name].push({id, url, title, severity, vulnerable_versions})\n    }\n\n    return bulk\n  }\n\n  async [_getReport] () {\n    // if we're not auditing, just return false\n    if (this.options.audit === false || this.tree.inventory.size === 1) {\n      return null\n    }\n\n    process.emit('time', 'auditReport:getReport')\n    try {\n      try {\n        // first try the super fast bulk advisory listing\n        const body = prepareBulkData(this.tree, this[_omit], this.filterSet)\n        this.log.silly('audit', 'bulk request', body)\n\n        // no sense asking if we don't have anything to audit,\n        // we know it'll be empty\n        if (!Object.keys(body).length) {\n          return null\n        }\n\n        const res = await fetch('/-/npm/v1/security/advisories/bulk', {\n          ...this.options,\n          registry: this.options.auditRegistry || this.options.registry,\n          method: 'POST',\n          gzip: true,\n          body,\n        })\n\n        return await res.json()\n      } catch (er) {\n        this.log.silly('audit', 'bulk request failed', String(er.body))\n        // that failed, try the quick audit endpoint\n        const body = prepareData(this.tree, this.options)\n        const res = await fetch('/-/npm/v1/security/audits/quick', {\n          ...this.options,\n          registry: this.options.auditRegistry || this.options.registry,\n          method: 'POST',\n          gzip: true,\n          body,\n        })\n        return AuditReport.auditToBulk(await res.json())\n      }\n    } catch (er) {\n      this.log.verbose('audit error', er)\n      this.log.silly('audit error', String(er.body))\n      this.error = er\n      return null\n    } finally {\n      process.emit('timeEnd', 'auditReport:getReport')\n    }\n  }\n}\n\n// return true if we should audit this one\nconst shouldAudit = (node, omit, filterSet) =>\n  !node.version ? false\n  : node.isRoot ? false\n  : filterSet && filterSet.size !== 0 && !filterSet.has(node) ? false\n  : omit.size === 0 ? true\n  : !( // otherwise, just ensure we're not omitting this one\n    node.dev && omit.has('dev') ||\n    node.optional && omit.has('optional') ||\n    node.devOptional && omit.has('dev') && omit.has('optional') ||\n    node.peer && omit.has('peer')\n  )\n\nconst prepareBulkData = (tree, omit, filterSet) => {\n  const payload = {}\n  for (const name of tree.inventory.query('packageName')) {\n    const set = new Set()\n    for (const node of tree.inventory.query('packageName', name)) {\n      if (!shouldAudit(node, omit, filterSet)) {\n        continue\n      }\n\n      set.add(node.version)\n    }\n    if (set.size) {\n      payload[name] = [...set]\n    }\n  }\n  return payload\n}\n\nconst prepareData = (tree, opts) => {\n  const { npmVersion: npm_version } = opts\n  const node_version = process.version\n  const { platform, arch } = process\n  const { NODE_ENV: node_env } = process.env\n  const data = tree.meta.commit()\n  // the legacy audit endpoint doesn't support any kind of pre-filtering\n  // we just have to get the advisories and skip over them in the report\n  return {\n    name: data.name,\n    version: data.version,\n    requires: {\n      ...(tree.package.devDependencies || {}),\n      ...(tree.package.peerDependencies || {}),\n      ...(tree.package.optionalDependencies || {}),\n      ...(tree.package.dependencies || {}),\n    },\n    dependencies: data.dependencies,\n    metadata: {\n      node_version,\n      npm_version,\n      platform,\n      arch,\n      node_env,\n    },\n  }\n}\n\nmodule.exports = AuditReport\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}