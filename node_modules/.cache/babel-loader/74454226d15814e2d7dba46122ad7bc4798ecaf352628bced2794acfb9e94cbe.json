{"ast":null,"code":"/* eslint-disable camelcase */\n/* eslint-disable standard/no-callback-literal */\nconst fs = require('fs');\nconst util = require('util');\nconst readdir = util.promisify(fs.readdir);\nconst reifyFinish = require('./utils/reify-finish.js');\nconst log = require('npmlog');\nconst {\n  resolve,\n  join\n} = require('path');\nconst Arborist = require('@npmcli/arborist');\nconst runScript = require('@npmcli/run-script');\nconst pacote = require('pacote');\nconst checks = require('npm-install-checks');\nconst ArboristWorkspaceCmd = require('./workspaces/arborist-cmd.js');\nclass Install extends ArboristWorkspaceCmd {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description() {\n    return 'Install a package';\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name() {\n    return 'install';\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params() {\n    return ['save', 'save-exact', 'global', 'global-style', 'legacy-bundling', 'strict-peer-deps', 'package-lock', 'omit', 'ignore-scripts', 'audit', 'bin-links', 'fund', 'dry-run', ...super.params];\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage() {\n    return ['[<@scope>/]<pkg>', '[<@scope>/]<pkg>@<tag>', '[<@scope>/]<pkg>@<version>', '[<@scope>/]<pkg>@<version range>', '<alias>@npm:<name>', '<folder>', '<tarball file>', '<tarball url>', '<git:// url>', '<github username>/<github project>'];\n  }\n  async completion(opts) {\n    const {\n      partialWord\n    } = opts;\n    // install can complete to a folder with a package.json, or any package.\n    // if it has a slash, then it's gotta be a folder\n    // if it starts with https?://, then just give up, because it's a url\n    if (/^https?:\\/\\//.test(partialWord)) {\n      // do not complete to URLs\n      return [];\n    }\n    if (/\\//.test(partialWord)) {\n      // Complete fully to folder if there is exactly one match and it\n      // is a folder containing a package.json file.  If that is not the\n      // case we return 0 matches, which will trigger the default bash\n      // complete.\n      const lastSlashIdx = partialWord.lastIndexOf('/');\n      const partialName = partialWord.slice(lastSlashIdx + 1);\n      const partialPath = partialWord.slice(0, lastSlashIdx) || '/';\n      const annotatePackageDirMatch = async sibling => {\n        const fullPath = join(partialPath, sibling);\n        if (sibling.slice(0, partialName.length) !== partialName) return null; // not name match\n\n        try {\n          const contents = await readdir(fullPath);\n          return {\n            fullPath,\n            isPackage: contents.indexOf('package.json') !== -1\n          };\n        } catch (er) {\n          return {\n            isPackage: false\n          };\n        }\n      };\n      try {\n        const siblings = await readdir(partialPath);\n        const matches = await Promise.all(siblings.map(async sibling => {\n          return await annotatePackageDirMatch(sibling);\n        }));\n        const match = matches.filter(el => !el || el.isPackage).pop();\n        if (match) {\n          // Success - only one match and it is a package dir\n          return [match.fullPath];\n        } else {\n          // no matches\n          return [];\n        }\n      } catch (er) {\n        return []; // invalid dir: no matching\n      }\n    }\n    // Note: there used to be registry completion here,\n    // but it stopped making sense somewhere around\n    // 50,000 packages on the registry\n  }\n  exec(args, cb) {\n    this.install(args).then(() => cb()).catch(cb);\n  }\n  async install(args) {\n    // the /path/to/node_modules/..\n    const globalTop = resolve(this.npm.globalDir, '..');\n    const ignoreScripts = this.npm.config.get('ignore-scripts');\n    const isGlobalInstall = this.npm.config.get('global');\n    const where = isGlobalInstall ? globalTop : this.npm.prefix;\n    const forced = this.npm.config.get('force');\n    const isDev = this.npm.config.get('dev');\n    const scriptShell = this.npm.config.get('script-shell') || undefined;\n\n    // be very strict about engines when trying to update npm itself\n    const npmInstall = args.find(arg => arg.startsWith('npm@') || arg === 'npm');\n    if (isGlobalInstall && npmInstall) {\n      const npmOptions = this.npm.flatOptions;\n      const npmManifest = await pacote.manifest(npmInstall, npmOptions);\n      try {\n        checks.checkEngine(npmManifest, npmManifest.version, process.version);\n      } catch (e) {\n        if (forced) this.npm.log.warn('install', `Forcing global npm install with incompatible version ${npmManifest.version} into node ${process.version}`);else throw e;\n      }\n    }\n\n    // don't try to install the prefix into itself\n    args = args.filter(a => resolve(a) !== this.npm.prefix);\n\n    // `npm i -g` => \"install this package globally\"\n    if (where === globalTop && !args.length) args = ['.'];\n\n    // TODO: Add warnings for other deprecated flags?  or remove this one?\n    if (isDev) log.warn('install', 'Usage of the `--dev` option is deprecated. Use `--include=dev` instead.');\n    const opts = {\n      ...this.npm.flatOptions,\n      log: this.npm.log,\n      auditLevel: null,\n      path: where,\n      add: args,\n      workspaces: this.workspaceNames\n    };\n    const arb = new Arborist(opts);\n    await arb.reify(opts);\n    if (!args.length && !isGlobalInstall && !ignoreScripts) {\n      const scripts = ['preinstall', 'install', 'postinstall', 'prepublish',\n      // XXX should we remove this finally??\n      'preprepare', 'prepare', 'postprepare'];\n      for (const event of scripts) {\n        await runScript({\n          path: where,\n          args: [],\n          scriptShell,\n          stdio: 'inherit',\n          stdioString: true,\n          banner: log.level !== 'silent',\n          event\n        });\n      }\n    }\n    await reifyFinish(this.npm, arb);\n  }\n}\nmodule.exports = Install;","map":{"version":3,"names":["fs","require","util","readdir","promisify","reifyFinish","log","resolve","join","Arborist","runScript","pacote","checks","ArboristWorkspaceCmd","Install","description","name","params","usage","completion","opts","partialWord","test","lastSlashIdx","lastIndexOf","partialName","slice","partialPath","annotatePackageDirMatch","sibling","fullPath","length","contents","isPackage","indexOf","er","siblings","matches","Promise","all","map","match","filter","el","pop","exec","args","cb","install","then","catch","globalTop","npm","globalDir","ignoreScripts","config","get","isGlobalInstall","where","prefix","forced","isDev","scriptShell","undefined","npmInstall","find","arg","startsWith","npmOptions","flatOptions","npmManifest","manifest","checkEngine","version","process","e","warn","a","auditLevel","path","add","workspaces","workspaceNames","arb","reify","scripts","event","stdio","stdioString","banner","level","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/lib/install.js"],"sourcesContent":["/* eslint-disable camelcase */\n/* eslint-disable standard/no-callback-literal */\nconst fs = require('fs')\nconst util = require('util')\nconst readdir = util.promisify(fs.readdir)\nconst reifyFinish = require('./utils/reify-finish.js')\nconst log = require('npmlog')\nconst { resolve, join } = require('path')\nconst Arborist = require('@npmcli/arborist')\nconst runScript = require('@npmcli/run-script')\nconst pacote = require('pacote')\nconst checks = require('npm-install-checks')\n\nconst ArboristWorkspaceCmd = require('./workspaces/arborist-cmd.js')\nclass Install extends ArboristWorkspaceCmd {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description () {\n    return 'Install a package'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'install'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return [\n      'save',\n      'save-exact',\n      'global',\n      'global-style',\n      'legacy-bundling',\n      'strict-peer-deps',\n      'package-lock',\n      'omit',\n      'ignore-scripts',\n      'audit',\n      'bin-links',\n      'fund',\n      'dry-run',\n      ...super.params,\n    ]\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return [\n      '[<@scope>/]<pkg>',\n      '[<@scope>/]<pkg>@<tag>',\n      '[<@scope>/]<pkg>@<version>',\n      '[<@scope>/]<pkg>@<version range>',\n      '<alias>@npm:<name>',\n      '<folder>',\n      '<tarball file>',\n      '<tarball url>',\n      '<git:// url>',\n      '<github username>/<github project>',\n    ]\n  }\n\n  async completion (opts) {\n    const { partialWord } = opts\n    // install can complete to a folder with a package.json, or any package.\n    // if it has a slash, then it's gotta be a folder\n    // if it starts with https?://, then just give up, because it's a url\n    if (/^https?:\\/\\//.test(partialWord)) {\n      // do not complete to URLs\n      return []\n    }\n\n    if (/\\//.test(partialWord)) {\n      // Complete fully to folder if there is exactly one match and it\n      // is a folder containing a package.json file.  If that is not the\n      // case we return 0 matches, which will trigger the default bash\n      // complete.\n      const lastSlashIdx = partialWord.lastIndexOf('/')\n      const partialName = partialWord.slice(lastSlashIdx + 1)\n      const partialPath = partialWord.slice(0, lastSlashIdx) || '/'\n\n      const annotatePackageDirMatch = async (sibling) => {\n        const fullPath = join(partialPath, sibling)\n        if (sibling.slice(0, partialName.length) !== partialName)\n          return null // not name match\n\n        try {\n          const contents = await readdir(fullPath)\n          return {\n            fullPath,\n            isPackage: contents.indexOf('package.json') !== -1,\n          }\n        } catch (er) {\n          return { isPackage: false }\n        }\n      }\n\n      try {\n        const siblings = await readdir(partialPath)\n        const matches = await Promise.all(\n          siblings.map(async sibling => {\n            return await annotatePackageDirMatch(sibling)\n          })\n        )\n        const match = matches.filter(el => !el || el.isPackage).pop()\n        if (match) {\n          // Success - only one match and it is a package dir\n          return [match.fullPath]\n        } else {\n          // no matches\n          return []\n        }\n      } catch (er) {\n        return [] // invalid dir: no matching\n      }\n    }\n    // Note: there used to be registry completion here,\n    // but it stopped making sense somewhere around\n    // 50,000 packages on the registry\n  }\n\n  exec (args, cb) {\n    this.install(args).then(() => cb()).catch(cb)\n  }\n\n  async install (args) {\n    // the /path/to/node_modules/..\n    const globalTop = resolve(this.npm.globalDir, '..')\n    const ignoreScripts = this.npm.config.get('ignore-scripts')\n    const isGlobalInstall = this.npm.config.get('global')\n    const where = isGlobalInstall ? globalTop : this.npm.prefix\n    const forced = this.npm.config.get('force')\n    const isDev = this.npm.config.get('dev')\n    const scriptShell = this.npm.config.get('script-shell') || undefined\n\n    // be very strict about engines when trying to update npm itself\n    const npmInstall = args.find(arg => arg.startsWith('npm@') || arg === 'npm')\n    if (isGlobalInstall && npmInstall) {\n      const npmOptions = this.npm.flatOptions\n      const npmManifest = await pacote.manifest(npmInstall, npmOptions)\n      try {\n        checks.checkEngine(npmManifest, npmManifest.version, process.version)\n      } catch (e) {\n        if (forced)\n          this.npm.log.warn('install', `Forcing global npm install with incompatible version ${npmManifest.version} into node ${process.version}`)\n        else\n          throw e\n      }\n    }\n\n    // don't try to install the prefix into itself\n    args = args.filter(a => resolve(a) !== this.npm.prefix)\n\n    // `npm i -g` => \"install this package globally\"\n    if (where === globalTop && !args.length)\n      args = ['.']\n\n    // TODO: Add warnings for other deprecated flags?  or remove this one?\n    if (isDev)\n      log.warn('install', 'Usage of the `--dev` option is deprecated. Use `--include=dev` instead.')\n\n    const opts = {\n      ...this.npm.flatOptions,\n      log: this.npm.log,\n      auditLevel: null,\n      path: where,\n      add: args,\n      workspaces: this.workspaceNames,\n    }\n    const arb = new Arborist(opts)\n    await arb.reify(opts)\n\n    if (!args.length && !isGlobalInstall && !ignoreScripts) {\n      const scripts = [\n        'preinstall',\n        'install',\n        'postinstall',\n        'prepublish', // XXX should we remove this finally??\n        'preprepare',\n        'prepare',\n        'postprepare',\n      ]\n      for (const event of scripts) {\n        await runScript({\n          path: where,\n          args: [],\n          scriptShell,\n          stdio: 'inherit',\n          stdioString: true,\n          banner: log.level !== 'silent',\n          event,\n        })\n      }\n    }\n    await reifyFinish(this.npm, arb)\n  }\n}\nmodule.exports = Install\n"],"mappings":"AAAA;AACA;AACA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAI,CAAC;AACxB,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAME,OAAO,GAAGD,IAAI,CAACE,SAAS,CAACJ,EAAE,CAACG,OAAO,CAAC;AAC1C,MAAME,WAAW,GAAGJ,OAAO,CAAC,yBAAyB,CAAC;AACtD,MAAMK,GAAG,GAAGL,OAAO,CAAC,QAAQ,CAAC;AAC7B,MAAM;EAAEM,OAAO;EAAEC;AAAK,CAAC,GAAGP,OAAO,CAAC,MAAM,CAAC;AACzC,MAAMQ,QAAQ,GAAGR,OAAO,CAAC,kBAAkB,CAAC;AAC5C,MAAMS,SAAS,GAAGT,OAAO,CAAC,oBAAoB,CAAC;AAC/C,MAAMU,MAAM,GAAGV,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMW,MAAM,GAAGX,OAAO,CAAC,oBAAoB,CAAC;AAE5C,MAAMY,oBAAoB,GAAGZ,OAAO,CAAC,8BAA8B,CAAC;AACpE,MAAMa,OAAO,SAASD,oBAAoB,CAAC;EACzC;EACA,WAAWE,WAAWA,CAAA,EAAI;IACxB,OAAO,mBAAmB;EAC5B;;EAEA;EACA,WAAWC,IAAIA,CAAA,EAAI;IACjB,OAAO,SAAS;EAClB;;EAEA;EACA,WAAWC,MAAMA,CAAA,EAAI;IACnB,OAAO,CACL,MAAM,EACN,YAAY,EACZ,QAAQ,EACR,cAAc,EACd,iBAAiB,EACjB,kBAAkB,EAClB,cAAc,EACd,MAAM,EACN,gBAAgB,EAChB,OAAO,EACP,WAAW,EACX,MAAM,EACN,SAAS,EACT,GAAG,KAAK,CAACA,MAAM,CAChB;EACH;;EAEA;EACA,WAAWC,KAAKA,CAAA,EAAI;IAClB,OAAO,CACL,kBAAkB,EAClB,wBAAwB,EACxB,4BAA4B,EAC5B,kCAAkC,EAClC,oBAAoB,EACpB,UAAU,EACV,gBAAgB,EAChB,eAAe,EACf,cAAc,EACd,oCAAoC,CACrC;EACH;EAEA,MAAMC,UAAUA,CAAEC,IAAI,EAAE;IACtB,MAAM;MAAEC;IAAY,CAAC,GAAGD,IAAI;IAC5B;IACA;IACA;IACA,IAAI,cAAc,CAACE,IAAI,CAACD,WAAW,CAAC,EAAE;MACpC;MACA,OAAO,EAAE;IACX;IAEA,IAAI,IAAI,CAACC,IAAI,CAACD,WAAW,CAAC,EAAE;MAC1B;MACA;MACA;MACA;MACA,MAAME,YAAY,GAAGF,WAAW,CAACG,WAAW,CAAC,GAAG,CAAC;MACjD,MAAMC,WAAW,GAAGJ,WAAW,CAACK,KAAK,CAACH,YAAY,GAAG,CAAC,CAAC;MACvD,MAAMI,WAAW,GAAGN,WAAW,CAACK,KAAK,CAAC,CAAC,EAAEH,YAAY,CAAC,IAAI,GAAG;MAE7D,MAAMK,uBAAuB,GAAG,MAAOC,OAAO,IAAK;QACjD,MAAMC,QAAQ,GAAGtB,IAAI,CAACmB,WAAW,EAAEE,OAAO,CAAC;QAC3C,IAAIA,OAAO,CAACH,KAAK,CAAC,CAAC,EAAED,WAAW,CAACM,MAAM,CAAC,KAAKN,WAAW,EACtD,OAAO,IAAI,EAAC;;QAEd,IAAI;UACF,MAAMO,QAAQ,GAAG,MAAM7B,OAAO,CAAC2B,QAAQ,CAAC;UACxC,OAAO;YACLA,QAAQ;YACRG,SAAS,EAAED,QAAQ,CAACE,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC;UACnD,CAAC;QACH,CAAC,CAAC,OAAOC,EAAE,EAAE;UACX,OAAO;YAAEF,SAAS,EAAE;UAAM,CAAC;QAC7B;MACF,CAAC;MAED,IAAI;QACF,MAAMG,QAAQ,GAAG,MAAMjC,OAAO,CAACwB,WAAW,CAAC;QAC3C,MAAMU,OAAO,GAAG,MAAMC,OAAO,CAACC,GAAG,CAC/BH,QAAQ,CAACI,GAAG,CAAC,MAAMX,OAAO,IAAI;UAC5B,OAAO,MAAMD,uBAAuB,CAACC,OAAO,CAAC;QAC/C,CAAC,CACH,CAAC;QACD,MAAMY,KAAK,GAAGJ,OAAO,CAACK,MAAM,CAACC,EAAE,IAAI,CAACA,EAAE,IAAIA,EAAE,CAACV,SAAS,CAAC,CAACW,GAAG,CAAC,CAAC;QAC7D,IAAIH,KAAK,EAAE;UACT;UACA,OAAO,CAACA,KAAK,CAACX,QAAQ,CAAC;QACzB,CAAC,MAAM;UACL;UACA,OAAO,EAAE;QACX;MACF,CAAC,CAAC,OAAOK,EAAE,EAAE;QACX,OAAO,EAAE,EAAC;MACZ;IACF;IACA;IACA;IACA;EACF;EAEAU,IAAIA,CAAEC,IAAI,EAAEC,EAAE,EAAE;IACd,IAAI,CAACC,OAAO,CAACF,IAAI,CAAC,CAACG,IAAI,CAAC,MAAMF,EAAE,CAAC,CAAC,CAAC,CAACG,KAAK,CAACH,EAAE,CAAC;EAC/C;EAEA,MAAMC,OAAOA,CAAEF,IAAI,EAAE;IACnB;IACA,MAAMK,SAAS,GAAG5C,OAAO,CAAC,IAAI,CAAC6C,GAAG,CAACC,SAAS,EAAE,IAAI,CAAC;IACnD,MAAMC,aAAa,GAAG,IAAI,CAACF,GAAG,CAACG,MAAM,CAACC,GAAG,CAAC,gBAAgB,CAAC;IAC3D,MAAMC,eAAe,GAAG,IAAI,CAACL,GAAG,CAACG,MAAM,CAACC,GAAG,CAAC,QAAQ,CAAC;IACrD,MAAME,KAAK,GAAGD,eAAe,GAAGN,SAAS,GAAG,IAAI,CAACC,GAAG,CAACO,MAAM;IAC3D,MAAMC,MAAM,GAAG,IAAI,CAACR,GAAG,CAACG,MAAM,CAACC,GAAG,CAAC,OAAO,CAAC;IAC3C,MAAMK,KAAK,GAAG,IAAI,CAACT,GAAG,CAACG,MAAM,CAACC,GAAG,CAAC,KAAK,CAAC;IACxC,MAAMM,WAAW,GAAG,IAAI,CAACV,GAAG,CAACG,MAAM,CAACC,GAAG,CAAC,cAAc,CAAC,IAAIO,SAAS;;IAEpE;IACA,MAAMC,UAAU,GAAGlB,IAAI,CAACmB,IAAI,CAACC,GAAG,IAAIA,GAAG,CAACC,UAAU,CAAC,MAAM,CAAC,IAAID,GAAG,KAAK,KAAK,CAAC;IAC5E,IAAIT,eAAe,IAAIO,UAAU,EAAE;MACjC,MAAMI,UAAU,GAAG,IAAI,CAAChB,GAAG,CAACiB,WAAW;MACvC,MAAMC,WAAW,GAAG,MAAM3D,MAAM,CAAC4D,QAAQ,CAACP,UAAU,EAAEI,UAAU,CAAC;MACjE,IAAI;QACFxD,MAAM,CAAC4D,WAAW,CAACF,WAAW,EAAEA,WAAW,CAACG,OAAO,EAAEC,OAAO,CAACD,OAAO,CAAC;MACvE,CAAC,CAAC,OAAOE,CAAC,EAAE;QACV,IAAIf,MAAM,EACR,IAAI,CAACR,GAAG,CAAC9C,GAAG,CAACsE,IAAI,CAAC,SAAS,EAAE,wDAAwDN,WAAW,CAACG,OAAO,cAAcC,OAAO,CAACD,OAAO,EAAE,CAAC,MAExI,MAAME,CAAC;MACX;IACF;;IAEA;IACA7B,IAAI,GAAGA,IAAI,CAACJ,MAAM,CAACmC,CAAC,IAAItE,OAAO,CAACsE,CAAC,CAAC,KAAK,IAAI,CAACzB,GAAG,CAACO,MAAM,CAAC;;IAEvD;IACA,IAAID,KAAK,KAAKP,SAAS,IAAI,CAACL,IAAI,CAACf,MAAM,EACrCe,IAAI,GAAG,CAAC,GAAG,CAAC;;IAEd;IACA,IAAIe,KAAK,EACPvD,GAAG,CAACsE,IAAI,CAAC,SAAS,EAAE,yEAAyE,CAAC;IAEhG,MAAMxD,IAAI,GAAG;MACX,GAAG,IAAI,CAACgC,GAAG,CAACiB,WAAW;MACvB/D,GAAG,EAAE,IAAI,CAAC8C,GAAG,CAAC9C,GAAG;MACjBwE,UAAU,EAAE,IAAI;MAChBC,IAAI,EAAErB,KAAK;MACXsB,GAAG,EAAElC,IAAI;MACTmC,UAAU,EAAE,IAAI,CAACC;IACnB,CAAC;IACD,MAAMC,GAAG,GAAG,IAAI1E,QAAQ,CAACW,IAAI,CAAC;IAC9B,MAAM+D,GAAG,CAACC,KAAK,CAAChE,IAAI,CAAC;IAErB,IAAI,CAAC0B,IAAI,CAACf,MAAM,IAAI,CAAC0B,eAAe,IAAI,CAACH,aAAa,EAAE;MACtD,MAAM+B,OAAO,GAAG,CACd,YAAY,EACZ,SAAS,EACT,aAAa,EACb,YAAY;MAAE;MACd,YAAY,EACZ,SAAS,EACT,aAAa,CACd;MACD,KAAK,MAAMC,KAAK,IAAID,OAAO,EAAE;QAC3B,MAAM3E,SAAS,CAAC;UACdqE,IAAI,EAAErB,KAAK;UACXZ,IAAI,EAAE,EAAE;UACRgB,WAAW;UACXyB,KAAK,EAAE,SAAS;UAChBC,WAAW,EAAE,IAAI;UACjBC,MAAM,EAAEnF,GAAG,CAACoF,KAAK,KAAK,QAAQ;UAC9BJ;QACF,CAAC,CAAC;MACJ;IACF;IACA,MAAMjF,WAAW,CAAC,IAAI,CAAC+C,GAAG,EAAE+B,GAAG,CAAC;EAClC;AACF;AACAQ,MAAM,CAACC,OAAO,GAAG9E,OAAO","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}