{"ast":null,"code":"const {\n  depth\n} = require('treeverse');\nconst calcDepFlags = (tree, resetRoot = true) => {\n  if (resetRoot) {\n    tree.dev = false;\n    tree.optional = false;\n    tree.devOptional = false;\n    tree.peer = false;\n  }\n  const ret = depth({\n    tree,\n    visit: node => calcDepFlagsStep(node),\n    filter: node => node,\n    getChildren: (node, tree) => [...tree.edgesOut.values()].map(edge => edge.to)\n  });\n  return ret;\n};\nconst calcDepFlagsStep = node => {\n  // This rewalk is necessary to handle cases where devDep and optional\n  // or normal dependency graphs overlap deep in the dep graph.\n  // Since we're only walking through deps that are not already flagged\n  // as non-dev/non-optional, it's typically a very shallow traversal\n  node.extraneous = false;\n  resetParents(node, 'extraneous');\n  resetParents(node, 'dev');\n  resetParents(node, 'peer');\n  resetParents(node, 'devOptional');\n  resetParents(node, 'optional');\n\n  // for links, map their hierarchy appropriately\n  if (node.isLink) {\n    node.target.dev = node.dev;\n    node.target.optional = node.optional;\n    node.target.devOptional = node.devOptional;\n    node.target.peer = node.peer;\n    return calcDepFlagsStep(node.target);\n  }\n  node.edgesOut.forEach(({\n    peer,\n    optional,\n    dev,\n    to\n  }) => {\n    // if the dep is missing, then its flags are already maximally unset\n    if (!to) {\n      return;\n    }\n\n    // everything with any kind of edge into it is not extraneous\n    to.extraneous = false;\n\n    // devOptional is the *overlap* of the dev and optional tree.\n    // however, for convenience and to save an extra rewalk, we leave\n    // it set when we are in *either* tree, and then omit it from the\n    // package-lock if either dev or optional are set.\n    const unsetDevOpt = !node.devOptional && !node.dev && !node.optional && !dev && !optional;\n\n    // if we are not in the devOpt tree, then we're also not in\n    // either the dev or opt trees\n    const unsetDev = unsetDevOpt || !node.dev && !dev;\n    const unsetOpt = unsetDevOpt || !node.optional && !optional;\n    const unsetPeer = !node.peer && !peer;\n    if (unsetPeer) {\n      unsetFlag(to, 'peer');\n    }\n    if (unsetDevOpt) {\n      unsetFlag(to, 'devOptional');\n    }\n    if (unsetDev) {\n      unsetFlag(to, 'dev');\n    }\n    if (unsetOpt) {\n      unsetFlag(to, 'optional');\n    }\n  });\n  return node;\n};\nconst resetParents = (node, flag) => {\n  if (node[flag]) {\n    return;\n  }\n  for (let p = node; p && (p === node || p[flag]); p = p.resolveParent) {\n    p[flag] = false;\n  }\n};\n\n// typically a short walk, since it only traverses deps that\n// have the flag set.\nconst unsetFlag = (node, flag) => {\n  if (node[flag]) {\n    node[flag] = false;\n    depth({\n      tree: node,\n      visit: node => {\n        node.extraneous = node[flag] = false;\n        if (node.isLink) {\n          node.target.extraneous = node.target[flag] = false;\n        }\n      },\n      getChildren: node => [...node.target.edgesOut.values()].filter(edge => edge.to && edge.to[flag] && (flag !== 'peer' && edge.type === 'peer' || edge.type === 'prod')).map(edge => edge.to)\n    });\n  }\n};\nmodule.exports = calcDepFlags;","map":{"version":3,"names":["depth","require","calcDepFlags","tree","resetRoot","dev","optional","devOptional","peer","ret","visit","node","calcDepFlagsStep","filter","getChildren","edgesOut","values","map","edge","to","extraneous","resetParents","isLink","target","forEach","unsetDevOpt","unsetDev","unsetOpt","unsetPeer","unsetFlag","flag","p","resolveParent","type","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/calc-dep-flags.js"],"sourcesContent":["const { depth } = require('treeverse')\n\nconst calcDepFlags = (tree, resetRoot = true) => {\n  if (resetRoot) {\n    tree.dev = false\n    tree.optional = false\n    tree.devOptional = false\n    tree.peer = false\n  }\n  const ret = depth({\n    tree,\n    visit: node => calcDepFlagsStep(node),\n    filter: node => node,\n    getChildren: (node, tree) =>\n      [...tree.edgesOut.values()].map(edge => edge.to),\n  })\n  return ret\n}\n\nconst calcDepFlagsStep = (node) => {\n  // This rewalk is necessary to handle cases where devDep and optional\n  // or normal dependency graphs overlap deep in the dep graph.\n  // Since we're only walking through deps that are not already flagged\n  // as non-dev/non-optional, it's typically a very shallow traversal\n  node.extraneous = false\n  resetParents(node, 'extraneous')\n  resetParents(node, 'dev')\n  resetParents(node, 'peer')\n  resetParents(node, 'devOptional')\n  resetParents(node, 'optional')\n\n  // for links, map their hierarchy appropriately\n  if (node.isLink) {\n    node.target.dev = node.dev\n    node.target.optional = node.optional\n    node.target.devOptional = node.devOptional\n    node.target.peer = node.peer\n    return calcDepFlagsStep(node.target)\n  }\n\n  node.edgesOut.forEach(({peer, optional, dev, to}) => {\n    // if the dep is missing, then its flags are already maximally unset\n    if (!to) {\n      return\n    }\n\n    // everything with any kind of edge into it is not extraneous\n    to.extraneous = false\n\n    // devOptional is the *overlap* of the dev and optional tree.\n    // however, for convenience and to save an extra rewalk, we leave\n    // it set when we are in *either* tree, and then omit it from the\n    // package-lock if either dev or optional are set.\n    const unsetDevOpt = !node.devOptional && !node.dev && !node.optional &&\n      !dev && !optional\n\n    // if we are not in the devOpt tree, then we're also not in\n    // either the dev or opt trees\n    const unsetDev = unsetDevOpt || !node.dev && !dev\n    const unsetOpt = unsetDevOpt ||\n      !node.optional && !optional\n    const unsetPeer = !node.peer && !peer\n\n    if (unsetPeer) {\n      unsetFlag(to, 'peer')\n    }\n\n    if (unsetDevOpt) {\n      unsetFlag(to, 'devOptional')\n    }\n\n    if (unsetDev) {\n      unsetFlag(to, 'dev')\n    }\n\n    if (unsetOpt) {\n      unsetFlag(to, 'optional')\n    }\n  })\n\n  return node\n}\n\nconst resetParents = (node, flag) => {\n  if (node[flag]) {\n    return\n  }\n\n  for (let p = node; p && (p === node || p[flag]); p = p.resolveParent) {\n    p[flag] = false\n  }\n}\n\n// typically a short walk, since it only traverses deps that\n// have the flag set.\nconst unsetFlag = (node, flag) => {\n  if (node[flag]) {\n    node[flag] = false\n    depth({\n      tree: node,\n      visit: node => {\n        node.extraneous = node[flag] = false\n        if (node.isLink) {\n          node.target.extraneous = node.target[flag] = false\n        }\n      },\n      getChildren: node => [...node.target.edgesOut.values()]\n        .filter(edge => edge.to && edge.to[flag] &&\n          (flag !== 'peer' && edge.type === 'peer' || edge.type === 'prod'))\n        .map(edge => edge.to),\n    })\n  }\n}\n\nmodule.exports = calcDepFlags\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}