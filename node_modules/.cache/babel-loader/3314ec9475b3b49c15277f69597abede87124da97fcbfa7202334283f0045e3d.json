{"ast":null,"code":"// Each command has a completion function that takes an options object and a cb\n// The callback gets called with an error and an array of possible completions.\n// The options object is built up based on the environment variables set by\n// zsh or bash when calling a function for completion, based on the cursor\n// position and the command line thus far.  These are:\n// COMP_CWORD: the index of the \"word\" in the command line being completed\n// COMP_LINE: the full command line thusfar as a string\n// COMP_POINT: the cursor index at the point of triggering completion\n//\n// We parse the command line with nopt, like npm does, and then create an\n// options object containing:\n// words: array of words in the command line\n// w: the index of the word being completed (ie, COMP_CWORD)\n// word: the word being completed\n// line: the COMP_LINE\n// lineLength\n// point: the COMP_POINT, usually equal to line length, but not always, eg if\n// the user has pressed the left-arrow to complete an earlier word\n// partialLine: the line up to the point\n// partialWord: the word being completed (which might be ''), up to the point\n// conf: a nopt parse of the command line\n//\n// When the implementation completion method returns its list of strings,\n// and arrays of strings, we filter that by any that start with the\n// partialWord, since only those can possibly be valid matches.\n//\n// Matches are wrapped with ' to escape them, if necessary, and then printed\n// one per line for the shell completion method to consume in IFS=$'\\n' mode\n// as an array.\n//\n\nconst {\n  definitions,\n  shorthands\n} = require('./utils/config/index.js');\nconst deref = require('./utils/deref-command.js');\nconst {\n  aliases,\n  cmdList,\n  plumbing\n} = require('./utils/cmd-list.js');\nconst aliasNames = Object.keys(aliases);\nconst fullList = cmdList.concat(aliasNames).filter(c => !plumbing.includes(c));\nconst nopt = require('nopt');\nconst configNames = Object.keys(definitions);\nconst shorthandNames = Object.keys(shorthands);\nconst allConfs = configNames.concat(shorthandNames);\nconst isWindowsShell = require('./utils/is-windows-shell.js');\nconst fileExists = require('./utils/file-exists.js');\nconst {\n  promisify\n} = require('util');\nconst BaseCommand = require('./base-command.js');\nclass Completion extends BaseCommand {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description() {\n    return 'Tab Completion for npm';\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name() {\n    return 'completion';\n  }\n\n  // completion for the completion command\n  async completion(opts) {\n    if (opts.w > 2) return;\n    const {\n      resolve\n    } = require('path');\n    const [bashExists, zshExists] = await Promise.all([fileExists(resolve(process.env.HOME, '.bashrc')), fileExists(resolve(process.env.HOME, '.zshrc'))]);\n    const out = [];\n    if (zshExists) out.push(['>>', '~/.zshrc']);\n    if (bashExists) out.push(['>>', '~/.bashrc']);\n    return out;\n  }\n  exec(args, cb) {\n    this.compl(args).then(() => cb()).catch(cb);\n  }\n  async compl(args) {\n    if (isWindowsShell) {\n      const msg = 'npm completion supported only in MINGW / Git bash on Windows';\n      throw Object.assign(new Error(msg), {\n        code: 'ENOTSUP'\n      });\n    }\n    const {\n      COMP_CWORD,\n      COMP_LINE,\n      COMP_POINT\n    } = process.env;\n\n    // if the COMP_* isn't in the env, then just dump the script.\n    if (COMP_CWORD === undefined || COMP_LINE === undefined || COMP_POINT === undefined) return dumpScript();\n\n    // ok we're actually looking at the envs and outputting the suggestions\n    // get the partial line and partial word,\n    // if the point isn't at the end.\n    // ie, tabbing at: npm foo b|ar\n    const w = +COMP_CWORD;\n    const words = args.map(unescape);\n    const word = words[w];\n    const line = COMP_LINE;\n    const point = +COMP_POINT;\n    const partialLine = line.substr(0, point);\n    const partialWords = words.slice(0, w);\n\n    // figure out where in that last word the point is.\n    const partialWordRaw = args[w];\n    let i = partialWordRaw.length;\n    while (partialWordRaw.substr(0, i) !== partialLine.substr(-1 * i) && i > 0) i--;\n    const partialWord = unescape(partialWordRaw.substr(0, i));\n    partialWords.push(partialWord);\n    const opts = {\n      words,\n      w,\n      word,\n      line,\n      lineLength: line.length,\n      point,\n      partialLine,\n      partialWords,\n      partialWord,\n      raw: args\n    };\n    if (partialWords.slice(0, -1).indexOf('--') === -1) {\n      if (word.charAt(0) === '-') return this.wrap(opts, configCompl(opts));\n      if (words[w - 1] && words[w - 1].charAt(0) === '-' && !isFlag(words[w - 1])) {\n        // awaiting a value for a non-bool config.\n        // don't even try to do this for now\n        return this.wrap(opts, configValueCompl(opts));\n      }\n    }\n\n    // try to find the npm command.\n    // it's the first thing after all the configs.\n    // take a little shortcut and use npm's arg parsing logic.\n    // don't have to worry about the last arg being implicitly\n    // boolean'ed, since the last block will catch that.\n    const types = Object.entries(definitions).reduce((types, [key, def]) => {\n      types[key] = def.type;\n      return types;\n    }, {});\n    const parsed = opts.conf = nopt(types, shorthands, partialWords.slice(0, -1), 0);\n    // check if there's a command already.\n    const cmd = parsed.argv.remain[1];\n    if (!cmd) return this.wrap(opts, cmdCompl(opts));\n    Object.keys(parsed).forEach(k => this.npm.config.set(k, parsed[k]));\n\n    // at this point, if words[1] is some kind of npm command,\n    // then complete on it.\n    // otherwise, do nothing\n    const impl = this.npm.commands[cmd];\n    if (impl && impl.completion) {\n      const comps = await impl.completion(opts);\n      return this.wrap(opts, comps);\n    }\n  }\n\n  // The command should respond with an array.  Loop over that,\n  // wrapping quotes around any that have spaces, and writing\n  // them to stdout.\n  // If any of the items are arrays, then join them with a space.\n  // Ie, returning ['a', 'b c', ['d', 'e']] would allow it to expand\n  // to: 'a', 'b c', or 'd' 'e'\n  wrap(opts, compls) {\n    if (!Array.isArray(compls)) compls = compls ? [compls] : [];\n    compls = compls.map(c => Array.isArray(c) ? c.map(escape).join(' ') : escape(c));\n    if (opts.partialWord) compls = compls.filter(c => c.startsWith(opts.partialWord));\n    if (compls.length > 0) this.npm.output(compls.join('\\n'));\n  }\n}\nconst dumpScript = async () => {\n  const fs = require('fs');\n  const readFile = promisify(fs.readFile);\n  const {\n    resolve\n  } = require('path');\n  const p = resolve(__dirname, 'utils/completion.sh');\n  const d = (await readFile(p, 'utf8')).replace(/^#!.*?\\n/, '');\n  await new Promise((res, rej) => {\n    let done = false;\n    process.stdout.write(d, () => {\n      if (done) return;\n      done = true;\n      res();\n    });\n    process.stdout.on('error', er => {\n      if (done) return;\n      done = true;\n\n      // Darwin is a pain sometimes.\n      //\n      // This is necessary because the \"source\" or \".\" program in\n      // bash on OS X closes its file argument before reading\n      // from it, meaning that you get exactly 1 write, which will\n      // work most of the time, and will always raise an EPIPE.\n      //\n      // Really, one should not be tossing away EPIPE errors, or any\n      // errors, so casually.  But, without this, `. <(npm completion)`\n      // can never ever work on OS X.\n      if (er.errno === 'EPIPE') res();else rej(er);\n    });\n  });\n};\nconst unescape = w => w.charAt(0) === '\\'' ? w.replace(/^'|'$/g, '') : w.replace(/\\\\ /g, ' ');\nconst escape = w => !/\\s+/.test(w) ? w : '\\'' + w + '\\'';\n\n// the current word has a dash.  Return the config names,\n// with the same number of dashes as the current word has.\nconst configCompl = opts => {\n  const word = opts.word;\n  const split = word.match(/^(-+)((?:no-)*)(.*)$/);\n  const dashes = split[1];\n  const no = split[2];\n  const flags = configNames.filter(isFlag);\n  return allConfs.map(c => dashes + c).concat(flags.map(f => dashes + (no || 'no-') + f));\n};\n\n// expand with the valid values of various config values.\n// not yet implemented.\nconst configValueCompl = opts => [];\n\n// check if the thing is a flag or not.\nconst isFlag = word => {\n  // shorthands never take args.\n  const split = word.match(/^(-*)((?:no-)+)?(.*)$/);\n  const no = split[2];\n  const conf = split[3];\n  const {\n    type\n  } = definitions[conf];\n  return no || type === Boolean || Array.isArray(type) && type.includes(Boolean) || shorthands[conf];\n};\n\n// complete against the npm commands\n// if they all resolve to the same thing, just return the thing it already is\nconst cmdCompl = opts => {\n  const matches = fullList.filter(c => c.startsWith(opts.partialWord));\n  if (!matches.length) return matches;\n  const derefs = new Set([...matches.map(c => deref(c))]);\n  if (derefs.size === 1) return [...derefs];\n  return fullList;\n};\nmodule.exports = Completion;","map":{"version":3,"names":["definitions","shorthands","require","deref","aliases","cmdList","plumbing","aliasNames","Object","keys","fullList","concat","filter","c","includes","nopt","configNames","shorthandNames","allConfs","isWindowsShell","fileExists","promisify","BaseCommand","Completion","description","name","completion","opts","w","resolve","bashExists","zshExists","Promise","all","process","env","HOME","out","push","exec","args","cb","compl","then","catch","msg","assign","Error","code","COMP_CWORD","COMP_LINE","COMP_POINT","undefined","dumpScript","words","map","unescape","word","line","point","partialLine","substr","partialWords","slice","partialWordRaw","i","length","partialWord","lineLength","raw","indexOf","charAt","wrap","configCompl","isFlag","configValueCompl","types","entries","reduce","key","def","type","parsed","conf","cmd","argv","remain","cmdCompl","forEach","k","npm","config","set","impl","commands","comps","compls","Array","isArray","escape","join","startsWith","output","fs","readFile","p","__dirname","d","replace","res","rej","done","stdout","write","on","er","errno","test","split","match","dashes","no","flags","f","Boolean","matches","derefs","Set","size","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/lib/completion.js"],"sourcesContent":["// Each command has a completion function that takes an options object and a cb\n// The callback gets called with an error and an array of possible completions.\n// The options object is built up based on the environment variables set by\n// zsh or bash when calling a function for completion, based on the cursor\n// position and the command line thus far.  These are:\n// COMP_CWORD: the index of the \"word\" in the command line being completed\n// COMP_LINE: the full command line thusfar as a string\n// COMP_POINT: the cursor index at the point of triggering completion\n//\n// We parse the command line with nopt, like npm does, and then create an\n// options object containing:\n// words: array of words in the command line\n// w: the index of the word being completed (ie, COMP_CWORD)\n// word: the word being completed\n// line: the COMP_LINE\n// lineLength\n// point: the COMP_POINT, usually equal to line length, but not always, eg if\n// the user has pressed the left-arrow to complete an earlier word\n// partialLine: the line up to the point\n// partialWord: the word being completed (which might be ''), up to the point\n// conf: a nopt parse of the command line\n//\n// When the implementation completion method returns its list of strings,\n// and arrays of strings, we filter that by any that start with the\n// partialWord, since only those can possibly be valid matches.\n//\n// Matches are wrapped with ' to escape them, if necessary, and then printed\n// one per line for the shell completion method to consume in IFS=$'\\n' mode\n// as an array.\n//\n\nconst { definitions, shorthands } = require('./utils/config/index.js')\nconst deref = require('./utils/deref-command.js')\nconst { aliases, cmdList, plumbing } = require('./utils/cmd-list.js')\nconst aliasNames = Object.keys(aliases)\nconst fullList = cmdList.concat(aliasNames).filter(c => !plumbing.includes(c))\nconst nopt = require('nopt')\nconst configNames = Object.keys(definitions)\nconst shorthandNames = Object.keys(shorthands)\nconst allConfs = configNames.concat(shorthandNames)\nconst isWindowsShell = require('./utils/is-windows-shell.js')\nconst fileExists = require('./utils/file-exists.js')\n\nconst { promisify } = require('util')\nconst BaseCommand = require('./base-command.js')\n\nclass Completion extends BaseCommand {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description () {\n    return 'Tab Completion for npm'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'completion'\n  }\n\n  // completion for the completion command\n  async completion (opts) {\n    if (opts.w > 2)\n      return\n\n    const { resolve } = require('path')\n    const [bashExists, zshExists] = await Promise.all([\n      fileExists(resolve(process.env.HOME, '.bashrc')),\n      fileExists(resolve(process.env.HOME, '.zshrc')),\n    ])\n    const out = []\n    if (zshExists)\n      out.push(['>>', '~/.zshrc'])\n\n    if (bashExists)\n      out.push(['>>', '~/.bashrc'])\n\n    return out\n  }\n\n  exec (args, cb) {\n    this.compl(args).then(() => cb()).catch(cb)\n  }\n\n  async compl (args) {\n    if (isWindowsShell) {\n      const msg = 'npm completion supported only in MINGW / Git bash on Windows'\n      throw Object.assign(new Error(msg), {\n        code: 'ENOTSUP',\n      })\n    }\n\n    const { COMP_CWORD, COMP_LINE, COMP_POINT } = process.env\n\n    // if the COMP_* isn't in the env, then just dump the script.\n    if (COMP_CWORD === undefined ||\n      COMP_LINE === undefined ||\n      COMP_POINT === undefined)\n      return dumpScript()\n\n    // ok we're actually looking at the envs and outputting the suggestions\n    // get the partial line and partial word,\n    // if the point isn't at the end.\n    // ie, tabbing at: npm foo b|ar\n    const w = +COMP_CWORD\n    const words = args.map(unescape)\n    const word = words[w]\n    const line = COMP_LINE\n    const point = +COMP_POINT\n    const partialLine = line.substr(0, point)\n    const partialWords = words.slice(0, w)\n\n    // figure out where in that last word the point is.\n    const partialWordRaw = args[w]\n    let i = partialWordRaw.length\n    while (partialWordRaw.substr(0, i) !== partialLine.substr(-1 * i) && i > 0)\n      i--\n\n    const partialWord = unescape(partialWordRaw.substr(0, i))\n    partialWords.push(partialWord)\n\n    const opts = {\n      words,\n      w,\n      word,\n      line,\n      lineLength: line.length,\n      point,\n      partialLine,\n      partialWords,\n      partialWord,\n      raw: args,\n    }\n\n    if (partialWords.slice(0, -1).indexOf('--') === -1) {\n      if (word.charAt(0) === '-')\n        return this.wrap(opts, configCompl(opts))\n\n      if (words[w - 1] &&\n        words[w - 1].charAt(0) === '-' &&\n        !isFlag(words[w - 1])) {\n        // awaiting a value for a non-bool config.\n        // don't even try to do this for now\n        return this.wrap(opts, configValueCompl(opts))\n      }\n    }\n\n    // try to find the npm command.\n    // it's the first thing after all the configs.\n    // take a little shortcut and use npm's arg parsing logic.\n    // don't have to worry about the last arg being implicitly\n    // boolean'ed, since the last block will catch that.\n    const types = Object.entries(definitions).reduce((types, [key, def]) => {\n      types[key] = def.type\n      return types\n    }, {})\n    const parsed = opts.conf =\n      nopt(types, shorthands, partialWords.slice(0, -1), 0)\n    // check if there's a command already.\n    const cmd = parsed.argv.remain[1]\n    if (!cmd)\n      return this.wrap(opts, cmdCompl(opts))\n\n    Object.keys(parsed).forEach(k => this.npm.config.set(k, parsed[k]))\n\n    // at this point, if words[1] is some kind of npm command,\n    // then complete on it.\n    // otherwise, do nothing\n    const impl = this.npm.commands[cmd]\n    if (impl && impl.completion) {\n      const comps = await impl.completion(opts)\n      return this.wrap(opts, comps)\n    }\n  }\n\n  // The command should respond with an array.  Loop over that,\n  // wrapping quotes around any that have spaces, and writing\n  // them to stdout.\n  // If any of the items are arrays, then join them with a space.\n  // Ie, returning ['a', 'b c', ['d', 'e']] would allow it to expand\n  // to: 'a', 'b c', or 'd' 'e'\n  wrap (opts, compls) {\n    if (!Array.isArray(compls))\n      compls = compls ? [compls] : []\n\n    compls = compls.map(c =>\n      Array.isArray(c) ? c.map(escape).join(' ') : escape(c))\n\n    if (opts.partialWord)\n      compls = compls.filter(c => c.startsWith(opts.partialWord))\n\n    if (compls.length > 0)\n      this.npm.output(compls.join('\\n'))\n  }\n}\n\nconst dumpScript = async () => {\n  const fs = require('fs')\n  const readFile = promisify(fs.readFile)\n  const { resolve } = require('path')\n  const p = resolve(__dirname, 'utils/completion.sh')\n\n  const d = (await readFile(p, 'utf8')).replace(/^#!.*?\\n/, '')\n  await new Promise((res, rej) => {\n    let done = false\n    process.stdout.write(d, () => {\n      if (done)\n        return\n\n      done = true\n      res()\n    })\n\n    process.stdout.on('error', er => {\n      if (done)\n        return\n\n      done = true\n\n      // Darwin is a pain sometimes.\n      //\n      // This is necessary because the \"source\" or \".\" program in\n      // bash on OS X closes its file argument before reading\n      // from it, meaning that you get exactly 1 write, which will\n      // work most of the time, and will always raise an EPIPE.\n      //\n      // Really, one should not be tossing away EPIPE errors, or any\n      // errors, so casually.  But, without this, `. <(npm completion)`\n      // can never ever work on OS X.\n      if (er.errno === 'EPIPE')\n        res()\n      else\n        rej(er)\n    })\n  })\n}\n\nconst unescape = w => w.charAt(0) === '\\'' ? w.replace(/^'|'$/g, '')\n  : w.replace(/\\\\ /g, ' ')\n\nconst escape = w => !/\\s+/.test(w) ? w\n  : '\\'' + w + '\\''\n\n// the current word has a dash.  Return the config names,\n// with the same number of dashes as the current word has.\nconst configCompl = opts => {\n  const word = opts.word\n  const split = word.match(/^(-+)((?:no-)*)(.*)$/)\n  const dashes = split[1]\n  const no = split[2]\n  const flags = configNames.filter(isFlag)\n  return allConfs.map(c => dashes + c)\n    .concat(flags.map(f => dashes + (no || 'no-') + f))\n}\n\n// expand with the valid values of various config values.\n// not yet implemented.\nconst configValueCompl = opts => []\n\n// check if the thing is a flag or not.\nconst isFlag = word => {\n  // shorthands never take args.\n  const split = word.match(/^(-*)((?:no-)+)?(.*)$/)\n  const no = split[2]\n  const conf = split[3]\n  const {type} = definitions[conf]\n  return no ||\n    type === Boolean ||\n    (Array.isArray(type) && type.includes(Boolean)) ||\n    shorthands[conf]\n}\n\n// complete against the npm commands\n// if they all resolve to the same thing, just return the thing it already is\nconst cmdCompl = opts => {\n  const matches = fullList.filter(c => c.startsWith(opts.partialWord))\n  if (!matches.length)\n    return matches\n\n  const derefs = new Set([...matches.map(c => deref(c))])\n  if (derefs.size === 1)\n    return [...derefs]\n\n  return fullList\n}\n\nmodule.exports = Completion\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}