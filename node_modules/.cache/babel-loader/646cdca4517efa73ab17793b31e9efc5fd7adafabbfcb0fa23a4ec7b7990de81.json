{"ast":null,"code":"// class that describes a config key we know about\n// this keeps us from defining a config key and not\n// providing a default, description, etc.\n//\n// TODO: some kind of categorization system, so we can\n// say \"these are for registry access\", \"these are for\n// version resolution\" etc.\n\nconst required = ['type', 'description', 'default', 'key'];\nconst allowed = ['default', 'defaultDescription', 'deprecated', 'description', 'flatten', 'hint', 'key', 'short', 'type', 'typeDescription', 'usage', 'envExport'];\nconst {\n  typeDefs: {\n    semver: {\n      type: semver\n    },\n    Umask: {\n      type: Umask\n    },\n    url: {\n      type: url\n    },\n    path: {\n      type: path\n    }\n  }\n} = require('@npmcli/config');\nclass Definition {\n  constructor(key, def) {\n    this.key = key;\n    // if it's set falsey, don't export it, otherwise we do by default\n    this.envExport = true;\n    Object.assign(this, def);\n    this.validate();\n    if (!this.defaultDescription) this.defaultDescription = describeValue(this.default);\n    if (!this.typeDescription) this.typeDescription = describeType(this.type);\n    // hint is only used for non-boolean values\n    if (!this.hint) {\n      if (this.type === Number) this.hint = '<number>';else this.hint = `<${this.key}>`;\n    }\n    if (!this.usage) this.usage = describeUsage(this);\n  }\n  validate() {\n    for (const req of required) {\n      if (!Object.prototype.hasOwnProperty.call(this, req)) throw new Error(`config lacks ${req}: ${this.key}`);\n    }\n    if (!this.key) throw new Error(`config lacks key: ${this.key}`);\n    for (const field of Object.keys(this)) {\n      if (!allowed.includes(field)) throw new Error(`config defines unknown field ${field}: ${this.key}`);\n    }\n  }\n\n  // a textual description of this config, suitable for help output\n  describe() {\n    const description = unindent(this.description);\n    const noEnvExport = this.envExport ? '' : `\nThis value is not exported to the environment for child processes.\n`;\n    const deprecated = !this.deprecated ? '' : `* DEPRECATED: ${unindent(this.deprecated)}\\n`;\n    return wrapAll(`#### \\`${this.key}\\`\n\n* Default: ${unindent(this.defaultDescription)}\n* Type: ${unindent(this.typeDescription)}\n${deprecated}\n${description}\n${noEnvExport}`);\n  }\n}\nconst describeUsage = def => {\n  let key = '';\n\n  // Single type\n  if (!Array.isArray(def.type)) {\n    if (def.short) key = `-${def.short}|`;\n    if (def.type === Boolean && def.default !== false) key = `${key}--no-${def.key}`;else key = `${key}--${def.key}`;\n    if (def.type !== Boolean) key = `${key} ${def.hint}`;\n    return key;\n  }\n  key = `--${def.key}`;\n  if (def.short) key = `-${def.short}|--${def.key}`;\n\n  // Multiple types\n  let types = def.type;\n  const multiple = types.includes(Array);\n  const bool = types.includes(Boolean);\n\n  // null type means optional and doesn't currently affect usage output since\n  // all non-optional params have defaults so we render everything as optional\n  types = types.filter(t => t !== null && t !== Array && t !== Boolean);\n  if (!types.length) return key;\n  let description;\n  if (!types.some(t => typeof t !== 'string'))\n    // Specific values, use specifics given\n    description = `<${types.filter(d => d).join('|')}>`;else {\n    // Generic values, use hint\n    description = def.hint;\n  }\n  if (bool) {\n    // Currently none of our multi-type configs with boolean values default to\n    // false so all their hints should show `--no-`, if we ever add ones that\n    // default to false we can branch the logic here\n    key = `--no-${def.key}|${key}`;\n  }\n  const usage = `${key} ${description}`;\n  if (multiple) return `${usage} [${usage} ...]`;else return usage;\n};\nconst describeType = type => {\n  if (Array.isArray(type)) {\n    const descriptions = type.filter(t => t !== Array).map(t => describeType(t));\n\n    // [a] => \"a\"\n    // [a, b] => \"a or b\"\n    // [a, b, c] => \"a, b, or c\"\n    // [a, Array] => \"a (can be set multiple times)\"\n    // [a, Array, b] => \"a or b (can be set multiple times)\"\n    const last = descriptions.length > 1 ? [descriptions.pop()] : [];\n    const oxford = descriptions.length > 1 ? ', or ' : ' or ';\n    const words = [descriptions.join(', ')].concat(last).join(oxford);\n    const multiple = type.includes(Array) ? ' (can be set multiple times)' : '';\n    return `${words}${multiple}`;\n  }\n\n  // Note: these are not quite the same as the description printed\n  // when validation fails.  In that case, we want to give the user\n  // a bit more information to help them figure out what's wrong.\n  switch (type) {\n    case String:\n      return 'String';\n    case Number:\n      return 'Number';\n    case Umask:\n      return 'Octal numeric string in range 0000..0777 (0..511)';\n    case Boolean:\n      return 'Boolean';\n    case Date:\n      return 'Date';\n    case path:\n      return 'Path';\n    case semver:\n      return 'SemVer string';\n    case url:\n      return 'URL';\n    default:\n      return describeValue(type);\n  }\n};\n\n// if it's a string, quote it.  otherwise, just cast to string.\nconst describeValue = val => typeof val === 'string' ? JSON.stringify(val) : String(val);\nconst unindent = s => {\n  // get the first \\n followed by a bunch of spaces, and pluck off\n  // that many spaces from the start of every line.\n  const match = s.match(/\\n +/);\n  return !match ? s.trim() : s.split(match[0]).join('\\n').trim();\n};\nconst wrap = s => {\n  const cols = Math.min(Math.max(20, process.stdout.columns) || 80, 80) - 5;\n  return unindent(s).split(/[ \\n]+/).reduce((left, right) => {\n    const last = left.split('\\n').pop();\n    const join = last.length && last.length + right.length > cols ? '\\n' : ' ';\n    return left + join + right;\n  });\n};\nconst wrapAll = s => {\n  let inCodeBlock = false;\n  return s.split('\\n\\n').map(block => {\n    if (inCodeBlock || block.startsWith('```')) {\n      inCodeBlock = !block.endsWith('```');\n      return block;\n    }\n    if (block.charAt(0) === '*') {\n      return '* ' + block.substr(1).trim().split('\\n* ').map(li => {\n        return wrap(li).replace(/\\n/g, '\\n  ');\n      }).join('\\n* ');\n    } else return wrap(block);\n  }).join('\\n\\n');\n};\nmodule.exports = Definition;","map":{"version":3,"names":["required","allowed","typeDefs","semver","type","Umask","url","path","require","Definition","constructor","key","def","envExport","Object","assign","validate","defaultDescription","describeValue","default","typeDescription","describeType","hint","Number","usage","describeUsage","req","prototype","hasOwnProperty","call","Error","field","keys","includes","describe","description","unindent","noEnvExport","deprecated","wrapAll","Array","isArray","short","Boolean","types","multiple","bool","filter","t","length","some","d","join","descriptions","map","last","pop","oxford","words","concat","String","Date","val","JSON","stringify","s","match","trim","split","wrap","cols","Math","min","max","process","stdout","columns","reduce","left","right","inCodeBlock","block","startsWith","endsWith","charAt","substr","li","replace","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/lib/utils/config/definition.js"],"sourcesContent":["// class that describes a config key we know about\n// this keeps us from defining a config key and not\n// providing a default, description, etc.\n//\n// TODO: some kind of categorization system, so we can\n// say \"these are for registry access\", \"these are for\n// version resolution\" etc.\n\nconst required = [\n  'type',\n  'description',\n  'default',\n  'key',\n]\n\nconst allowed = [\n  'default',\n  'defaultDescription',\n  'deprecated',\n  'description',\n  'flatten',\n  'hint',\n  'key',\n  'short',\n  'type',\n  'typeDescription',\n  'usage',\n  'envExport',\n]\n\nconst {\n  typeDefs: {\n    semver: { type: semver },\n    Umask: { type: Umask },\n    url: { type: url },\n    path: { type: path },\n  },\n} = require('@npmcli/config')\n\nclass Definition {\n  constructor (key, def) {\n    this.key = key\n    // if it's set falsey, don't export it, otherwise we do by default\n    this.envExport = true\n    Object.assign(this, def)\n    this.validate()\n    if (!this.defaultDescription)\n      this.defaultDescription = describeValue(this.default)\n    if (!this.typeDescription)\n      this.typeDescription = describeType(this.type)\n    // hint is only used for non-boolean values\n    if (!this.hint) {\n      if (this.type === Number)\n        this.hint = '<number>'\n      else\n        this.hint = `<${this.key}>`\n    }\n    if (!this.usage)\n      this.usage = describeUsage(this)\n  }\n\n  validate () {\n    for (const req of required) {\n      if (!Object.prototype.hasOwnProperty.call(this, req))\n        throw new Error(`config lacks ${req}: ${this.key}`)\n    }\n    if (!this.key)\n      throw new Error(`config lacks key: ${this.key}`)\n    for (const field of Object.keys(this)) {\n      if (!allowed.includes(field))\n        throw new Error(`config defines unknown field ${field}: ${this.key}`)\n    }\n  }\n\n  // a textual description of this config, suitable for help output\n  describe () {\n    const description = unindent(this.description)\n    const noEnvExport = this.envExport ? '' : `\nThis value is not exported to the environment for child processes.\n`\n    const deprecated = !this.deprecated ? ''\n      : `* DEPRECATED: ${unindent(this.deprecated)}\\n`\n    return wrapAll(`#### \\`${this.key}\\`\n\n* Default: ${unindent(this.defaultDescription)}\n* Type: ${unindent(this.typeDescription)}\n${deprecated}\n${description}\n${noEnvExport}`)\n  }\n}\n\nconst describeUsage = (def) => {\n  let key = ''\n\n  // Single type\n  if (!Array.isArray(def.type)) {\n    if (def.short)\n      key = `-${def.short}|`\n\n    if (def.type === Boolean && def.default !== false)\n      key = `${key}--no-${def.key}`\n    else\n      key = `${key}--${def.key}`\n\n    if (def.type !== Boolean)\n      key = `${key} ${def.hint}`\n\n    return key\n  }\n\n  key = `--${def.key}`\n  if (def.short)\n    key = `-${def.short}|--${def.key}`\n\n  // Multiple types\n  let types = def.type\n  const multiple = types.includes(Array)\n  const bool = types.includes(Boolean)\n\n  // null type means optional and doesn't currently affect usage output since\n  // all non-optional params have defaults so we render everything as optional\n  types = types.filter(t => t !== null && t !== Array && t !== Boolean)\n\n  if (!types.length)\n    return key\n\n  let description\n  if (!types.some(t => typeof t !== 'string'))\n    // Specific values, use specifics given\n    description = `<${types.filter(d => d).join('|')}>`\n  else {\n    // Generic values, use hint\n    description = def.hint\n  }\n\n  if (bool) {\n    // Currently none of our multi-type configs with boolean values default to\n    // false so all their hints should show `--no-`, if we ever add ones that\n    // default to false we can branch the logic here\n    key = `--no-${def.key}|${key}`\n  }\n\n  const usage = `${key} ${description}`\n  if (multiple)\n    return `${usage} [${usage} ...]`\n  else\n    return usage\n}\n\nconst describeType = type => {\n  if (Array.isArray(type)) {\n    const descriptions = type\n      .filter(t => t !== Array)\n      .map(t => describeType(t))\n\n    // [a] => \"a\"\n    // [a, b] => \"a or b\"\n    // [a, b, c] => \"a, b, or c\"\n    // [a, Array] => \"a (can be set multiple times)\"\n    // [a, Array, b] => \"a or b (can be set multiple times)\"\n    const last = descriptions.length > 1 ? [descriptions.pop()] : []\n    const oxford = descriptions.length > 1 ? ', or ' : ' or '\n    const words = [descriptions.join(', ')].concat(last).join(oxford)\n    const multiple = type.includes(Array) ? ' (can be set multiple times)'\n      : ''\n    return `${words}${multiple}`\n  }\n\n  // Note: these are not quite the same as the description printed\n  // when validation fails.  In that case, we want to give the user\n  // a bit more information to help them figure out what's wrong.\n  switch (type) {\n    case String:\n      return 'String'\n    case Number:\n      return 'Number'\n    case Umask:\n      return 'Octal numeric string in range 0000..0777 (0..511)'\n    case Boolean:\n      return 'Boolean'\n    case Date:\n      return 'Date'\n    case path:\n      return 'Path'\n    case semver:\n      return 'SemVer string'\n    case url:\n      return 'URL'\n    default:\n      return describeValue(type)\n  }\n}\n\n// if it's a string, quote it.  otherwise, just cast to string.\nconst describeValue = val =>\n  typeof val === 'string' ? JSON.stringify(val) : String(val)\n\nconst unindent = s => {\n  // get the first \\n followed by a bunch of spaces, and pluck off\n  // that many spaces from the start of every line.\n  const match = s.match(/\\n +/)\n  return !match ? s.trim() : s.split(match[0]).join('\\n').trim()\n}\n\nconst wrap = (s) => {\n  const cols = Math.min(Math.max(20, process.stdout.columns) || 80, 80) - 5\n  return unindent(s).split(/[ \\n]+/).reduce((left, right) => {\n    const last = left.split('\\n').pop()\n    const join = last.length && last.length + right.length > cols ? '\\n' : ' '\n    return left + join + right\n  })\n}\n\nconst wrapAll = s => {\n  let inCodeBlock = false\n  return s.split('\\n\\n').map(block => {\n    if (inCodeBlock || block.startsWith('```')) {\n      inCodeBlock = !block.endsWith('```')\n      return block\n    }\n\n    if (block.charAt(0) === '*') {\n      return '* ' + block.substr(1).trim().split('\\n* ').map(li => {\n        return wrap(li).replace(/\\n/g, '\\n  ')\n      }).join('\\n* ')\n    } else\n      return wrap(block)\n  }).join('\\n\\n')\n}\n\nmodule.exports = Definition\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}