{"ast":null,"code":"const signals = require('./signals.js');\n\n// for testing, expose the process being used\nmodule.exports = Object.assign(fn => setup(fn), {\n  process\n});\n\n// do all of this in a setup function so that we can call it\n// multiple times for multiple reifies that might be going on.\n// Otherwise, Arborist.reify() is a global action, which is a\n// new constraint we'd be adding with this behavior.\nconst setup = fn => {\n  const {\n    process\n  } = module.exports;\n  const sigListeners = {\n    loaded: false\n  };\n  const unload = () => {\n    if (!sigListeners.loaded) {\n      return;\n    }\n    for (const sig of signals) {\n      try {\n        process.removeListener(sig, sigListeners[sig]);\n      } catch (er) {}\n    }\n    process.removeListener('beforeExit', onBeforeExit);\n    sigListeners.loaded = false;\n  };\n  const onBeforeExit = () => {\n    // this trick ensures that we exit with the same signal we caught\n    // Ie, if you press ^C and npm gets a SIGINT, we'll do the rollback\n    // and then exit with a SIGINT signal once we've removed the handler.\n    // The timeout is there because signals are asynchronous, so we need\n    // the process to NOT exit on its own, which means we have to have\n    // something keeping the event loop looping.  Hence this hack.\n    unload();\n    process.kill(process.pid, signalReceived);\n    setTimeout(() => {}, 500);\n  };\n  let signalReceived = null;\n  const listener = (sig, fn) => () => {\n    signalReceived = sig;\n\n    // if we exit normally, but caught a signal which would have been fatal,\n    // then re-send it once we're done with whatever cleanup we have to do.\n    unload();\n    if (process.listeners(sig).length < 1) {\n      process.once('beforeExit', onBeforeExit);\n    }\n    fn({\n      signal: sig\n    });\n  };\n\n  // do the actual loading here\n  for (const sig of signals) {\n    sigListeners[sig] = listener(sig, fn);\n    const max = process.getMaxListeners();\n    try {\n      // if we call this a bunch of times, avoid triggering the warning\n      const {\n        length\n      } = process.listeners(sig);\n      if (length >= max) {\n        process.setMaxListeners(length + 1);\n      }\n      process.on(sig, sigListeners[sig]);\n    } catch (er) {}\n  }\n  sigListeners.loaded = true;\n  return unload;\n};","map":{"version":3,"names":["signals","require","module","exports","Object","assign","fn","setup","process","sigListeners","loaded","unload","sig","removeListener","er","onBeforeExit","kill","pid","signalReceived","setTimeout","listener","listeners","length","once","signal","max","getMaxListeners","setMaxListeners","on"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/signal-handling.js"],"sourcesContent":["const signals = require('./signals.js')\n\n// for testing, expose the process being used\nmodule.exports = Object.assign(fn => setup(fn), { process })\n\n// do all of this in a setup function so that we can call it\n// multiple times for multiple reifies that might be going on.\n// Otherwise, Arborist.reify() is a global action, which is a\n// new constraint we'd be adding with this behavior.\nconst setup = fn => {\n  const { process } = module.exports\n\n  const sigListeners = { loaded: false }\n\n  const unload = () => {\n    if (!sigListeners.loaded) {\n      return\n    }\n    for (const sig of signals) {\n      try {\n        process.removeListener(sig, sigListeners[sig])\n      } catch (er) {}\n    }\n    process.removeListener('beforeExit', onBeforeExit)\n    sigListeners.loaded = false\n  }\n\n  const onBeforeExit = () => {\n    // this trick ensures that we exit with the same signal we caught\n    // Ie, if you press ^C and npm gets a SIGINT, we'll do the rollback\n    // and then exit with a SIGINT signal once we've removed the handler.\n    // The timeout is there because signals are asynchronous, so we need\n    // the process to NOT exit on its own, which means we have to have\n    // something keeping the event loop looping.  Hence this hack.\n    unload()\n    process.kill(process.pid, signalReceived)\n    setTimeout(() => {}, 500)\n  }\n\n  let signalReceived = null\n  const listener = (sig, fn) => () => {\n    signalReceived = sig\n\n    // if we exit normally, but caught a signal which would have been fatal,\n    // then re-send it once we're done with whatever cleanup we have to do.\n    unload()\n    if (process.listeners(sig).length < 1) {\n      process.once('beforeExit', onBeforeExit)\n    }\n\n    fn({ signal: sig })\n  }\n\n  // do the actual loading here\n  for (const sig of signals) {\n    sigListeners[sig] = listener(sig, fn)\n    const max = process.getMaxListeners()\n    try {\n      // if we call this a bunch of times, avoid triggering the warning\n      const { length } = process.listeners(sig)\n      if (length >= max) {\n        process.setMaxListeners(length + 1)\n      }\n      process.on(sig, sigListeners[sig])\n    } catch (er) {}\n  }\n  sigListeners.loaded = true\n\n  return unload\n}\n"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,cAAc,CAAC;;AAEvC;AACAC,MAAM,CAACC,OAAO,GAAGC,MAAM,CAACC,MAAM,CAACC,EAAE,IAAIC,KAAK,CAACD,EAAE,CAAC,EAAE;EAAEE;AAAQ,CAAC,CAAC;;AAE5D;AACA;AACA;AACA;AACA,MAAMD,KAAK,GAAGD,EAAE,IAAI;EAClB,MAAM;IAAEE;EAAQ,CAAC,GAAGN,MAAM,CAACC,OAAO;EAElC,MAAMM,YAAY,GAAG;IAAEC,MAAM,EAAE;EAAM,CAAC;EAEtC,MAAMC,MAAM,GAAGA,CAAA,KAAM;IACnB,IAAI,CAACF,YAAY,CAACC,MAAM,EAAE;MACxB;IACF;IACA,KAAK,MAAME,GAAG,IAAIZ,OAAO,EAAE;MACzB,IAAI;QACFQ,OAAO,CAACK,cAAc,CAACD,GAAG,EAAEH,YAAY,CAACG,GAAG,CAAC,CAAC;MAChD,CAAC,CAAC,OAAOE,EAAE,EAAE,CAAC;IAChB;IACAN,OAAO,CAACK,cAAc,CAAC,YAAY,EAAEE,YAAY,CAAC;IAClDN,YAAY,CAACC,MAAM,GAAG,KAAK;EAC7B,CAAC;EAED,MAAMK,YAAY,GAAGA,CAAA,KAAM;IACzB;IACA;IACA;IACA;IACA;IACA;IACAJ,MAAM,CAAC,CAAC;IACRH,OAAO,CAACQ,IAAI,CAACR,OAAO,CAACS,GAAG,EAAEC,cAAc,CAAC;IACzCC,UAAU,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC;EAC3B,CAAC;EAED,IAAID,cAAc,GAAG,IAAI;EACzB,MAAME,QAAQ,GAAGA,CAACR,GAAG,EAAEN,EAAE,KAAK,MAAM;IAClCY,cAAc,GAAGN,GAAG;;IAEpB;IACA;IACAD,MAAM,CAAC,CAAC;IACR,IAAIH,OAAO,CAACa,SAAS,CAACT,GAAG,CAAC,CAACU,MAAM,GAAG,CAAC,EAAE;MACrCd,OAAO,CAACe,IAAI,CAAC,YAAY,EAAER,YAAY,CAAC;IAC1C;IAEAT,EAAE,CAAC;MAAEkB,MAAM,EAAEZ;IAAI,CAAC,CAAC;EACrB,CAAC;;EAED;EACA,KAAK,MAAMA,GAAG,IAAIZ,OAAO,EAAE;IACzBS,YAAY,CAACG,GAAG,CAAC,GAAGQ,QAAQ,CAACR,GAAG,EAAEN,EAAE,CAAC;IACrC,MAAMmB,GAAG,GAAGjB,OAAO,CAACkB,eAAe,CAAC,CAAC;IACrC,IAAI;MACF;MACA,MAAM;QAAEJ;MAAO,CAAC,GAAGd,OAAO,CAACa,SAAS,CAACT,GAAG,CAAC;MACzC,IAAIU,MAAM,IAAIG,GAAG,EAAE;QACjBjB,OAAO,CAACmB,eAAe,CAACL,MAAM,GAAG,CAAC,CAAC;MACrC;MACAd,OAAO,CAACoB,EAAE,CAAChB,GAAG,EAAEH,YAAY,CAACG,GAAG,CAAC,CAAC;IACpC,CAAC,CAAC,OAAOE,EAAE,EAAE,CAAC;EAChB;EACAL,YAAY,CAACC,MAAM,GAAG,IAAI;EAE1B,OAAOC,MAAM;AACf,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}