{"ast":null,"code":"// Sometimes we need to actually do a walk from the root, because you can\n// have a cycle of deps that all depend on each other, but no path from root.\n// Also, since the ideal tree is loaded from the shrinkwrap, it had extraneous\n// flags set false that might now be actually extraneous, and dev/optional\n// flags that are also now incorrect.  This method sets all flags to true, so\n// we can find the set that is actually extraneous.\nmodule.exports = tree => {\n  for (const node of tree.inventory.values()) {\n    node.extraneous = true;\n    node.dev = true;\n    node.devOptional = true;\n    node.peer = true;\n    node.optional = true;\n  }\n};","map":{"version":3,"names":["module","exports","tree","node","inventory","values","extraneous","dev","devOptional","peer","optional"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/reset-dep-flags.js"],"sourcesContent":["// Sometimes we need to actually do a walk from the root, because you can\n// have a cycle of deps that all depend on each other, but no path from root.\n// Also, since the ideal tree is loaded from the shrinkwrap, it had extraneous\n// flags set false that might now be actually extraneous, and dev/optional\n// flags that are also now incorrect.  This method sets all flags to true, so\n// we can find the set that is actually extraneous.\nmodule.exports = tree => {\n  for (const node of tree.inventory.values()) {\n    node.extraneous = true\n    node.dev = true\n    node.devOptional = true\n    node.peer = true\n    node.optional = true\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,OAAO,GAAGC,IAAI,IAAI;EACvB,KAAK,MAAMC,IAAI,IAAID,IAAI,CAACE,SAAS,CAACC,MAAM,CAAC,CAAC,EAAE;IAC1CF,IAAI,CAACG,UAAU,GAAG,IAAI;IACtBH,IAAI,CAACI,GAAG,GAAG,IAAI;IACfJ,IAAI,CAACK,WAAW,GAAG,IAAI;IACvBL,IAAI,CAACM,IAAI,GAAG,IAAI;IAChBN,IAAI,CAACO,QAAQ,GAAG,IAAI;EACtB;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}