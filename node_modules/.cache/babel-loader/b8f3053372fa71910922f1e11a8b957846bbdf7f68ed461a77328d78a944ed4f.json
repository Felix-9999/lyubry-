{"ast":null,"code":"// inventory, path, realpath, root, and parent\n//\n// node.root is a reference to the root module in the tree (ie, typically the\n// cwd project folder)\n//\n// node.location is the /-delimited path from the root module to the node.  In\n// the case of link targets that may be outside of the root's package tree,\n// this can include some number of /../ path segments.  The location of the\n// root module is always '.'.  node.location thus never contains drive letters\n// or absolute paths, and is portable within a given project, suitable for\n// inclusion in lockfiles and metadata.\n//\n// node.path is the path to the place where this node lives on disk.  It is\n// system-specific and absolute.\n//\n// node.realpath is the path to where the module actually resides on disk.  In\n// the case of non-link nodes, node.realpath is equivalent to node.path.  In\n// the case of link nodes, it is equivalent to node.target.path.\n//\n// Setting node.parent will set the node's root to the parent's root, as well\n// as updating edgesIn and edgesOut to reload dependency resolutions as needed,\n// and setting node.path to parent.path/node_modules/name.\n//\n// node.inventory is a Map of name to a Set() of all the nodes under a given\n// root by that name.  It's empty for non-root nodes, and changing the root\n// reference will remove it from the old root's inventory and add it to the new\n// one.  This map is useful for cases like `npm update foo` or `npm ls foo`\n// where we need to quickly find all instances of a given package name within a\n// tree.\n\nconst semver = require('semver');\nconst nameFromFolder = require('@npmcli/name-from-folder');\nconst Edge = require('./edge.js');\nconst Inventory = require('./inventory.js');\nconst {\n  normalize\n} = require('read-package-json-fast');\nconst {\n  getPaths: getBinPaths\n} = require('bin-links');\nconst npa = require('npm-package-arg');\nconst debug = require('./debug.js');\nconst gatherDepSet = require('./gather-dep-set.js');\nconst treeCheck = require('./tree-check.js');\nconst walkUp = require('walk-up-path');\nconst {\n  resolve,\n  relative,\n  dirname,\n  basename\n} = require('path');\nconst util = require('util');\nconst _package = Symbol('_package');\nconst _parent = Symbol('_parent');\nconst _target = Symbol.for('_target');\nconst _fsParent = Symbol('_fsParent');\nconst _loadDepType = Symbol('_loadDepType');\nconst _loadWorkspaces = Symbol('_loadWorkspaces');\nconst _reloadNamedEdges = Symbol('_reloadNamedEdges');\n// overridden by Link class\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps');\nconst _root = Symbol('_root');\nconst _refreshLocation = Symbol.for('_refreshLocation');\nconst _changePath = Symbol.for('_changePath');\n// used by Link class as well\nconst _delistFromMeta = Symbol.for('_delistFromMeta');\nconst _global = Symbol.for('global');\nconst _workspaces = Symbol('_workspaces');\nconst _explain = Symbol('_explain');\nconst _explanation = Symbol('_explanation');\nconst _meta = Symbol('_meta');\nconst relpath = require('./relpath.js');\nconst consistentResolve = require('./consistent-resolve.js');\nconst printableTree = require('./printable.js');\nconst CaseInsensitiveMap = require('./case-insensitive-map.js');\nclass Node {\n  constructor(options) {\n    // NB: path can be null if it's a link target\n    const {\n      root,\n      path,\n      realpath,\n      parent,\n      error,\n      meta,\n      fsParent,\n      resolved,\n      integrity,\n      // allow setting name explicitly when we haven't set a path yet\n      name,\n      children,\n      fsChildren,\n      legacyPeerDeps = false,\n      linksIn,\n      hasShrinkwrap,\n      extraneous = true,\n      dev = true,\n      optional = true,\n      devOptional = true,\n      peer = true,\n      global = false,\n      dummy = false,\n      sourceReference = null\n    } = options;\n\n    // true if part of a global install\n    this[_global] = global;\n    this[_workspaces] = null;\n    this.errors = error ? [error] : [];\n\n    // this will usually be null, except when modeling a\n    // package's dependencies in a virtual root.\n    this.sourceReference = sourceReference;\n    const pkg = sourceReference ? sourceReference.package : normalize(options.pkg || {});\n    this.name = name || nameFromFolder(path || pkg.name || realpath) || pkg.name || null;\n\n    // should be equal if not a link\n    this.path = path ? resolve(path) : null;\n    if (!this.name && (!this.path || this.path !== dirname(this.path))) {\n      throw new TypeError('could not detect node name from path or package');\n    }\n    this.realpath = !this.isLink ? this.path : resolve(realpath);\n    this.resolved = resolved || null;\n    if (!this.resolved) {\n      // note: this *only* works for non-file: deps, so we avoid even\n      // trying here.\n      // file: deps are tracked in package.json will _resolved set to the\n      // full path to the tarball or link target.  However, if the package\n      // is checked into git or moved to another location, that's 100% not\n      // portable at all!  The _where and _location don't provide much help,\n      // since _location is just where the module ended up in the tree,\n      // and _where can be different than the actual root if it's a\n      // meta-dep deeper in the dependency graph.\n      //\n      // If we don't have the other oldest indicators of legacy npm, then it's\n      // probably what we're getting from pacote, which IS trustworthy.\n      //\n      // Otherwise, hopefully a shrinkwrap will help us out.\n      const resolved = consistentResolve(pkg._resolved);\n      if (resolved && !(/^file:/.test(resolved) && pkg._where)) {\n        this.resolved = resolved;\n      }\n    }\n    this.integrity = integrity || pkg._integrity || null;\n    this.hasShrinkwrap = hasShrinkwrap || pkg._hasShrinkwrap || false;\n    this.legacyPeerDeps = legacyPeerDeps;\n    this.children = new CaseInsensitiveMap();\n    this.fsChildren = new Set();\n    this.inventory = new Inventory({});\n    this.tops = new Set();\n    this.linksIn = new Set(linksIn || []);\n\n    // these three are set by an Arborist taking a catalog\n    // after the tree is built.  We don't get this along the way,\n    // because they have a tendency to change as new children are\n    // added, especially when they're deduped.  Eg, a dev dep may be\n    // a 3-levels-deep dependency of a non-dev dep.  If we calc the\n    // flags along the way, then they'll tend to be invalid  by the\n    // time we need to look at them.\n    if (!dummy) {\n      this.dev = dev;\n      this.optional = optional;\n      this.devOptional = devOptional;\n      this.peer = peer;\n      this.extraneous = extraneous;\n      this.dummy = false;\n    } else {\n      // true if this is a placeholder for the purpose of serving as a\n      // fsParent to link targets that get their deps resolved outside\n      // the root tree folder.\n      this.dummy = true;\n      this.dev = false;\n      this.optional = false;\n      this.devOptional = false;\n      this.peer = false;\n      this.extraneous = false;\n    }\n    this.edgesIn = new Set();\n    this.edgesOut = new CaseInsensitiveMap();\n\n    // have to set the internal package ref before assigning the parent,\n    // because this.package is read when adding to inventory\n    this[_package] = pkg && typeof pkg === 'object' ? pkg : {};\n\n    // only relevant for the root and top nodes\n    this.meta = meta;\n\n    // Note: this is _slightly_ less efficient for the initial tree\n    // building than it could be, but in exchange, it's a much simpler\n    // algorithm.\n    // If this node has a bunch of children, and those children satisfy\n    // its various deps, then we're going to _first_ create all the\n    // edges, and _then_ assign the children into place, re-resolving\n    // them all in _reloadNamedEdges.\n    // A more efficient, but more complicated, approach would be to\n    // flag this node as being a part of a tree build, so it could\n    // hold off on resolving its deps until its children are in place.\n\n    // call the parent setter\n    // Must be set prior to calling _loadDeps, because top-ness is relevant\n\n    // will also assign root if present on the parent\n    this[_parent] = null;\n    this.parent = parent || null;\n    this[_fsParent] = null;\n    this.fsParent = fsParent || null;\n\n    // see parent/root setters below.\n    // root is set to parent's root if we have a parent, otherwise if it's\n    // null, then it's set to the node itself.\n    if (!parent && !fsParent) {\n      this.root = root || null;\n    }\n\n    // mostly a convenience for testing, but also a way to create\n    // trees in a more declarative way than setting parent on each\n    if (children) {\n      for (const c of children) {\n        new Node({\n          ...c,\n          parent: this\n        });\n      }\n    }\n    if (fsChildren) {\n      for (const c of fsChildren) {\n        new Node({\n          ...c,\n          fsParent: this\n        });\n      }\n    }\n\n    // now load all the dep edges\n    this[_loadDeps]();\n  }\n  get meta() {\n    return this[_meta];\n  }\n  set meta(meta) {\n    this[_meta] = meta;\n    if (meta) {\n      meta.add(this);\n    }\n  }\n  get global() {\n    return this.root[_global];\n  }\n\n  // true for packages installed directly in the global node_modules folder\n  get globalTop() {\n    return this.global && this.parent && this.parent.isProjectRoot;\n  }\n  get workspaces() {\n    return this[_workspaces];\n  }\n  set workspaces(workspaces) {\n    // deletes edges if they already exists\n    if (this[_workspaces]) {\n      for (const name of this[_workspaces].keys()) {\n        if (!workspaces.has(name)) {\n          this.edgesOut.get(name).detach();\n        }\n      }\n    }\n    this[_workspaces] = workspaces;\n    this[_loadWorkspaces]();\n    this[_loadDeps]();\n  }\n  get binPaths() {\n    if (!this.parent) {\n      return [];\n    }\n    return getBinPaths({\n      pkg: this[_package],\n      path: this.path,\n      global: this.global,\n      top: this.globalTop\n    });\n  }\n  get hasInstallScript() {\n    const {\n      hasInstallScript,\n      scripts\n    } = this.package;\n    const {\n      install,\n      preinstall,\n      postinstall\n    } = scripts || {};\n    return !!(hasInstallScript || install || preinstall || postinstall);\n  }\n  get version() {\n    return this[_package].version || '';\n  }\n  get packageName() {\n    return this[_package].name || null;\n  }\n  get pkgid() {\n    const {\n      name = '',\n      version = ''\n    } = this.package;\n    // root package will prefer package name over folder name,\n    // and never be called an alias.\n    const {\n      isProjectRoot\n    } = this;\n    const myname = isProjectRoot ? name || this.name : this.name;\n    const alias = !isProjectRoot && name && myname !== name ? `npm:${name}@` : '';\n    return `${myname}@${alias}${version}`;\n  }\n  get package() {\n    return this[_package];\n  }\n  set package(pkg) {\n    // just detach them all.  we could make this _slightly_ more efficient\n    // by only detaching the ones that changed, but we'd still have to walk\n    // them all, and the comparison logic gets a bit tricky.  we generally\n    // only do this more than once at the root level, so the resolve() calls\n    // are only one level deep, and there's not much to be saved, anyway.\n    // simpler to just toss them all out.\n    for (const edge of this.edgesOut.values()) {\n      edge.detach();\n    }\n    this[_explanation] = null;\n    /* istanbul ignore next - should be impossible */\n    if (!pkg || typeof pkg !== 'object') {\n      debug(() => {\n        throw new Error('setting Node.package to non-object');\n      });\n      pkg = {};\n    }\n    this[_package] = pkg;\n    this[_loadWorkspaces]();\n    this[_loadDeps]();\n    // do a hard reload, since the dependents may now be valid or invalid\n    // as a result of the package change.\n    this.edgesIn.forEach(edge => edge.reload(true));\n  }\n\n  // node.explain(nodes seen already, edge we're trying to satisfy\n  // if edge is not specified, it lists every edge into the node.\n  explain(edge = null, seen = []) {\n    if (this[_explanation]) {\n      return this[_explanation];\n    }\n    return this[_explanation] = this[_explain](edge, seen);\n  }\n  [_explain](edge, seen) {\n    if (this.isProjectRoot && !this.sourceReference) {\n      return {\n        location: this.path\n      };\n    }\n    const why = {\n      name: this.isProjectRoot || this.isTop ? this.packageName : this.name,\n      version: this.package.version\n    };\n    if (this.errors.length || !this.packageName || !this.package.version) {\n      why.errors = this.errors.length ? this.errors : [new Error('invalid package: lacks name and/or version')];\n      why.package = this.package;\n    }\n    if (this.root.sourceReference) {\n      const {\n        name,\n        version\n      } = this.root.package;\n      why.whileInstalling = {\n        name,\n        version,\n        path: this.root.sourceReference.path\n      };\n    }\n    if (this.sourceReference) {\n      return this.sourceReference.explain(edge, seen);\n    }\n    if (seen.includes(this)) {\n      return why;\n    }\n    why.location = this.location;\n    why.isWorkspace = this.isWorkspace;\n\n    // make a new list each time.  we can revisit, but not loop.\n    seen = seen.concat(this);\n    why.dependents = [];\n    if (edge) {\n      why.dependents.push(edge.explain(seen));\n    } else {\n      // ignore invalid edges, since those aren't satisfied by this thing,\n      // and are not keeping it held in this spot anyway.\n      const edges = [];\n      for (const edge of this.edgesIn) {\n        if (!edge.valid && !edge.from.isProjectRoot) {\n          continue;\n        }\n        edges.push(edge);\n      }\n      for (const edge of edges) {\n        why.dependents.push(edge.explain(seen));\n      }\n    }\n    if (this.linksIn.size) {\n      why.linksIn = [...this.linksIn].map(link => link[_explain](edge, seen));\n    }\n    return why;\n  }\n  isDescendantOf(node) {\n    for (let p = this; p; p = p.resolveParent) {\n      if (p === node) {\n        return true;\n      }\n    }\n    return false;\n  }\n  getBundler(path = []) {\n    // made a cycle, definitely not bundled!\n    if (path.includes(this)) {\n      return null;\n    }\n    path.push(this);\n    const parent = this[_parent];\n    if (!parent) {\n      return null;\n    }\n    const pBundler = parent.getBundler(path);\n    if (pBundler) {\n      return pBundler;\n    }\n    const ppkg = parent.package;\n    const bd = ppkg && ppkg.bundleDependencies;\n    // explicit bundling\n    if (Array.isArray(bd) && bd.includes(this.name)) {\n      return parent;\n    }\n\n    // deps that are deduped up to the bundling level are bundled.\n    // however, if they get their dep met further up than that,\n    // then they are not bundled.  Ie, installing a package with\n    // unmet bundled deps will not cause your deps to be bundled.\n    for (const edge of this.edgesIn) {\n      const eBundler = edge.from.getBundler(path);\n      if (!eBundler) {\n        continue;\n      }\n      if (eBundler === parent) {\n        return eBundler;\n      }\n    }\n    return null;\n  }\n  get inBundle() {\n    return !!this.getBundler();\n  }\n\n  // when reifying, if a package is technically in a bundleDependencies list,\n  // but that list is the root project, we still have to install it.  This\n  // getter returns true if it's in a dependency's bundle list, not the root's.\n  get inDepBundle() {\n    const bundler = this.getBundler();\n    return !!bundler && bundler !== this.root;\n  }\n  get isWorkspace() {\n    if (this.isProjectRoot) {\n      return false;\n    }\n    const {\n      root\n    } = this;\n    const {\n      type,\n      to\n    } = root.edgesOut.get(this.packageName) || {};\n    return type === 'workspace' && to && (to.target === this || to === this);\n  }\n  get isRoot() {\n    return this === this.root;\n  }\n  get isProjectRoot() {\n    // only treat as project root if it's the actual link that is the root,\n    // or the target of the root link, but NOT if it's another link to the\n    // same root that happens to be somewhere else.\n    return this === this.root || this === this.root.target;\n  }\n  *ancestry() {\n    for (let anc = this; anc; anc = anc.resolveParent) {\n      yield anc;\n    }\n  }\n  set root(root) {\n    // setting to null means this is the new root\n    // should only ever be one step\n    while (root && root.root !== root) {\n      root = root.root;\n    }\n    root = root || this;\n\n    // delete from current root inventory\n    this[_delistFromMeta]();\n\n    // can't set the root (yet) if there's no way to determine location\n    // this allows us to do new Node({...}) and then set the root later.\n    // just make the assignment so we don't lose it, and move on.\n    if (!this.path || !root.realpath || !root.path) {\n      return this[_root] = root;\n    }\n\n    // temporarily become a root node\n    this[_root] = this;\n\n    // break all linksIn, we're going to re-set them if needed later\n    for (const link of this.linksIn) {\n      link[_target] = null;\n      this.linksIn.delete(link);\n    }\n\n    // temporarily break this link as well, we'll re-set if possible later\n    const {\n      target\n    } = this;\n    if (this.isLink) {\n      if (target) {\n        target.linksIn.delete(this);\n        if (target.root === this) {\n          target[_delistFromMeta]();\n        }\n      }\n      this[_target] = null;\n    }\n\n    // if this is part of a cascading root set, then don't do this bit\n    // but if the parent/fsParent is in a different set, we have to break\n    // that reference before proceeding\n    if (this.parent && this.parent.root !== root) {\n      this.parent.children.delete(this.name);\n      this[_parent] = null;\n    }\n    if (this.fsParent && this.fsParent.root !== root) {\n      this.fsParent.fsChildren.delete(this);\n      this[_fsParent] = null;\n    }\n    if (root === this) {\n      this[_refreshLocation]();\n    } else {\n      // setting to some different node.\n      const loc = relpath(root.realpath, this.path);\n      const current = root.inventory.get(loc);\n\n      // clobber whatever is there now\n      if (current) {\n        current.root = null;\n      }\n      this[_root] = root;\n      // set this.location and add to inventory\n      this[_refreshLocation]();\n\n      // try to find our parent/fsParent in the new root inventory\n      for (const p of walkUp(dirname(this.path))) {\n        if (p === this.path) {\n          continue;\n        }\n        const ploc = relpath(root.realpath, p);\n        const parent = root.inventory.get(ploc);\n        if (parent) {\n          /* istanbul ignore next - impossible */\n          if (parent.isLink) {\n            debug(() => {\n              throw Object.assign(new Error('assigning parentage to link'), {\n                path: this.path,\n                parent: parent.path,\n                parentReal: parent.realpath\n              });\n            });\n            continue;\n          }\n          const childLoc = `${ploc}${ploc ? '/' : ''}node_modules/${this.name}`;\n          const isParent = this.location === childLoc;\n          if (isParent) {\n            const oldChild = parent.children.get(this.name);\n            if (oldChild && oldChild !== this) {\n              oldChild.root = null;\n            }\n            if (this.parent) {\n              this.parent.children.delete(this.name);\n              this.parent[_reloadNamedEdges](this.name);\n            }\n            parent.children.set(this.name, this);\n            this[_parent] = parent;\n            // don't do it for links, because they don't have a target yet\n            // we'll hit them up a bit later on.\n            if (!this.isLink) {\n              parent[_reloadNamedEdges](this.name);\n            }\n          } else {\n            /* istanbul ignore if - should be impossible, since we break\n             * all fsParent/child relationships when moving? */\n            if (this.fsParent) {\n              this.fsParent.fsChildren.delete(this);\n            }\n            parent.fsChildren.add(this);\n            this[_fsParent] = parent;\n          }\n          break;\n        }\n      }\n\n      // if it doesn't have a parent, it's a top node\n      if (!this.parent) {\n        root.tops.add(this);\n      } else {\n        root.tops.delete(this);\n      }\n\n      // assign parentage for any nodes that need to have this as a parent\n      // this can happen when we have a node at nm/a/nm/b added *before*\n      // the node at nm/a, which might have the root node as a fsParent.\n      // we can't rely on the public setter here, because it calls into\n      // this function to set up these references!\n      const nmloc = `${this.location}${this.location ? '/' : ''}node_modules/`;\n      const isChild = n => n.location === nmloc + n.name;\n      // check dirname so that /foo isn't treated as the fsparent of /foo-bar\n      const isFsChild = n => {\n        return dirname(n.path).startsWith(this.path) && n !== this && !n.parent && (!n.fsParent || n.fsParent === this || dirname(this.path).startsWith(n.fsParent.path));\n      };\n      const isKid = n => isChild(n) || isFsChild(n);\n\n      // only walk top nodes, since anything else already has a parent.\n      for (const child of root.tops) {\n        if (!isKid(child)) {\n          continue;\n        }\n\n        // set up the internal parentage links\n        if (this.isLink) {\n          child.root = null;\n        } else {\n          // can't possibly have a parent, because it's in tops\n          if (child.fsParent) {\n            child.fsParent.fsChildren.delete(child);\n          }\n          child[_fsParent] = null;\n          if (isChild(child)) {\n            this.children.set(child.name, child);\n            child[_parent] = this;\n            root.tops.delete(child);\n          } else {\n            this.fsChildren.add(child);\n            child[_fsParent] = this;\n          }\n        }\n      }\n\n      // look for any nodes with the same realpath.  either they're links\n      // to that realpath, or a thing at that realpath if we're adding a link\n      // (if we're adding a regular node, we already deleted the old one)\n      for (const node of root.inventory.query('realpath', this.realpath)) {\n        if (node === this) {\n          continue;\n        }\n\n        /* istanbul ignore next - should be impossible */\n        debug(() => {\n          if (node.root !== root) {\n            throw new Error('inventory contains node from other root');\n          }\n        });\n        if (this.isLink) {\n          const target = node.target;\n          this[_target] = target;\n          this[_package] = target.package;\n          target.linksIn.add(this);\n          // reload edges here, because now we have a target\n          if (this.parent) {\n            this.parent[_reloadNamedEdges](this.name);\n          }\n          break;\n        } else {\n          /* istanbul ignore else - should be impossible */\n          if (node.isLink) {\n            node[_target] = this;\n            node[_package] = this.package;\n            this.linksIn.add(node);\n            if (node.parent) {\n              node.parent[_reloadNamedEdges](node.name);\n            }\n          } else {\n            debug(() => {\n              throw Object.assign(new Error('duplicate node in root setter'), {\n                path: this.path,\n                realpath: this.realpath,\n                root: root.realpath\n              });\n            });\n          }\n        }\n      }\n    }\n\n    // reload all edgesIn where the root doesn't match, so we don't have\n    // cross-tree dependency graphs\n    for (const edge of this.edgesIn) {\n      if (edge.from.root !== root) {\n        edge.reload();\n      }\n    }\n    // reload all edgesOut where root doens't match, or is missing, since\n    // it might not be missing in the new tree\n    for (const edge of this.edgesOut.values()) {\n      if (!edge.to || edge.to.root !== root) {\n        edge.reload();\n      }\n    }\n\n    // now make sure our family comes along for the ride!\n    const family = new Set([...this.fsChildren, ...this.children.values(), ...this.inventory.values()].filter(n => n !== this));\n    for (const child of family) {\n      if (child.root !== root) {\n        child[_delistFromMeta]();\n        child[_parent] = null;\n        this.children.delete(child.name);\n        child[_fsParent] = null;\n        this.fsChildren.delete(child);\n        for (const l of child.linksIn) {\n          l[_target] = null;\n          child.linksIn.delete(l);\n        }\n      }\n    }\n    for (const child of family) {\n      if (child.root !== root) {\n        child.root = root;\n      }\n    }\n\n    // if we had a target, and didn't find one in the new root, then bring\n    // it over as well, but only if we're setting the link into a new root,\n    // as we don't want to lose the target any time we remove a link.\n    if (this.isLink && target && !this.target && root !== this) {\n      target.root = root;\n    }\n\n    // tree should always be valid upon root setter completion.\n    treeCheck(this);\n    treeCheck(root);\n  }\n  get root() {\n    return this[_root] || this;\n  }\n  [_loadWorkspaces]() {\n    if (!this[_workspaces]) {\n      return;\n    }\n    for (const [name, path] of this[_workspaces].entries()) {\n      new Edge({\n        from: this,\n        name,\n        spec: `file:${path}`,\n        type: 'workspace'\n      });\n    }\n  }\n  [_loadDeps]() {\n    // Caveat!  Order is relevant!\n    // Packages in optionalDependencies are optional.\n    // Packages in both deps and devDeps are required.\n    // Note the subtle breaking change from v6: it is no longer possible\n    // to have a different spec for a devDep than production dep.\n\n    // Linked targets that are disconnected from the tree are tops,\n    // but don't have a 'path' field, only a 'realpath', because we\n    // don't know their canonical location. We don't need their devDeps.\n    const pd = this.package.peerDependencies;\n    if (pd && typeof pd === 'object' && !this.legacyPeerDeps) {\n      const pm = this.package.peerDependenciesMeta || {};\n      const peerDependencies = {};\n      const peerOptional = {};\n      for (const [name, dep] of Object.entries(pd)) {\n        if (pm[name] && pm[name].optional) {\n          peerOptional[name] = dep;\n        } else {\n          peerDependencies[name] = dep;\n        }\n      }\n      this[_loadDepType](peerDependencies, 'peer');\n      this[_loadDepType](peerOptional, 'peerOptional');\n    }\n    this[_loadDepType](this.package.dependencies, 'prod');\n    this[_loadDepType](this.package.optionalDependencies, 'optional');\n    const {\n      globalTop,\n      isTop,\n      path,\n      sourceReference\n    } = this;\n    const {\n      globalTop: srcGlobalTop,\n      isTop: srcTop,\n      path: srcPath\n    } = sourceReference || {};\n    const thisDev = isTop && !globalTop && path;\n    const srcDev = !sourceReference || srcTop && !srcGlobalTop && srcPath;\n    if (thisDev && srcDev) {\n      this[_loadDepType](this.package.devDependencies, 'dev');\n    }\n  }\n  [_loadDepType](deps, type) {\n    const ad = this.package.acceptDependencies || {};\n    // Because of the order in which _loadDeps runs, we always want to\n    // prioritize a new edge over an existing one\n    for (const [name, spec] of Object.entries(deps || {})) {\n      const current = this.edgesOut.get(name);\n      if (!current || current.type !== 'workspace') {\n        new Edge({\n          from: this,\n          name,\n          spec,\n          accept: ad[name],\n          type\n        });\n      }\n    }\n  }\n  get fsParent() {\n    const parent = this[_fsParent];\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if (parent === this) {\n        throw new Error('node set to its own fsParent');\n      }\n    });\n    return parent;\n  }\n  set fsParent(fsParent) {\n    if (!fsParent) {\n      if (this[_fsParent]) {\n        this.root = null;\n      }\n      return;\n    }\n    debug(() => {\n      if (fsParent === this) {\n        throw new Error('setting node to its own fsParent');\n      }\n      if (fsParent.realpath === this.realpath) {\n        throw new Error('setting fsParent to same path');\n      }\n\n      // the initial set MUST be an actual walk-up from the realpath\n      // subsequent sets will re-root on the new fsParent's path.\n      if (!this[_fsParent] && this.realpath.indexOf(fsParent.realpath) !== 0) {\n        throw Object.assign(new Error('setting fsParent improperly'), {\n          path: this.path,\n          realpath: this.realpath,\n          fsParent: {\n            path: fsParent.path,\n            realpath: fsParent.realpath\n          }\n        });\n      }\n    });\n    if (fsParent.isLink) {\n      fsParent = fsParent.target;\n    }\n\n    // setting a thing to its own fsParent is not normal, but no-op for safety\n    if (this === fsParent || fsParent.realpath === this.realpath) {\n      return;\n    }\n\n    // nothing to do\n    if (this[_fsParent] === fsParent) {\n      return;\n    }\n    const oldFsParent = this[_fsParent];\n    const newPath = !oldFsParent ? this.path : resolve(fsParent.path, relative(oldFsParent.path, this.path));\n    const nmPath = resolve(fsParent.path, 'node_modules', this.name);\n\n    // this is actually the parent, set that instead\n    if (newPath === nmPath) {\n      this.parent = fsParent;\n      return;\n    }\n    const pathChange = newPath !== this.path;\n\n    // remove from old parent/fsParent\n    const oldParent = this.parent;\n    const oldName = this.name;\n    if (this.parent) {\n      this.parent.children.delete(this.name);\n      this[_parent] = null;\n    }\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this);\n      this[_fsParent] = null;\n    }\n\n    // update this.path/realpath for this and all children/fsChildren\n    if (pathChange) {\n      this[_changePath](newPath);\n    }\n    if (oldParent) {\n      oldParent[_reloadNamedEdges](oldName);\n    }\n\n    // clobbers anything at that path, resets all appropriate references\n    this.root = fsParent.root;\n  }\n\n  // is it safe to replace one node with another?  check the edges to\n  // make sure no one will get upset.  Note that the node might end up\n  // having its own unmet dependencies, if the new node has new deps.\n  // Note that there are cases where Arborist will opt to insert a node\n  // into the tree even though this function returns false!  This is\n  // necessary when a root dependency is added or updated, or when a\n  // root dependency brings peer deps along with it.  In that case, we\n  // will go ahead and create the invalid state, and then try to resolve\n  // it with more tree construction, because it's a user request.\n  canReplaceWith(node, ignorePeers = []) {\n    if (node.name !== this.name) {\n      return false;\n    }\n    if (node.packageName !== this.packageName) {\n      return false;\n    }\n    ignorePeers = new Set(ignorePeers);\n\n    // gather up all the deps of this node and that are only depended\n    // upon by deps of this node.  those ones don't count, since\n    // they'll be replaced if this node is replaced anyway.\n    const depSet = gatherDepSet([this], e => e.to !== this && e.valid);\n    for (const edge of this.edgesIn) {\n      // when replacing peer sets, we need to be able to replace the entire\n      // peer group, which means we ignore incoming edges from other peers\n      // within the replacement set.\n      const ignored = !this.isTop && edge.from.parent === this.parent && edge.peer && ignorePeers.has(edge.from.name);\n      if (ignored) {\n        continue;\n      }\n\n      // only care about edges that don't originate from this node\n      if (!depSet.has(edge.from) && !edge.satisfiedBy(node)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  canReplace(node, ignorePeers) {\n    return node.canReplaceWith(this, ignorePeers);\n  }\n\n  // return true if it's safe to remove this node, because anything that\n  // is depending on it would be fine with the thing that they would resolve\n  // to if it was removed, or nothing is depending on it in the first place.\n  canDedupe(preferDedupe = false) {\n    // not allowed to mess with shrinkwraps or bundles\n    if (this.inDepBundle || this.inShrinkwrap) {\n      return false;\n    }\n\n    // it's a top level pkg, or a dep of one\n    if (!this.resolveParent || !this.resolveParent.resolveParent) {\n      return false;\n    }\n\n    // no one wants it, remove it\n    if (this.edgesIn.size === 0) {\n      return true;\n    }\n    const other = this.resolveParent.resolveParent.resolve(this.name);\n\n    // nothing else, need this one\n    if (!other) {\n      return false;\n    }\n\n    // if it's the same thing, then always fine to remove\n    if (other.matches(this)) {\n      return true;\n    }\n\n    // if the other thing can't replace this, then skip it\n    if (!other.canReplace(this)) {\n      return false;\n    }\n\n    // if we prefer dedupe, or if the version is greater/equal, take the other\n    if (preferDedupe || semver.gte(other.version, this.version)) {\n      return true;\n    }\n    return false;\n  }\n  satisfies(requested) {\n    if (requested instanceof Edge) {\n      return this.name === requested.name && requested.satisfiedBy(this);\n    }\n    const parsed = npa(requested);\n    const {\n      name = this.name,\n      rawSpec: spec\n    } = parsed;\n    return this.name === name && this.satisfies(new Edge({\n      from: new Node({\n        path: this.root.realpath\n      }),\n      type: 'prod',\n      name,\n      spec\n    }));\n  }\n  matches(node) {\n    // if the nodes are literally the same object, obviously a match.\n    if (node === this) {\n      return true;\n    }\n\n    // if the names don't match, they're different things, even if\n    // the package contents are identical.\n    if (node.name !== this.name) {\n      return false;\n    }\n\n    // if they're links, they match if the targets match\n    if (this.isLink) {\n      return node.isLink && this.target.matches(node.target);\n    }\n\n    // if they're two project root nodes, they're different if the paths differ\n    if (this.isProjectRoot && node.isProjectRoot) {\n      return this.path === node.path;\n    }\n\n    // if the integrity matches, then they're the same.\n    if (this.integrity && node.integrity) {\n      return this.integrity === node.integrity;\n    }\n\n    // if no integrity, check resolved\n    if (this.resolved && node.resolved) {\n      return this.resolved === node.resolved;\n    }\n\n    // if no resolved, check both package name and version\n    // otherwise, conclude that they are different things\n    return this.packageName && node.packageName && this.packageName === node.packageName && this.version && node.version && this.version === node.version;\n  }\n\n  // replace this node with the supplied argument\n  // Useful when mutating an ideal tree, so we can avoid having to call\n  // the parent/root setters more than necessary.\n  replaceWith(node) {\n    node.replace(this);\n  }\n  replace(node) {\n    this[_delistFromMeta]();\n\n    // if the name matches, but is not identical, we are intending to clobber\n    // something case-insensitively, so merely setting name and path won't\n    // have the desired effect.  just set the path so it'll collide in the\n    // parent's children map, and leave it at that.\n    const nameMatch = node.parent && node.parent.children.get(this.name) === node;\n    if (nameMatch) {\n      this.path = resolve(node.parent.path, 'node_modules', this.name);\n    } else {\n      this.path = node.path;\n      this.name = node.name;\n    }\n    if (!this.isLink) {\n      this.realpath = this.path;\n    }\n    this[_refreshLocation]();\n\n    // keep children when a node replaces another\n    if (!this.isLink) {\n      for (const kid of node.children.values()) {\n        kid.parent = this;\n      }\n    }\n    if (!node.isRoot) {\n      this.root = node.root;\n    }\n    treeCheck(this);\n  }\n  get inShrinkwrap() {\n    return this.parent && (this.parent.hasShrinkwrap || this.parent.inShrinkwrap);\n  }\n  get parent() {\n    const parent = this[_parent];\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if (parent === this) {\n        throw new Error('node set to its own parent');\n      }\n    });\n    return parent;\n  }\n\n  // This setter keeps everything in order when we move a node from\n  // one point in a logical tree to another.  Edges get reloaded,\n  // metadata updated, etc.  It's also called when we *replace* a node\n  // with another by the same name (eg, to update or dedupe).\n  // This does a couple of walks out on the node_modules tree, recursing\n  // into child nodes.  However, as setting the parent is typically done\n  // with nodes that don't have have many children, and (deduped) package\n  // trees tend to be broad rather than deep, it's not that bad.\n  // The only walk that starts from the parent rather than this node is\n  // limited by edge name.\n  set parent(parent) {\n    // when setting to null, just remove it from the tree entirely\n    if (!parent) {\n      // but only delete it if we actually had a parent in the first place\n      // otherwise it's just setting to null when it's already null\n      if (this[_parent]) {\n        this.root = null;\n      }\n      return;\n    }\n    if (parent.isLink) {\n      parent = parent.target;\n    }\n\n    // setting a thing to its own parent is not normal, but no-op for safety\n    if (this === parent) {\n      return;\n    }\n    const oldParent = this[_parent];\n\n    // nothing to do\n    if (oldParent === parent) {\n      return;\n    }\n\n    // ok now we know something is actually changing, and parent is not a link\n    const newPath = resolve(parent.path, 'node_modules', this.name);\n    const pathChange = newPath !== this.path;\n\n    // remove from old parent/fsParent\n    if (oldParent) {\n      oldParent.children.delete(this.name);\n      this[_parent] = null;\n    }\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this);\n      this[_fsParent] = null;\n    }\n\n    // update this.path/realpath for this and all children/fsChildren\n    if (pathChange) {\n      this[_changePath](newPath);\n    }\n\n    // clobbers anything at that path, resets all appropriate references\n    this.root = parent.root;\n  }\n\n  // Call this before changing path or updating the _root reference.\n  // Removes the node from its root the metadata and inventory.\n  [_delistFromMeta]() {\n    const root = this.root;\n    if (!root.realpath || !this.path) {\n      return;\n    }\n    root.inventory.delete(this);\n    root.tops.delete(this);\n    if (root.meta) {\n      root.meta.delete(this.path);\n    }\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if ([...root.inventory.values()].includes(this)) {\n        throw new Error('failed to delist');\n      }\n    });\n  }\n\n  // update this.path/realpath and the paths of all children/fsChildren\n  [_changePath](newPath) {\n    // have to de-list before changing paths\n    this[_delistFromMeta]();\n    const oldPath = this.path;\n    this.path = newPath;\n    const namePattern = /(?:^|\\/|\\\\)node_modules[\\\\/](@[^/\\\\]+[\\\\/][^\\\\/]+|[^\\\\/]+)$/;\n    const nameChange = newPath.match(namePattern);\n    if (nameChange && this.name !== nameChange[1]) {\n      this.name = nameChange[1].replace(/\\\\/g, '/');\n    }\n\n    // if we move a link target, update link realpaths\n    if (!this.isLink) {\n      this.realpath = newPath;\n      for (const link of this.linksIn) {\n        link[_delistFromMeta]();\n        link.realpath = newPath;\n        link[_refreshLocation]();\n      }\n    }\n    // if we move /x to /y, then a module at /x/a/b becomes /y/a/b\n    for (const child of this.fsChildren) {\n      child[_changePath](resolve(newPath, relative(oldPath, child.path)));\n    }\n    for (const [name, child] of this.children.entries()) {\n      child[_changePath](resolve(newPath, 'node_modules', name));\n    }\n    this[_refreshLocation]();\n  }\n\n  // Called whenever the root/parent is changed.\n  // NB: need to remove from former root's meta/inventory and then update\n  // this.path BEFORE calling this method!\n  [_refreshLocation]() {\n    const root = this.root;\n    const loc = relpath(root.realpath, this.path);\n    this.location = loc;\n    root.inventory.add(this);\n    if (root.meta) {\n      root.meta.add(this);\n    }\n  }\n  addEdgeOut(edge) {\n    this.edgesOut.set(edge.name, edge);\n  }\n  addEdgeIn(edge) {\n    this.edgesIn.add(edge);\n\n    // try to get metadata from the yarn.lock file\n    if (this.root.meta) {\n      this.root.meta.addEdge(edge);\n    }\n  }\n  [_reloadNamedEdges](name, rootLoc = this.location) {\n    const edge = this.edgesOut.get(name);\n    // if we don't have an edge, do nothing, but keep descending\n    const rootLocResolved = edge && edge.to && edge.to.location === `${rootLoc}/node_modules/${edge.name}`;\n    const sameResolved = edge && this.resolve(name) === edge.to;\n    const recheck = rootLocResolved || !sameResolved;\n    if (edge && recheck) {\n      edge.reload(true);\n    }\n    for (const c of this.children.values()) {\n      c[_reloadNamedEdges](name, rootLoc);\n    }\n    for (const c of this.fsChildren) {\n      c[_reloadNamedEdges](name, rootLoc);\n    }\n  }\n  get isLink() {\n    return false;\n  }\n  get target() {\n    return this;\n  }\n  set target(n) {\n    debug(() => {\n      throw Object.assign(new Error('cannot set target on non-Link Nodes'), {\n        path: this.path\n      });\n    });\n  }\n  get depth() {\n    return this.isTop ? 0 : this.parent.depth + 1;\n  }\n  get isTop() {\n    return !this.parent || this.globalTop;\n  }\n  get top() {\n    return this.isTop ? this : this.parent.top;\n  }\n  get isFsTop() {\n    return !this.fsParent;\n  }\n  get fsTop() {\n    return this.isFsTop ? this : this.fsParent.fsTop;\n  }\n  get resolveParent() {\n    return this.parent || this.fsParent;\n  }\n  resolve(name) {\n    /* istanbul ignore next - should be impossible,\n     * but I keep doing this mistake in tests */\n    debug(() => {\n      if (typeof name !== 'string' || !name) {\n        throw new Error('non-string passed to Node.resolve');\n      }\n    });\n    const mine = this.children.get(name);\n    if (mine) {\n      return mine;\n    }\n    const resolveParent = this.resolveParent;\n    if (resolveParent) {\n      return resolveParent.resolve(name);\n    }\n    return null;\n  }\n  inNodeModules() {\n    const rp = this.realpath;\n    const name = this.name;\n    const scoped = name.charAt(0) === '@';\n    const d = dirname(rp);\n    const nm = scoped ? dirname(d) : d;\n    const dir = dirname(nm);\n    const base = scoped ? `${basename(d)}/${basename(rp)}` : basename(rp);\n    return base === name && basename(nm) === 'node_modules' ? dir : false;\n  }\n  toJSON() {\n    return printableTree(this);\n  }\n  [util.inspect.custom]() {\n    return this.toJSON();\n  }\n}\nmodule.exports = Node;","map":{"version":3,"names":["semver","require","nameFromFolder","Edge","Inventory","normalize","getPaths","getBinPaths","npa","debug","gatherDepSet","treeCheck","walkUp","resolve","relative","dirname","basename","util","_package","Symbol","_parent","_target","for","_fsParent","_loadDepType","_loadWorkspaces","_reloadNamedEdges","_loadDeps","_root","_refreshLocation","_changePath","_delistFromMeta","_global","_workspaces","_explain","_explanation","_meta","relpath","consistentResolve","printableTree","CaseInsensitiveMap","Node","constructor","options","root","path","realpath","parent","error","meta","fsParent","resolved","integrity","name","children","fsChildren","legacyPeerDeps","linksIn","hasShrinkwrap","extraneous","dev","optional","devOptional","peer","global","dummy","sourceReference","errors","pkg","package","TypeError","isLink","_resolved","test","_where","_integrity","_hasShrinkwrap","Set","inventory","tops","edgesIn","edgesOut","c","add","globalTop","isProjectRoot","workspaces","keys","has","get","detach","binPaths","top","hasInstallScript","scripts","install","preinstall","postinstall","version","packageName","pkgid","myname","alias","edge","values","Error","forEach","reload","explain","seen","location","why","isTop","length","whileInstalling","includes","isWorkspace","concat","dependents","push","edges","valid","from","size","map","link","isDescendantOf","node","p","resolveParent","getBundler","pBundler","ppkg","bd","bundleDependencies","Array","isArray","eBundler","inBundle","inDepBundle","bundler","type","to","target","isRoot","ancestry","anc","delete","loc","current","ploc","Object","assign","parentReal","childLoc","isParent","oldChild","set","nmloc","isChild","n","isFsChild","startsWith","isKid","child","query","family","filter","l","entries","spec","pd","peerDependencies","pm","peerDependenciesMeta","peerOptional","dep","dependencies","optionalDependencies","srcGlobalTop","srcTop","srcPath","thisDev","srcDev","devDependencies","deps","ad","acceptDependencies","accept","indexOf","oldFsParent","newPath","nmPath","pathChange","oldParent","oldName","canReplaceWith","ignorePeers","depSet","e","ignored","satisfiedBy","canReplace","canDedupe","preferDedupe","inShrinkwrap","other","matches","gte","satisfies","requested","parsed","rawSpec","replaceWith","replace","nameMatch","kid","oldPath","namePattern","nameChange","match","addEdgeOut","addEdgeIn","addEdge","rootLoc","rootLocResolved","sameResolved","recheck","depth","isFsTop","fsTop","mine","inNodeModules","rp","scoped","charAt","d","nm","dir","base","toJSON","inspect","custom","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/node.js"],"sourcesContent":["// inventory, path, realpath, root, and parent\n//\n// node.root is a reference to the root module in the tree (ie, typically the\n// cwd project folder)\n//\n// node.location is the /-delimited path from the root module to the node.  In\n// the case of link targets that may be outside of the root's package tree,\n// this can include some number of /../ path segments.  The location of the\n// root module is always '.'.  node.location thus never contains drive letters\n// or absolute paths, and is portable within a given project, suitable for\n// inclusion in lockfiles and metadata.\n//\n// node.path is the path to the place where this node lives on disk.  It is\n// system-specific and absolute.\n//\n// node.realpath is the path to where the module actually resides on disk.  In\n// the case of non-link nodes, node.realpath is equivalent to node.path.  In\n// the case of link nodes, it is equivalent to node.target.path.\n//\n// Setting node.parent will set the node's root to the parent's root, as well\n// as updating edgesIn and edgesOut to reload dependency resolutions as needed,\n// and setting node.path to parent.path/node_modules/name.\n//\n// node.inventory is a Map of name to a Set() of all the nodes under a given\n// root by that name.  It's empty for non-root nodes, and changing the root\n// reference will remove it from the old root's inventory and add it to the new\n// one.  This map is useful for cases like `npm update foo` or `npm ls foo`\n// where we need to quickly find all instances of a given package name within a\n// tree.\n\nconst semver = require('semver')\nconst nameFromFolder = require('@npmcli/name-from-folder')\nconst Edge = require('./edge.js')\nconst Inventory = require('./inventory.js')\nconst {normalize} = require('read-package-json-fast')\nconst {getPaths: getBinPaths} = require('bin-links')\nconst npa = require('npm-package-arg')\nconst debug = require('./debug.js')\nconst gatherDepSet = require('./gather-dep-set.js')\nconst treeCheck = require('./tree-check.js')\nconst walkUp = require('walk-up-path')\n\nconst {resolve, relative, dirname, basename} = require('path')\nconst util = require('util')\nconst _package = Symbol('_package')\nconst _parent = Symbol('_parent')\nconst _target = Symbol.for('_target')\nconst _fsParent = Symbol('_fsParent')\nconst _loadDepType = Symbol('_loadDepType')\nconst _loadWorkspaces = Symbol('_loadWorkspaces')\nconst _reloadNamedEdges = Symbol('_reloadNamedEdges')\n// overridden by Link class\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps')\nconst _root = Symbol('_root')\nconst _refreshLocation = Symbol.for('_refreshLocation')\nconst _changePath = Symbol.for('_changePath')\n// used by Link class as well\nconst _delistFromMeta = Symbol.for('_delistFromMeta')\nconst _global = Symbol.for('global')\nconst _workspaces = Symbol('_workspaces')\nconst _explain = Symbol('_explain')\nconst _explanation = Symbol('_explanation')\nconst _meta = Symbol('_meta')\n\nconst relpath = require('./relpath.js')\nconst consistentResolve = require('./consistent-resolve.js')\n\nconst printableTree = require('./printable.js')\nconst CaseInsensitiveMap = require('./case-insensitive-map.js')\n\nclass Node {\n  constructor (options) {\n    // NB: path can be null if it's a link target\n    const {\n      root,\n      path,\n      realpath,\n      parent,\n      error,\n      meta,\n      fsParent,\n      resolved,\n      integrity,\n      // allow setting name explicitly when we haven't set a path yet\n      name,\n      children,\n      fsChildren,\n      legacyPeerDeps = false,\n      linksIn,\n      hasShrinkwrap,\n      extraneous = true,\n      dev = true,\n      optional = true,\n      devOptional = true,\n      peer = true,\n      global = false,\n      dummy = false,\n      sourceReference = null,\n    } = options\n\n    // true if part of a global install\n    this[_global] = global\n\n    this[_workspaces] = null\n\n    this.errors = error ? [error] : []\n\n    // this will usually be null, except when modeling a\n    // package's dependencies in a virtual root.\n    this.sourceReference = sourceReference\n\n    const pkg = sourceReference ? sourceReference.package\n      : normalize(options.pkg || {})\n\n    this.name = name ||\n      nameFromFolder(path || pkg.name || realpath) ||\n      pkg.name ||\n      null\n\n    // should be equal if not a link\n    this.path = path ? resolve(path) : null\n\n    if (!this.name && (!this.path || this.path !== dirname(this.path))) {\n      throw new TypeError('could not detect node name from path or package')\n    }\n\n    this.realpath = !this.isLink ? this.path : resolve(realpath)\n\n    this.resolved = resolved || null\n    if (!this.resolved) {\n      // note: this *only* works for non-file: deps, so we avoid even\n      // trying here.\n      // file: deps are tracked in package.json will _resolved set to the\n      // full path to the tarball or link target.  However, if the package\n      // is checked into git or moved to another location, that's 100% not\n      // portable at all!  The _where and _location don't provide much help,\n      // since _location is just where the module ended up in the tree,\n      // and _where can be different than the actual root if it's a\n      // meta-dep deeper in the dependency graph.\n      //\n      // If we don't have the other oldest indicators of legacy npm, then it's\n      // probably what we're getting from pacote, which IS trustworthy.\n      //\n      // Otherwise, hopefully a shrinkwrap will help us out.\n      const resolved = consistentResolve(pkg._resolved)\n      if (resolved && !(/^file:/.test(resolved) && pkg._where)) {\n        this.resolved = resolved\n      }\n    }\n    this.integrity = integrity || pkg._integrity || null\n    this.hasShrinkwrap = hasShrinkwrap || pkg._hasShrinkwrap || false\n    this.legacyPeerDeps = legacyPeerDeps\n\n    this.children = new CaseInsensitiveMap()\n    this.fsChildren = new Set()\n    this.inventory = new Inventory({})\n    this.tops = new Set()\n    this.linksIn = new Set(linksIn || [])\n\n    // these three are set by an Arborist taking a catalog\n    // after the tree is built.  We don't get this along the way,\n    // because they have a tendency to change as new children are\n    // added, especially when they're deduped.  Eg, a dev dep may be\n    // a 3-levels-deep dependency of a non-dev dep.  If we calc the\n    // flags along the way, then they'll tend to be invalid  by the\n    // time we need to look at them.\n    if (!dummy) {\n      this.dev = dev\n      this.optional = optional\n      this.devOptional = devOptional\n      this.peer = peer\n      this.extraneous = extraneous\n      this.dummy = false\n    } else {\n      // true if this is a placeholder for the purpose of serving as a\n      // fsParent to link targets that get their deps resolved outside\n      // the root tree folder.\n      this.dummy = true\n      this.dev = false\n      this.optional = false\n      this.devOptional = false\n      this.peer = false\n      this.extraneous = false\n    }\n\n    this.edgesIn = new Set()\n    this.edgesOut = new CaseInsensitiveMap()\n\n    // have to set the internal package ref before assigning the parent,\n    // because this.package is read when adding to inventory\n    this[_package] = pkg && typeof pkg === 'object' ? pkg : {}\n\n    // only relevant for the root and top nodes\n    this.meta = meta\n\n    // Note: this is _slightly_ less efficient for the initial tree\n    // building than it could be, but in exchange, it's a much simpler\n    // algorithm.\n    // If this node has a bunch of children, and those children satisfy\n    // its various deps, then we're going to _first_ create all the\n    // edges, and _then_ assign the children into place, re-resolving\n    // them all in _reloadNamedEdges.\n    // A more efficient, but more complicated, approach would be to\n    // flag this node as being a part of a tree build, so it could\n    // hold off on resolving its deps until its children are in place.\n\n    // call the parent setter\n    // Must be set prior to calling _loadDeps, because top-ness is relevant\n\n    // will also assign root if present on the parent\n    this[_parent] = null\n    this.parent = parent || null\n\n    this[_fsParent] = null\n    this.fsParent = fsParent || null\n\n    // see parent/root setters below.\n    // root is set to parent's root if we have a parent, otherwise if it's\n    // null, then it's set to the node itself.\n    if (!parent && !fsParent) {\n      this.root = root || null\n    }\n\n    // mostly a convenience for testing, but also a way to create\n    // trees in a more declarative way than setting parent on each\n    if (children) {\n      for (const c of children) {\n        new Node({ ...c, parent: this })\n      }\n    }\n    if (fsChildren) {\n      for (const c of fsChildren) {\n        new Node({ ...c, fsParent: this })\n      }\n    }\n\n    // now load all the dep edges\n    this[_loadDeps]()\n  }\n\n  get meta () {\n    return this[_meta]\n  }\n\n  set meta (meta) {\n    this[_meta] = meta\n    if (meta) {\n      meta.add(this)\n    }\n  }\n\n  get global () {\n    return this.root[_global]\n  }\n\n  // true for packages installed directly in the global node_modules folder\n  get globalTop () {\n    return this.global && this.parent && this.parent.isProjectRoot\n  }\n\n  get workspaces () {\n    return this[_workspaces]\n  }\n\n  set workspaces (workspaces) {\n    // deletes edges if they already exists\n    if (this[_workspaces]) {\n      for (const name of this[_workspaces].keys()) {\n        if (!workspaces.has(name)) {\n          this.edgesOut.get(name).detach()\n        }\n      }\n    }\n\n    this[_workspaces] = workspaces\n    this[_loadWorkspaces]()\n    this[_loadDeps]()\n  }\n\n  get binPaths () {\n    if (!this.parent) {\n      return []\n    }\n\n    return getBinPaths({\n      pkg: this[_package],\n      path: this.path,\n      global: this.global,\n      top: this.globalTop,\n    })\n  }\n\n  get hasInstallScript () {\n    const {hasInstallScript, scripts} = this.package\n    const {install, preinstall, postinstall} = scripts || {}\n    return !!(hasInstallScript || install || preinstall || postinstall)\n  }\n\n  get version () {\n    return this[_package].version || ''\n  }\n\n  get packageName () {\n    return this[_package].name || null\n  }\n\n  get pkgid () {\n    const { name = '', version = '' } = this.package\n    // root package will prefer package name over folder name,\n    // and never be called an alias.\n    const { isProjectRoot } = this\n    const myname = isProjectRoot ? name || this.name\n      : this.name\n    const alias = !isProjectRoot && name && myname !== name ? `npm:${name}@`\n      : ''\n    return `${myname}@${alias}${version}`\n  }\n\n  get package () {\n    return this[_package]\n  }\n\n  set package (pkg) {\n    // just detach them all.  we could make this _slightly_ more efficient\n    // by only detaching the ones that changed, but we'd still have to walk\n    // them all, and the comparison logic gets a bit tricky.  we generally\n    // only do this more than once at the root level, so the resolve() calls\n    // are only one level deep, and there's not much to be saved, anyway.\n    // simpler to just toss them all out.\n    for (const edge of this.edgesOut.values()) {\n      edge.detach()\n    }\n\n    this[_explanation] = null\n    /* istanbul ignore next - should be impossible */\n    if (!pkg || typeof pkg !== 'object') {\n      debug(() => {\n        throw new Error('setting Node.package to non-object')\n      })\n      pkg = {}\n    }\n    this[_package] = pkg\n    this[_loadWorkspaces]()\n    this[_loadDeps]()\n    // do a hard reload, since the dependents may now be valid or invalid\n    // as a result of the package change.\n    this.edgesIn.forEach(edge => edge.reload(true))\n  }\n\n  // node.explain(nodes seen already, edge we're trying to satisfy\n  // if edge is not specified, it lists every edge into the node.\n  explain (edge = null, seen = []) {\n    if (this[_explanation]) {\n      return this[_explanation]\n    }\n\n    return this[_explanation] = this[_explain](edge, seen)\n  }\n\n  [_explain] (edge, seen) {\n    if (this.isProjectRoot && !this.sourceReference) {\n      return {\n        location: this.path,\n      }\n    }\n\n    const why = {\n      name: this.isProjectRoot || this.isTop ? this.packageName : this.name,\n      version: this.package.version,\n    }\n    if (this.errors.length || !this.packageName || !this.package.version) {\n      why.errors = this.errors.length ? this.errors : [\n        new Error('invalid package: lacks name and/or version'),\n      ]\n      why.package = this.package\n    }\n\n    if (this.root.sourceReference) {\n      const {name, version} = this.root.package\n      why.whileInstalling = {\n        name,\n        version,\n        path: this.root.sourceReference.path,\n      }\n    }\n\n    if (this.sourceReference) {\n      return this.sourceReference.explain(edge, seen)\n    }\n\n    if (seen.includes(this)) {\n      return why\n    }\n\n    why.location = this.location\n    why.isWorkspace = this.isWorkspace\n\n    // make a new list each time.  we can revisit, but not loop.\n    seen = seen.concat(this)\n\n    why.dependents = []\n    if (edge) {\n      why.dependents.push(edge.explain(seen))\n    } else {\n      // ignore invalid edges, since those aren't satisfied by this thing,\n      // and are not keeping it held in this spot anyway.\n      const edges = []\n      for (const edge of this.edgesIn) {\n        if (!edge.valid && !edge.from.isProjectRoot) {\n          continue\n        }\n\n        edges.push(edge)\n      }\n      for (const edge of edges) {\n        why.dependents.push(edge.explain(seen))\n      }\n    }\n\n    if (this.linksIn.size) {\n      why.linksIn = [...this.linksIn].map(link => link[_explain](edge, seen))\n    }\n\n    return why\n  }\n\n  isDescendantOf (node) {\n    for (let p = this; p; p = p.resolveParent) {\n      if (p === node) {\n        return true\n      }\n    }\n    return false\n  }\n\n  getBundler (path = []) {\n    // made a cycle, definitely not bundled!\n    if (path.includes(this)) {\n      return null\n    }\n\n    path.push(this)\n\n    const parent = this[_parent]\n    if (!parent) {\n      return null\n    }\n\n    const pBundler = parent.getBundler(path)\n    if (pBundler) {\n      return pBundler\n    }\n\n    const ppkg = parent.package\n    const bd = ppkg && ppkg.bundleDependencies\n    // explicit bundling\n    if (Array.isArray(bd) && bd.includes(this.name)) {\n      return parent\n    }\n\n    // deps that are deduped up to the bundling level are bundled.\n    // however, if they get their dep met further up than that,\n    // then they are not bundled.  Ie, installing a package with\n    // unmet bundled deps will not cause your deps to be bundled.\n    for (const edge of this.edgesIn) {\n      const eBundler = edge.from.getBundler(path)\n      if (!eBundler) {\n        continue\n      }\n\n      if (eBundler === parent) {\n        return eBundler\n      }\n    }\n\n    return null\n  }\n\n  get inBundle () {\n    return !!this.getBundler()\n  }\n\n  // when reifying, if a package is technically in a bundleDependencies list,\n  // but that list is the root project, we still have to install it.  This\n  // getter returns true if it's in a dependency's bundle list, not the root's.\n  get inDepBundle () {\n    const bundler = this.getBundler()\n    return !!bundler && bundler !== this.root\n  }\n\n  get isWorkspace () {\n    if (this.isProjectRoot) {\n      return false\n    }\n    const { root } = this\n    const { type, to } = root.edgesOut.get(this.packageName) || {}\n    return type === 'workspace' && to && (to.target === this || to === this)\n  }\n\n  get isRoot () {\n    return this === this.root\n  }\n\n  get isProjectRoot () {\n    // only treat as project root if it's the actual link that is the root,\n    // or the target of the root link, but NOT if it's another link to the\n    // same root that happens to be somewhere else.\n    return this === this.root || this === this.root.target\n  }\n\n  * ancestry () {\n    for (let anc = this; anc; anc = anc.resolveParent) {\n      yield anc\n    }\n  }\n\n  set root (root) {\n    // setting to null means this is the new root\n    // should only ever be one step\n    while (root && root.root !== root) {\n      root = root.root\n    }\n\n    root = root || this\n\n    // delete from current root inventory\n    this[_delistFromMeta]()\n\n    // can't set the root (yet) if there's no way to determine location\n    // this allows us to do new Node({...}) and then set the root later.\n    // just make the assignment so we don't lose it, and move on.\n    if (!this.path || !root.realpath || !root.path) {\n      return this[_root] = root\n    }\n\n    // temporarily become a root node\n    this[_root] = this\n\n    // break all linksIn, we're going to re-set them if needed later\n    for (const link of this.linksIn) {\n      link[_target] = null\n      this.linksIn.delete(link)\n    }\n\n    // temporarily break this link as well, we'll re-set if possible later\n    const { target } = this\n    if (this.isLink) {\n      if (target) {\n        target.linksIn.delete(this)\n        if (target.root === this) {\n          target[_delistFromMeta]()\n        }\n      }\n      this[_target] = null\n    }\n\n    // if this is part of a cascading root set, then don't do this bit\n    // but if the parent/fsParent is in a different set, we have to break\n    // that reference before proceeding\n    if (this.parent && this.parent.root !== root) {\n      this.parent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent && this.fsParent.root !== root) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    if (root === this) {\n      this[_refreshLocation]()\n    } else {\n      // setting to some different node.\n      const loc = relpath(root.realpath, this.path)\n      const current = root.inventory.get(loc)\n\n      // clobber whatever is there now\n      if (current) {\n        current.root = null\n      }\n\n      this[_root] = root\n      // set this.location and add to inventory\n      this[_refreshLocation]()\n\n      // try to find our parent/fsParent in the new root inventory\n      for (const p of walkUp(dirname(this.path))) {\n        if (p === this.path) {\n          continue\n        }\n        const ploc = relpath(root.realpath, p)\n        const parent = root.inventory.get(ploc)\n        if (parent) {\n          /* istanbul ignore next - impossible */\n          if (parent.isLink) {\n            debug(() => {\n              throw Object.assign(new Error('assigning parentage to link'), {\n                path: this.path,\n                parent: parent.path,\n                parentReal: parent.realpath,\n              })\n            })\n            continue\n          }\n          const childLoc = `${ploc}${ploc ? '/' : ''}node_modules/${this.name}`\n          const isParent = this.location === childLoc\n          if (isParent) {\n            const oldChild = parent.children.get(this.name)\n            if (oldChild && oldChild !== this) {\n              oldChild.root = null\n            }\n            if (this.parent) {\n              this.parent.children.delete(this.name)\n              this.parent[_reloadNamedEdges](this.name)\n            }\n            parent.children.set(this.name, this)\n            this[_parent] = parent\n            // don't do it for links, because they don't have a target yet\n            // we'll hit them up a bit later on.\n            if (!this.isLink) {\n              parent[_reloadNamedEdges](this.name)\n            }\n          } else {\n            /* istanbul ignore if - should be impossible, since we break\n             * all fsParent/child relationships when moving? */\n            if (this.fsParent) {\n              this.fsParent.fsChildren.delete(this)\n            }\n            parent.fsChildren.add(this)\n            this[_fsParent] = parent\n          }\n          break\n        }\n      }\n\n      // if it doesn't have a parent, it's a top node\n      if (!this.parent) {\n        root.tops.add(this)\n      } else {\n        root.tops.delete(this)\n      }\n\n      // assign parentage for any nodes that need to have this as a parent\n      // this can happen when we have a node at nm/a/nm/b added *before*\n      // the node at nm/a, which might have the root node as a fsParent.\n      // we can't rely on the public setter here, because it calls into\n      // this function to set up these references!\n      const nmloc = `${this.location}${this.location ? '/' : ''}node_modules/`\n      const isChild = n => n.location === nmloc + n.name\n      // check dirname so that /foo isn't treated as the fsparent of /foo-bar\n      const isFsChild = n => {\n        return dirname(n.path).startsWith(this.path) &&\n          n !== this &&\n          !n.parent &&\n          (!n.fsParent ||\n            n.fsParent === this ||\n            dirname(this.path).startsWith(n.fsParent.path))\n      }\n      const isKid = n => isChild(n) || isFsChild(n)\n\n      // only walk top nodes, since anything else already has a parent.\n      for (const child of root.tops) {\n        if (!isKid(child)) {\n          continue\n        }\n\n        // set up the internal parentage links\n        if (this.isLink) {\n          child.root = null\n        } else {\n          // can't possibly have a parent, because it's in tops\n          if (child.fsParent) {\n            child.fsParent.fsChildren.delete(child)\n          }\n          child[_fsParent] = null\n          if (isChild(child)) {\n            this.children.set(child.name, child)\n            child[_parent] = this\n            root.tops.delete(child)\n          } else {\n            this.fsChildren.add(child)\n            child[_fsParent] = this\n          }\n        }\n      }\n\n      // look for any nodes with the same realpath.  either they're links\n      // to that realpath, or a thing at that realpath if we're adding a link\n      // (if we're adding a regular node, we already deleted the old one)\n      for (const node of root.inventory.query('realpath', this.realpath)) {\n        if (node === this) {\n          continue\n        }\n\n        /* istanbul ignore next - should be impossible */\n        debug(() => {\n          if (node.root !== root) {\n            throw new Error('inventory contains node from other root')\n          }\n        })\n\n        if (this.isLink) {\n          const target = node.target\n          this[_target] = target\n          this[_package] = target.package\n          target.linksIn.add(this)\n          // reload edges here, because now we have a target\n          if (this.parent) {\n            this.parent[_reloadNamedEdges](this.name)\n          }\n          break\n        } else {\n          /* istanbul ignore else - should be impossible */\n          if (node.isLink) {\n            node[_target] = this\n            node[_package] = this.package\n            this.linksIn.add(node)\n            if (node.parent) {\n              node.parent[_reloadNamedEdges](node.name)\n            }\n          } else {\n            debug(() => {\n              throw Object.assign(new Error('duplicate node in root setter'), {\n                path: this.path,\n                realpath: this.realpath,\n                root: root.realpath,\n              })\n            })\n          }\n        }\n      }\n    }\n\n    // reload all edgesIn where the root doesn't match, so we don't have\n    // cross-tree dependency graphs\n    for (const edge of this.edgesIn) {\n      if (edge.from.root !== root) {\n        edge.reload()\n      }\n    }\n    // reload all edgesOut where root doens't match, or is missing, since\n    // it might not be missing in the new tree\n    for (const edge of this.edgesOut.values()) {\n      if (!edge.to || edge.to.root !== root) {\n        edge.reload()\n      }\n    }\n\n    // now make sure our family comes along for the ride!\n    const family = new Set([\n      ...this.fsChildren,\n      ...this.children.values(),\n      ...this.inventory.values(),\n    ].filter(n => n !== this))\n\n    for (const child of family) {\n      if (child.root !== root) {\n        child[_delistFromMeta]()\n        child[_parent] = null\n        this.children.delete(child.name)\n        child[_fsParent] = null\n        this.fsChildren.delete(child)\n        for (const l of child.linksIn) {\n          l[_target] = null\n          child.linksIn.delete(l)\n        }\n      }\n    }\n    for (const child of family) {\n      if (child.root !== root) {\n        child.root = root\n      }\n    }\n\n    // if we had a target, and didn't find one in the new root, then bring\n    // it over as well, but only if we're setting the link into a new root,\n    // as we don't want to lose the target any time we remove a link.\n    if (this.isLink && target && !this.target && root !== this) {\n      target.root = root\n    }\n\n    // tree should always be valid upon root setter completion.\n    treeCheck(this)\n    treeCheck(root)\n  }\n\n  get root () {\n    return this[_root] || this\n  }\n\n  [_loadWorkspaces] () {\n    if (!this[_workspaces]) {\n      return\n    }\n\n    for (const [name, path] of this[_workspaces].entries()) {\n      new Edge({ from: this, name, spec: `file:${path}`, type: 'workspace' })\n    }\n  }\n\n  [_loadDeps] () {\n    // Caveat!  Order is relevant!\n    // Packages in optionalDependencies are optional.\n    // Packages in both deps and devDeps are required.\n    // Note the subtle breaking change from v6: it is no longer possible\n    // to have a different spec for a devDep than production dep.\n\n    // Linked targets that are disconnected from the tree are tops,\n    // but don't have a 'path' field, only a 'realpath', because we\n    // don't know their canonical location. We don't need their devDeps.\n    const pd = this.package.peerDependencies\n    if (pd && typeof pd === 'object' && !this.legacyPeerDeps) {\n      const pm = this.package.peerDependenciesMeta || {}\n      const peerDependencies = {}\n      const peerOptional = {}\n      for (const [name, dep] of Object.entries(pd)) {\n        if (pm[name] && pm[name].optional) {\n          peerOptional[name] = dep\n        } else {\n          peerDependencies[name] = dep\n        }\n      }\n      this[_loadDepType](peerDependencies, 'peer')\n      this[_loadDepType](peerOptional, 'peerOptional')\n    }\n\n    this[_loadDepType](this.package.dependencies, 'prod')\n    this[_loadDepType](this.package.optionalDependencies, 'optional')\n\n    const { globalTop, isTop, path, sourceReference } = this\n    const {\n      globalTop: srcGlobalTop,\n      isTop: srcTop,\n      path: srcPath,\n    } = sourceReference || {}\n    const thisDev = isTop && !globalTop && path\n    const srcDev = !sourceReference || srcTop && !srcGlobalTop && srcPath\n    if (thisDev && srcDev) {\n      this[_loadDepType](this.package.devDependencies, 'dev')\n    }\n  }\n\n  [_loadDepType] (deps, type) {\n    const ad = this.package.acceptDependencies || {}\n    // Because of the order in which _loadDeps runs, we always want to\n    // prioritize a new edge over an existing one\n    for (const [name, spec] of Object.entries(deps || {})) {\n      const current = this.edgesOut.get(name)\n      if (!current || current.type !== 'workspace') {\n        new Edge({ from: this, name, spec, accept: ad[name], type })\n      }\n    }\n  }\n\n  get fsParent () {\n    const parent = this[_fsParent]\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if (parent === this) {\n        throw new Error('node set to its own fsParent')\n      }\n    })\n    return parent\n  }\n\n  set fsParent (fsParent) {\n    if (!fsParent) {\n      if (this[_fsParent]) {\n        this.root = null\n      }\n      return\n    }\n\n    debug(() => {\n      if (fsParent === this) {\n        throw new Error('setting node to its own fsParent')\n      }\n\n      if (fsParent.realpath === this.realpath) {\n        throw new Error('setting fsParent to same path')\n      }\n\n      // the initial set MUST be an actual walk-up from the realpath\n      // subsequent sets will re-root on the new fsParent's path.\n      if (!this[_fsParent] && this.realpath.indexOf(fsParent.realpath) !== 0) {\n        throw Object.assign(new Error('setting fsParent improperly'), {\n          path: this.path,\n          realpath: this.realpath,\n          fsParent: {\n            path: fsParent.path,\n            realpath: fsParent.realpath,\n          },\n        })\n      }\n    })\n\n    if (fsParent.isLink) {\n      fsParent = fsParent.target\n    }\n\n    // setting a thing to its own fsParent is not normal, but no-op for safety\n    if (this === fsParent || fsParent.realpath === this.realpath) {\n      return\n    }\n\n    // nothing to do\n    if (this[_fsParent] === fsParent) {\n      return\n    }\n\n    const oldFsParent = this[_fsParent]\n    const newPath = !oldFsParent ? this.path\n      : resolve(fsParent.path, relative(oldFsParent.path, this.path))\n    const nmPath = resolve(fsParent.path, 'node_modules', this.name)\n\n    // this is actually the parent, set that instead\n    if (newPath === nmPath) {\n      this.parent = fsParent\n      return\n    }\n\n    const pathChange = newPath !== this.path\n\n    // remove from old parent/fsParent\n    const oldParent = this.parent\n    const oldName = this.name\n    if (this.parent) {\n      this.parent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    // update this.path/realpath for this and all children/fsChildren\n    if (pathChange) {\n      this[_changePath](newPath)\n    }\n\n    if (oldParent) {\n      oldParent[_reloadNamedEdges](oldName)\n    }\n\n    // clobbers anything at that path, resets all appropriate references\n    this.root = fsParent.root\n  }\n\n  // is it safe to replace one node with another?  check the edges to\n  // make sure no one will get upset.  Note that the node might end up\n  // having its own unmet dependencies, if the new node has new deps.\n  // Note that there are cases where Arborist will opt to insert a node\n  // into the tree even though this function returns false!  This is\n  // necessary when a root dependency is added or updated, or when a\n  // root dependency brings peer deps along with it.  In that case, we\n  // will go ahead and create the invalid state, and then try to resolve\n  // it with more tree construction, because it's a user request.\n  canReplaceWith (node, ignorePeers = []) {\n    if (node.name !== this.name) {\n      return false\n    }\n\n    if (node.packageName !== this.packageName) {\n      return false\n    }\n\n    ignorePeers = new Set(ignorePeers)\n\n    // gather up all the deps of this node and that are only depended\n    // upon by deps of this node.  those ones don't count, since\n    // they'll be replaced if this node is replaced anyway.\n    const depSet = gatherDepSet([this], e => e.to !== this && e.valid)\n\n    for (const edge of this.edgesIn) {\n      // when replacing peer sets, we need to be able to replace the entire\n      // peer group, which means we ignore incoming edges from other peers\n      // within the replacement set.\n      const ignored = !this.isTop &&\n        edge.from.parent === this.parent &&\n        edge.peer &&\n        ignorePeers.has(edge.from.name)\n      if (ignored) {\n        continue\n      }\n\n      // only care about edges that don't originate from this node\n      if (!depSet.has(edge.from) && !edge.satisfiedBy(node)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  canReplace (node, ignorePeers) {\n    return node.canReplaceWith(this, ignorePeers)\n  }\n\n  // return true if it's safe to remove this node, because anything that\n  // is depending on it would be fine with the thing that they would resolve\n  // to if it was removed, or nothing is depending on it in the first place.\n  canDedupe (preferDedupe = false) {\n    // not allowed to mess with shrinkwraps or bundles\n    if (this.inDepBundle || this.inShrinkwrap) {\n      return false\n    }\n\n    // it's a top level pkg, or a dep of one\n    if (!this.resolveParent || !this.resolveParent.resolveParent) {\n      return false\n    }\n\n    // no one wants it, remove it\n    if (this.edgesIn.size === 0) {\n      return true\n    }\n\n    const other = this.resolveParent.resolveParent.resolve(this.name)\n\n    // nothing else, need this one\n    if (!other) {\n      return false\n    }\n\n    // if it's the same thing, then always fine to remove\n    if (other.matches(this)) {\n      return true\n    }\n\n    // if the other thing can't replace this, then skip it\n    if (!other.canReplace(this)) {\n      return false\n    }\n\n    // if we prefer dedupe, or if the version is greater/equal, take the other\n    if (preferDedupe || semver.gte(other.version, this.version)) {\n      return true\n    }\n\n    return false\n  }\n\n  satisfies (requested) {\n    if (requested instanceof Edge) {\n      return this.name === requested.name && requested.satisfiedBy(this)\n    }\n\n    const parsed = npa(requested)\n    const { name = this.name, rawSpec: spec } = parsed\n    return this.name === name && this.satisfies(new Edge({\n      from: new Node({ path: this.root.realpath }),\n      type: 'prod',\n      name,\n      spec,\n    }))\n  }\n\n  matches (node) {\n    // if the nodes are literally the same object, obviously a match.\n    if (node === this) {\n      return true\n    }\n\n    // if the names don't match, they're different things, even if\n    // the package contents are identical.\n    if (node.name !== this.name) {\n      return false\n    }\n\n    // if they're links, they match if the targets match\n    if (this.isLink) {\n      return node.isLink && this.target.matches(node.target)\n    }\n\n    // if they're two project root nodes, they're different if the paths differ\n    if (this.isProjectRoot && node.isProjectRoot) {\n      return this.path === node.path\n    }\n\n    // if the integrity matches, then they're the same.\n    if (this.integrity && node.integrity) {\n      return this.integrity === node.integrity\n    }\n\n    // if no integrity, check resolved\n    if (this.resolved && node.resolved) {\n      return this.resolved === node.resolved\n    }\n\n    // if no resolved, check both package name and version\n    // otherwise, conclude that they are different things\n    return this.packageName && node.packageName &&\n      this.packageName === node.packageName &&\n      this.version && node.version &&\n      this.version === node.version\n  }\n\n  // replace this node with the supplied argument\n  // Useful when mutating an ideal tree, so we can avoid having to call\n  // the parent/root setters more than necessary.\n  replaceWith (node) {\n    node.replace(this)\n  }\n\n  replace (node) {\n    this[_delistFromMeta]()\n\n    // if the name matches, but is not identical, we are intending to clobber\n    // something case-insensitively, so merely setting name and path won't\n    // have the desired effect.  just set the path so it'll collide in the\n    // parent's children map, and leave it at that.\n    const nameMatch = node.parent &&\n      node.parent.children.get(this.name) === node\n    if (nameMatch) {\n      this.path = resolve(node.parent.path, 'node_modules', this.name)\n    } else {\n      this.path = node.path\n      this.name = node.name\n    }\n\n    if (!this.isLink) {\n      this.realpath = this.path\n    }\n    this[_refreshLocation]()\n\n    // keep children when a node replaces another\n    if (!this.isLink) {\n      for (const kid of node.children.values()) {\n        kid.parent = this\n      }\n    }\n\n    if (!node.isRoot) {\n      this.root = node.root\n    }\n\n    treeCheck(this)\n  }\n\n  get inShrinkwrap () {\n    return this.parent &&\n      (this.parent.hasShrinkwrap || this.parent.inShrinkwrap)\n  }\n\n  get parent () {\n    const parent = this[_parent]\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if (parent === this) {\n        throw new Error('node set to its own parent')\n      }\n    })\n    return parent\n  }\n\n  // This setter keeps everything in order when we move a node from\n  // one point in a logical tree to another.  Edges get reloaded,\n  // metadata updated, etc.  It's also called when we *replace* a node\n  // with another by the same name (eg, to update or dedupe).\n  // This does a couple of walks out on the node_modules tree, recursing\n  // into child nodes.  However, as setting the parent is typically done\n  // with nodes that don't have have many children, and (deduped) package\n  // trees tend to be broad rather than deep, it's not that bad.\n  // The only walk that starts from the parent rather than this node is\n  // limited by edge name.\n  set parent (parent) {\n    // when setting to null, just remove it from the tree entirely\n    if (!parent) {\n      // but only delete it if we actually had a parent in the first place\n      // otherwise it's just setting to null when it's already null\n      if (this[_parent]) {\n        this.root = null\n      }\n      return\n    }\n\n    if (parent.isLink) {\n      parent = parent.target\n    }\n\n    // setting a thing to its own parent is not normal, but no-op for safety\n    if (this === parent) {\n      return\n    }\n\n    const oldParent = this[_parent]\n\n    // nothing to do\n    if (oldParent === parent) {\n      return\n    }\n\n    // ok now we know something is actually changing, and parent is not a link\n    const newPath = resolve(parent.path, 'node_modules', this.name)\n    const pathChange = newPath !== this.path\n\n    // remove from old parent/fsParent\n    if (oldParent) {\n      oldParent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    // update this.path/realpath for this and all children/fsChildren\n    if (pathChange) {\n      this[_changePath](newPath)\n    }\n\n    // clobbers anything at that path, resets all appropriate references\n    this.root = parent.root\n  }\n\n  // Call this before changing path or updating the _root reference.\n  // Removes the node from its root the metadata and inventory.\n  [_delistFromMeta] () {\n    const root = this.root\n    if (!root.realpath || !this.path) {\n      return\n    }\n    root.inventory.delete(this)\n    root.tops.delete(this)\n    if (root.meta) {\n      root.meta.delete(this.path)\n    }\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if ([...root.inventory.values()].includes(this)) {\n        throw new Error('failed to delist')\n      }\n    })\n  }\n\n  // update this.path/realpath and the paths of all children/fsChildren\n  [_changePath] (newPath) {\n    // have to de-list before changing paths\n    this[_delistFromMeta]()\n    const oldPath = this.path\n    this.path = newPath\n    const namePattern = /(?:^|\\/|\\\\)node_modules[\\\\/](@[^/\\\\]+[\\\\/][^\\\\/]+|[^\\\\/]+)$/\n    const nameChange = newPath.match(namePattern)\n    if (nameChange && this.name !== nameChange[1]) {\n      this.name = nameChange[1].replace(/\\\\/g, '/')\n    }\n\n    // if we move a link target, update link realpaths\n    if (!this.isLink) {\n      this.realpath = newPath\n      for (const link of this.linksIn) {\n        link[_delistFromMeta]()\n        link.realpath = newPath\n        link[_refreshLocation]()\n      }\n    }\n    // if we move /x to /y, then a module at /x/a/b becomes /y/a/b\n    for (const child of this.fsChildren) {\n      child[_changePath](resolve(newPath, relative(oldPath, child.path)))\n    }\n    for (const [name, child] of this.children.entries()) {\n      child[_changePath](resolve(newPath, 'node_modules', name))\n    }\n\n    this[_refreshLocation]()\n  }\n\n  // Called whenever the root/parent is changed.\n  // NB: need to remove from former root's meta/inventory and then update\n  // this.path BEFORE calling this method!\n  [_refreshLocation] () {\n    const root = this.root\n    const loc = relpath(root.realpath, this.path)\n\n    this.location = loc\n\n    root.inventory.add(this)\n    if (root.meta) {\n      root.meta.add(this)\n    }\n  }\n\n  addEdgeOut (edge) {\n    this.edgesOut.set(edge.name, edge)\n  }\n\n  addEdgeIn (edge) {\n    this.edgesIn.add(edge)\n\n    // try to get metadata from the yarn.lock file\n    if (this.root.meta) {\n      this.root.meta.addEdge(edge)\n    }\n  }\n\n  [_reloadNamedEdges] (name, rootLoc = this.location) {\n    const edge = this.edgesOut.get(name)\n    // if we don't have an edge, do nothing, but keep descending\n    const rootLocResolved = edge && edge.to &&\n      edge.to.location === `${rootLoc}/node_modules/${edge.name}`\n    const sameResolved = edge && this.resolve(name) === edge.to\n    const recheck = rootLocResolved || !sameResolved\n    if (edge && recheck) {\n      edge.reload(true)\n    }\n    for (const c of this.children.values()) {\n      c[_reloadNamedEdges](name, rootLoc)\n    }\n\n    for (const c of this.fsChildren) {\n      c[_reloadNamedEdges](name, rootLoc)\n    }\n  }\n\n  get isLink () {\n    return false\n  }\n\n  get target () {\n    return this\n  }\n\n  set target (n) {\n    debug(() => {\n      throw Object.assign(new Error('cannot set target on non-Link Nodes'), {\n        path: this.path,\n      })\n    })\n  }\n\n  get depth () {\n    return this.isTop ? 0 : this.parent.depth + 1\n  }\n\n  get isTop () {\n    return !this.parent || this.globalTop\n  }\n\n  get top () {\n    return this.isTop ? this : this.parent.top\n  }\n\n  get isFsTop () {\n    return !this.fsParent\n  }\n\n  get fsTop () {\n    return this.isFsTop ? this : this.fsParent.fsTop\n  }\n\n  get resolveParent () {\n    return this.parent || this.fsParent\n  }\n\n  resolve (name) {\n    /* istanbul ignore next - should be impossible,\n     * but I keep doing this mistake in tests */\n    debug(() => {\n      if (typeof name !== 'string' || !name) {\n        throw new Error('non-string passed to Node.resolve')\n      }\n    })\n    const mine = this.children.get(name)\n    if (mine) {\n      return mine\n    }\n    const resolveParent = this.resolveParent\n    if (resolveParent) {\n      return resolveParent.resolve(name)\n    }\n    return null\n  }\n\n  inNodeModules () {\n    const rp = this.realpath\n    const name = this.name\n    const scoped = name.charAt(0) === '@'\n    const d = dirname(rp)\n    const nm = scoped ? dirname(d) : d\n    const dir = dirname(nm)\n    const base = scoped ? `${basename(d)}/${basename(rp)}` : basename(rp)\n    return base === name && basename(nm) === 'node_modules' ? dir : false\n  }\n\n  toJSON () {\n    return printableTree(this)\n  }\n\n  [util.inspect.custom] () {\n    return this.toJSON()\n  }\n}\n\nmodule.exports = Node\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}