{"ast":null,"code":"const Minipass = require('minipass');\nconst Pipeline = require('minipass-pipeline');\nconst libSearch = require('libnpmsearch');\nconst log = require('npmlog');\nconst formatPackageStream = require('./search/format-package-stream.js');\nconst packageFilter = require('./search/package-filter.js');\nfunction prepareIncludes(args) {\n  return args.map(s => s.toLowerCase()).filter(s => s);\n}\nfunction prepareExcludes(searchexclude) {\n  var exclude;\n  if (typeof searchexclude === 'string') exclude = searchexclude.split(/\\s+/);else exclude = [];\n  return exclude.map(s => s.toLowerCase()).filter(s => s);\n}\nconst BaseCommand = require('./base-command.js');\nclass Search extends BaseCommand {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description() {\n    return 'Search for packages';\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name() {\n    return 'search';\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params() {\n    return ['long', 'json', 'color', 'parseable', 'description', 'searchopts', 'searchexclude', 'registry', 'prefer-online', 'prefer-offline', 'offline'];\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage() {\n    return ['[search terms ...]'];\n  }\n  exec(args, cb) {\n    this.search(args).then(() => cb()).catch(cb);\n  }\n  async search(args) {\n    const opts = {\n      ...this.npm.flatOptions,\n      ...this.npm.flatOptions.search,\n      include: prepareIncludes(args),\n      exclude: prepareExcludes(this.npm.flatOptions.search.exclude)\n    };\n    if (opts.include.length === 0) throw new Error('search must be called with arguments');\n\n    // Used later to figure out whether we had any packages go out\n    let anyOutput = false;\n    class FilterStream extends Minipass {\n      write(pkg) {\n        if (packageFilter(pkg, opts.include, opts.exclude)) super.write(pkg);\n      }\n    }\n    const filterStream = new FilterStream();\n\n    // Grab a configured output stream that will spit out packages in the\n    // desired format.\n    const outputStream = formatPackageStream({\n      args,\n      // --searchinclude options are not highlighted\n      ...opts\n    });\n    log.silly('search', 'searching packages');\n    const p = new Pipeline(libSearch.stream(opts.include, opts), filterStream, outputStream);\n    p.on('data', chunk => {\n      if (!anyOutput) anyOutput = true;\n      this.npm.output(chunk.toString('utf8'));\n    });\n    await p.promise();\n    if (!anyOutput && !this.npm.config.get('json') && !this.npm.config.get('parseable')) this.npm.output('No matches found for ' + args.map(JSON.stringify).join(' '));\n    log.silly('search', 'search completed');\n    log.clearProgress();\n  }\n}\nmodule.exports = Search;","map":{"version":3,"names":["Minipass","require","Pipeline","libSearch","log","formatPackageStream","packageFilter","prepareIncludes","args","map","s","toLowerCase","filter","prepareExcludes","searchexclude","exclude","split","BaseCommand","Search","description","name","params","usage","exec","cb","search","then","catch","opts","npm","flatOptions","include","length","Error","anyOutput","FilterStream","write","pkg","filterStream","outputStream","silly","p","stream","on","chunk","output","toString","promise","config","get","JSON","stringify","join","clearProgress","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/lib/search.js"],"sourcesContent":["const Minipass = require('minipass')\nconst Pipeline = require('minipass-pipeline')\nconst libSearch = require('libnpmsearch')\nconst log = require('npmlog')\n\nconst formatPackageStream = require('./search/format-package-stream.js')\nconst packageFilter = require('./search/package-filter.js')\n\nfunction prepareIncludes (args) {\n  return args\n    .map(s => s.toLowerCase())\n    .filter(s => s)\n}\n\nfunction prepareExcludes (searchexclude) {\n  var exclude\n  if (typeof searchexclude === 'string')\n    exclude = searchexclude.split(/\\s+/)\n  else\n    exclude = []\n\n  return exclude\n    .map(s => s.toLowerCase())\n    .filter(s => s)\n}\n\nconst BaseCommand = require('./base-command.js')\nclass Search extends BaseCommand {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description () {\n    return 'Search for packages'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'search'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return [\n      'long',\n      'json',\n      'color',\n      'parseable',\n      'description',\n      'searchopts',\n      'searchexclude',\n      'registry',\n      'prefer-online',\n      'prefer-offline',\n      'offline',\n    ]\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return ['[search terms ...]']\n  }\n\n  exec (args, cb) {\n    this.search(args).then(() => cb()).catch(cb)\n  }\n\n  async search (args) {\n    const opts = {\n      ...this.npm.flatOptions,\n      ...this.npm.flatOptions.search,\n      include: prepareIncludes(args),\n      exclude: prepareExcludes(this.npm.flatOptions.search.exclude),\n    }\n\n    if (opts.include.length === 0)\n      throw new Error('search must be called with arguments')\n\n    // Used later to figure out whether we had any packages go out\n    let anyOutput = false\n\n    class FilterStream extends Minipass {\n      write (pkg) {\n        if (packageFilter(pkg, opts.include, opts.exclude))\n          super.write(pkg)\n      }\n    }\n\n    const filterStream = new FilterStream()\n\n    // Grab a configured output stream that will spit out packages in the\n    // desired format.\n    const outputStream = formatPackageStream({\n      args, // --searchinclude options are not highlighted\n      ...opts,\n    })\n\n    log.silly('search', 'searching packages')\n    const p = new Pipeline(\n      libSearch.stream(opts.include, opts),\n      filterStream,\n      outputStream\n    )\n\n    p.on('data', chunk => {\n      if (!anyOutput)\n        anyOutput = true\n      this.npm.output(chunk.toString('utf8'))\n    })\n\n    await p.promise()\n    if (!anyOutput && !this.npm.config.get('json') && !this.npm.config.get('parseable'))\n      this.npm.output('No matches found for ' + (args.map(JSON.stringify).join(' ')))\n\n    log.silly('search', 'search completed')\n    log.clearProgress()\n  }\n}\nmodule.exports = Search\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}