{"ast":null,"code":"const Fetcher = require('./fetcher.js');\nconst RemoteFetcher = require('./remote.js');\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\nconst pacoteVersion = require('../package.json').version;\nconst npa = require('npm-package-arg');\nconst rpj = require('read-package-json-fast');\nconst pickManifest = require('npm-pick-manifest');\nconst ssri = require('ssri');\nconst Minipass = require('minipass');\n\n// Corgis are cute. üêïüê∂\nconst corgiDoc = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*';\nconst fullDoc = 'application/json';\nconst fetch = require('npm-registry-fetch');\n\n// TODO: memoize reg requests, so we don't even have to check cache\n\nconst _headers = Symbol('_headers');\nclass RegistryFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts);\n\n    // you usually don't want to fetch the same packument multiple times in\n    // the span of a given script or command, no matter how many pacote calls\n    // are made, so this lets us avoid doing that.  It's only relevant for\n    // registry fetchers, because other types simulate their packument from\n    // the manifest, which they memoize on this.package, so it's very cheap\n    // already.\n    this.packumentCache = this.opts.packumentCache || null;\n\n    // handle case when npm-package-arg guesses wrong.\n    if (this.spec.type === 'tag' && this.spec.rawSpec === '' && this.defaultTag !== 'latest') this.spec = npa(`${this.spec.name}@${this.defaultTag}`);\n    this.registry = fetch.pickRegistry(spec, opts);\n    this.packumentUrl = this.registry.replace(/\\/*$/, '/') + this.spec.escapedName;\n\n    // XXX pacote <=9 has some logic to ignore opts.resolved if\n    // the resolved URL doesn't go to the same registry.\n    // Consider reproducing that here, to throw away this.resolved\n    // in that case.\n  }\n  resolve() {\n    if (this.resolved) return Promise.resolve(this.resolved);\n\n    // fetching the manifest sets resolved and (usually) integrity\n    return this.manifest().then(() => {\n      if (this.resolved) return this.resolved;\n      throw Object.assign(new Error('Invalid package manifest: no `dist.tarball` field'), {\n        package: this.spec.toString()\n      });\n    });\n  }\n  [_headers]() {\n    return {\n      // npm will override UA, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent || `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'packument',\n      'pacote-pkg-id': `registry:${this.spec.name}`,\n      accept: this.fullMetadata ? fullDoc : corgiDoc\n    };\n  }\n  async packument() {\n    // note this might be either an in-flight promise for a request,\n    // or the actual packument, but we never want to make more than\n    // one request at a time for the same thing regardless.\n    if (this.packumentCache && this.packumentCache.has(this.packumentUrl)) return this.packumentCache.get(this.packumentUrl);\n\n    // npm-registry-fetch the packument\n    // set the appropriate header for corgis if fullMetadata isn't set\n    // return the res.json() promise\n    const p = fetch(this.packumentUrl, {\n      ...this.opts,\n      headers: this[_headers](),\n      spec: this.spec,\n      // never check integrity for packuments themselves\n      integrity: null\n    }).then(res => res.json().then(packument => {\n      packument._cached = res.headers.has('x-local-cache');\n      packument._contentLength = +res.headers.get('content-length');\n      if (this.packumentCache) this.packumentCache.set(this.packumentUrl, packument);\n      return packument;\n    })).catch(er => {\n      if (this.packumentCache) this.packumentCache.delete(this.packumentUrl);\n      if (er.code === 'E404' && !this.fullMetadata) {\n        // possible that corgis are not supported by this registry\n        this.fullMetadata = true;\n        return this.packument();\n      }\n      throw er;\n    });\n    if (this.packumentCache) this.packumentCache.set(this.packumentUrl, p);\n    return p;\n  }\n  manifest() {\n    if (this.package) return Promise.resolve(this.package);\n    return this.packument().then(packument => pickManifest(packument, this.spec.fetchSpec, {\n      ...this.opts,\n      defaultTag: this.defaultTag,\n      before: this.before\n    }) /* XXX add ETARGET and E403 revalidation of cached packuments here */).then(mani => {\n      // add _resolved and _integrity from dist object\n      const {\n        dist\n      } = mani;\n      if (dist) {\n        this.resolved = mani._resolved = dist.tarball;\n        mani._from = this.from;\n        const distIntegrity = dist.integrity ? ssri.parse(dist.integrity) : dist.shasum ? ssri.fromHex(dist.shasum, 'sha1', {\n          ...this.opts\n        }) : null;\n        if (distIntegrity) {\n          if (!this.integrity) this.integrity = distIntegrity;else if (!this.integrity.match(distIntegrity)) {\n            // only bork if they have algos in common.\n            // otherwise we end up breaking if we have saved a sha512\n            // previously for the tarball, but the manifest only\n            // provides a sha1, which is possible for older publishes.\n            // Otherwise, this is almost certainly a case of holding it\n            // wrong, and will result in weird or insecure behavior\n            // later on when building package tree.\n            for (const algo of Object.keys(this.integrity)) {\n              if (distIntegrity[algo]) {\n                throw Object.assign(new Error(`Integrity checksum failed when using ${algo}: ` + `wanted ${this.integrity} but got ${distIntegrity}.`), {\n                  code: 'EINTEGRITY'\n                });\n              }\n            }\n            // made it this far, the integrity is worthwhile.  accept it.\n            // the setter here will take care of merging it into what we\n            // already had.\n            this.integrity = distIntegrity;\n          }\n        }\n      }\n      if (this.integrity) mani._integrity = String(this.integrity);\n      this.package = rpj.normalize(mani);\n      return this.package;\n    });\n  }\n  [_tarballFromResolved]() {\n    // we use a RemoteFetcher to get the actual tarball stream\n    return new RemoteFetcher(this.resolved, {\n      ...this.opts,\n      resolved: this.resolved,\n      pkgid: `registry:${this.spec.name}@${this.resolved}`\n    })[_tarballFromResolved]();\n  }\n  get types() {\n    return ['tag', 'version', 'range'];\n  }\n}\nmodule.exports = RegistryFetcher;","map":{"version":3,"names":["Fetcher","require","RemoteFetcher","_tarballFromResolved","Symbol","for","pacoteVersion","version","npa","rpj","pickManifest","ssri","Minipass","corgiDoc","fullDoc","fetch","_headers","RegistryFetcher","constructor","spec","opts","packumentCache","type","rawSpec","defaultTag","name","registry","pickRegistry","packumentUrl","replace","escapedName","resolve","resolved","Promise","manifest","then","Object","assign","Error","package","toString","userAgent","process","headers","accept","fullMetadata","packument","has","get","p","integrity","res","json","_cached","_contentLength","set","catch","er","delete","code","fetchSpec","before","mani","dist","_resolved","tarball","_from","from","distIntegrity","parse","shasum","fromHex","match","algo","keys","_integrity","String","normalize","pkgid","types","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/pacote/lib/registry.js"],"sourcesContent":["const Fetcher = require('./fetcher.js')\nconst RemoteFetcher = require('./remote.js')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst pacoteVersion = require('../package.json').version\nconst npa = require('npm-package-arg')\nconst rpj = require('read-package-json-fast')\nconst pickManifest = require('npm-pick-manifest')\nconst ssri = require('ssri')\nconst Minipass = require('minipass')\n\n// Corgis are cute. üêïüê∂\nconst corgiDoc = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*'\nconst fullDoc = 'application/json'\n\nconst fetch = require('npm-registry-fetch')\n\n// TODO: memoize reg requests, so we don't even have to check cache\n\nconst _headers = Symbol('_headers')\nclass RegistryFetcher extends Fetcher {\n  constructor (spec, opts) {\n    super(spec, opts)\n\n    // you usually don't want to fetch the same packument multiple times in\n    // the span of a given script or command, no matter how many pacote calls\n    // are made, so this lets us avoid doing that.  It's only relevant for\n    // registry fetchers, because other types simulate their packument from\n    // the manifest, which they memoize on this.package, so it's very cheap\n    // already.\n    this.packumentCache = this.opts.packumentCache || null\n\n    // handle case when npm-package-arg guesses wrong.\n    if (this.spec.type === 'tag' &&\n        this.spec.rawSpec === '' &&\n        this.defaultTag !== 'latest')\n      this.spec = npa(`${this.spec.name}@${this.defaultTag}`)\n    this.registry = fetch.pickRegistry(spec, opts)\n    this.packumentUrl = this.registry.replace(/\\/*$/, '/') +\n      this.spec.escapedName\n\n    // XXX pacote <=9 has some logic to ignore opts.resolved if\n    // the resolved URL doesn't go to the same registry.\n    // Consider reproducing that here, to throw away this.resolved\n    // in that case.\n  }\n\n  resolve () {\n    if (this.resolved)\n      return Promise.resolve(this.resolved)\n\n    // fetching the manifest sets resolved and (usually) integrity\n    return this.manifest().then(() => {\n      if (this.resolved)\n        return this.resolved\n\n      throw Object.assign(\n        new Error('Invalid package manifest: no `dist.tarball` field'),\n        { package: this.spec.toString() }\n      )\n    })\n  }\n\n  [_headers] () {\n    return {\n      // npm will override UA, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent ||\n        `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'packument',\n      'pacote-pkg-id': `registry:${this.spec.name}`,\n      accept: this.fullMetadata ? fullDoc : corgiDoc,\n    }\n  }\n\n  async packument () {\n    // note this might be either an in-flight promise for a request,\n    // or the actual packument, but we never want to make more than\n    // one request at a time for the same thing regardless.\n    if (this.packumentCache && this.packumentCache.has(this.packumentUrl))\n      return this.packumentCache.get(this.packumentUrl)\n\n    // npm-registry-fetch the packument\n    // set the appropriate header for corgis if fullMetadata isn't set\n    // return the res.json() promise\n    const p = fetch(this.packumentUrl, {\n      ...this.opts,\n      headers: this[_headers](),\n      spec: this.spec,\n      // never check integrity for packuments themselves\n      integrity: null,\n    }).then(res => res.json().then(packument => {\n      packument._cached = res.headers.has('x-local-cache')\n      packument._contentLength = +res.headers.get('content-length')\n      if (this.packumentCache)\n        this.packumentCache.set(this.packumentUrl, packument)\n      return packument\n    })).catch(er => {\n      if (this.packumentCache)\n        this.packumentCache.delete(this.packumentUrl)\n      if (er.code === 'E404' && !this.fullMetadata) {\n        // possible that corgis are not supported by this registry\n        this.fullMetadata = true\n        return this.packument()\n      }\n      throw er\n    })\n    if (this.packumentCache)\n      this.packumentCache.set(this.packumentUrl, p)\n    return p\n  }\n\n  manifest () {\n    if (this.package)\n      return Promise.resolve(this.package)\n\n    return this.packument()\n      .then(packument => pickManifest(packument, this.spec.fetchSpec, {\n        ...this.opts,\n        defaultTag: this.defaultTag,\n        before: this.before,\n      }) /* XXX add ETARGET and E403 revalidation of cached packuments here */)\n      .then(mani => {\n        // add _resolved and _integrity from dist object\n        const { dist } = mani\n        if (dist) {\n          this.resolved = mani._resolved = dist.tarball\n          mani._from = this.from\n          const distIntegrity = dist.integrity ? ssri.parse(dist.integrity)\n            : dist.shasum ? ssri.fromHex(dist.shasum, 'sha1', {...this.opts})\n            : null\n          if (distIntegrity) {\n            if (!this.integrity)\n              this.integrity = distIntegrity\n            else if (!this.integrity.match(distIntegrity)) {\n              // only bork if they have algos in common.\n              // otherwise we end up breaking if we have saved a sha512\n              // previously for the tarball, but the manifest only\n              // provides a sha1, which is possible for older publishes.\n              // Otherwise, this is almost certainly a case of holding it\n              // wrong, and will result in weird or insecure behavior\n              // later on when building package tree.\n              for (const algo of Object.keys(this.integrity)) {\n                if (distIntegrity[algo]) {\n                  throw Object.assign(new Error(\n                    `Integrity checksum failed when using ${algo}: `+\n                    `wanted ${this.integrity} but got ${distIntegrity}.`\n                  ), { code: 'EINTEGRITY' })\n                }\n              }\n              // made it this far, the integrity is worthwhile.  accept it.\n              // the setter here will take care of merging it into what we\n              // already had.\n              this.integrity = distIntegrity\n            }\n          }\n        }\n        if (this.integrity)\n          mani._integrity = String(this.integrity)\n        this.package = rpj.normalize(mani)\n        return this.package\n      })\n  }\n\n  [_tarballFromResolved] () {\n    // we use a RemoteFetcher to get the actual tarball stream\n    return new RemoteFetcher(this.resolved, {\n      ...this.opts,\n      resolved: this.resolved,\n      pkgid: `registry:${this.spec.name}@${this.resolved}`,\n    })[_tarballFromResolved]()\n  }\n\n  get types () {\n    return [\n      'tag',\n      'version',\n      'range',\n    ]\n  }\n}\nmodule.exports = RegistryFetcher\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}