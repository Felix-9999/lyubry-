{"ast":null,"code":"// mixin providing the loadVirtual method\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\nconst {\n  resolve\n} = require('path');\nconst nameFromFolder = require('@npmcli/name-from-folder');\nconst consistentResolve = require('../consistent-resolve.js');\nconst Shrinkwrap = require('../shrinkwrap.js');\nconst Node = require('../node.js');\nconst Link = require('../link.js');\nconst relpath = require('../relpath.js');\nconst calcDepFlags = require('../calc-dep-flags.js');\nconst rpj = require('read-package-json-fast');\nconst treeCheck = require('../tree-check.js');\nconst loadFromShrinkwrap = Symbol('loadFromShrinkwrap');\nconst resolveNodes = Symbol('resolveNodes');\nconst resolveLinks = Symbol('resolveLinks');\nconst assignBundles = Symbol('assignBundles');\nconst loadRoot = Symbol('loadRoot');\nconst loadNode = Symbol('loadVirtualNode');\nconst loadLink = Symbol('loadVirtualLink');\nconst loadWorkspaces = Symbol.for('loadWorkspaces');\nconst loadWorkspacesVirtual = Symbol.for('loadWorkspacesVirtual');\nconst flagsSuspect = Symbol.for('flagsSuspect');\nconst reCalcDepFlags = Symbol('reCalcDepFlags');\nconst checkRootEdges = Symbol('checkRootEdges');\nconst rootOptionProvided = Symbol('rootOptionProvided');\nconst depsToEdges = (type, deps) => Object.entries(deps).map(d => [type, ...d]);\nmodule.exports = cls => class VirtualLoader extends cls {\n  constructor(options) {\n    super(options);\n\n    // the virtual tree we load from a shrinkwrap\n    this.virtualTree = options.virtualTree;\n    this[flagsSuspect] = false;\n  }\n\n  // public method\n  async loadVirtual(options = {}) {\n    if (this.virtualTree) {\n      return this.virtualTree;\n    }\n\n    // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n    options = {\n      ...this.options,\n      ...options\n    };\n    if (options.root && options.root.meta) {\n      await this[loadFromShrinkwrap](options.root.meta, options.root);\n      return treeCheck(this.virtualTree);\n    }\n    const s = await Shrinkwrap.load({\n      path: this.path\n    });\n    if (!s.loadedFromDisk && !options.root) {\n      const er = new Error('loadVirtual requires existing shrinkwrap file');\n      throw Object.assign(er, {\n        code: 'ENOLOCK'\n      });\n    }\n\n    // when building the ideal tree, we pass in a root node to this function\n    // otherwise, load it from the root package json or the lockfile\n    const {\n      root = await this[loadRoot](s)\n    } = options;\n    this[rootOptionProvided] = options.root;\n    await this[loadFromShrinkwrap](s, root);\n    return treeCheck(this.virtualTree);\n  }\n  async [loadRoot](s) {\n    const pj = this.path + '/package.json';\n    const pkg = (await rpj(pj).catch(() => s.data.packages[''])) || {};\n    return this[loadWorkspaces](this[loadNode]('', pkg));\n  }\n  async [loadFromShrinkwrap](s, root) {\n    if (!this[rootOptionProvided]) {\n      // root is never any of these things, but might be a brand new\n      // baby Node object that never had its dep flags calculated.\n      root.extraneous = false;\n      root.dev = false;\n      root.optional = false;\n      root.devOptional = false;\n      root.peer = false;\n    } else {\n      this[flagsSuspect] = true;\n    }\n    this[checkRootEdges](s, root);\n    root.meta = s;\n    this.virtualTree = root;\n    const {\n      links,\n      nodes\n    } = this[resolveNodes](s, root);\n    await this[resolveLinks](links, nodes);\n    if (!(s.originalLockfileVersion >= 2)) {\n      this[assignBundles](nodes);\n    }\n    if (this[flagsSuspect]) {\n      this[reCalcDepFlags](nodes.values());\n    }\n    return root;\n  }\n  [reCalcDepFlags](nodes) {\n    // reset all dep flags\n    // can't use inventory here, because virtualTree might not be root\n    for (const node of nodes) {\n      if (node.isRoot || node === this[rootOptionProvided]) {\n        continue;\n      }\n      node.extraneous = true;\n      node.dev = true;\n      node.optional = true;\n      node.devOptional = true;\n      node.peer = true;\n    }\n    calcDepFlags(this.virtualTree, !this[rootOptionProvided]);\n  }\n\n  // check the lockfile deps, and see if they match.  if they do not\n  // then we have to reset dep flags at the end.  for example, if the\n  // user manually edits their package.json file, then we need to know\n  // that the idealTree is no longer entirely trustworthy.\n  [checkRootEdges](s, root) {\n    // loaded virtually from tree, no chance of being out of sync\n    // ancient lockfiles are critically damaged by this process,\n    // so we need to just hope for the best in those cases.\n    if (!s.loadedFromDisk || s.ancientLockfile) {\n      return;\n    }\n    const lock = s.get('');\n    const prod = lock.dependencies || {};\n    const dev = lock.devDependencies || {};\n    const optional = lock.optionalDependencies || {};\n    const peer = lock.peerDependencies || {};\n    const peerOptional = {};\n    if (lock.peerDependenciesMeta) {\n      for (const [name, meta] of Object.entries(lock.peerDependenciesMeta)) {\n        if (meta.optional && peer[name] !== undefined) {\n          peerOptional[name] = peer[name];\n          delete peer[name];\n        }\n      }\n    }\n    for (const name of Object.keys(optional)) {\n      delete prod[name];\n    }\n    const lockWS = [];\n    const workspaces = this[loadWorkspacesVirtual]({\n      cwd: this.path,\n      lockfile: s.data\n    });\n    for (const [name, path] of workspaces.entries()) {\n      lockWS.push(['workspace', name, `file:${path}`]);\n    }\n    const lockEdges = [...depsToEdges('prod', prod), ...depsToEdges('dev', dev), ...depsToEdges('optional', optional), ...depsToEdges('peer', peer), ...depsToEdges('peerOptional', peerOptional), ...lockWS].sort(([atype, aname], [btype, bname]) => localeCompare(atype, btype) || localeCompare(aname, bname));\n    const rootEdges = [...root.edgesOut.values()].map(e => [e.type, e.name, e.spec]).sort(([atype, aname], [btype, bname]) => localeCompare(atype, btype) || localeCompare(aname, bname));\n    if (rootEdges.length !== lockEdges.length) {\n      // something added or removed\n      return this[flagsSuspect] = true;\n    }\n    for (let i = 0; i < lockEdges.length; i++) {\n      if (rootEdges[i][0] !== lockEdges[i][0] || rootEdges[i][1] !== lockEdges[i][1] || rootEdges[i][2] !== lockEdges[i][2]) {\n        return this[flagsSuspect] = true;\n      }\n    }\n  }\n\n  // separate out link metadatas, and create Node objects for nodes\n  [resolveNodes](s, root) {\n    const links = new Map();\n    const nodes = new Map([['', root]]);\n    for (const [location, meta] of Object.entries(s.data.packages)) {\n      // skip the root because we already got it\n      if (!location) {\n        continue;\n      }\n      if (meta.link) {\n        links.set(location, meta);\n      } else {\n        nodes.set(location, this[loadNode](location, meta));\n      }\n    }\n    return {\n      links,\n      nodes\n    };\n  }\n\n  // links is the set of metadata, and nodes is the map of non-Link nodes\n  // Set the targets to nodes in the set, if we have them (we might not)\n  async [resolveLinks](links, nodes) {\n    for (const [location, meta] of links.entries()) {\n      const targetPath = resolve(this.path, meta.resolved);\n      const targetLoc = relpath(this.path, targetPath);\n      const target = nodes.get(targetLoc);\n      const link = this[loadLink](location, targetLoc, target, meta);\n      nodes.set(location, link);\n      nodes.set(targetLoc, link.target);\n\n      // we always need to read the package.json for link targets\n      // outside node_modules because they can be changed by the local user\n      if (!link.target.parent) {\n        const pj = link.realpath + '/package.json';\n        const pkg = await rpj(pj).catch(() => null);\n        if (pkg) {\n          link.target.package = pkg;\n        }\n      }\n    }\n  }\n  [assignBundles](nodes) {\n    for (const [location, node] of nodes) {\n      // Skip assignment of parentage for the root package\n      if (!location || node.isLink && !node.target.location) {\n        continue;\n      }\n      const {\n        name,\n        parent,\n        package: {\n          inBundle\n        }\n      } = node;\n      if (!parent) {\n        continue;\n      }\n\n      // read inBundle from package because 'package' here is\n      // actually a v2 lockfile metadata entry.\n      // If the *parent* is also bundled, though, or if the parent has\n      // no dependency on it, then we assume that it's being pulled in\n      // just by virtue of its parent or a transitive dep being bundled.\n      const {\n        package: ppkg\n      } = parent;\n      const {\n        inBundle: parentBundled\n      } = ppkg;\n      if (inBundle && !parentBundled && parent.edgesOut.has(node.name)) {\n        if (!ppkg.bundleDependencies) {\n          ppkg.bundleDependencies = [name];\n        } else {\n          ppkg.bundleDependencies.push(name);\n        }\n      }\n    }\n  }\n  [loadNode](location, sw) {\n    const p = this.virtualTree ? this.virtualTree.realpath : this.path;\n    const path = resolve(p, location);\n    // shrinkwrap doesn't include package name unless necessary\n    if (!sw.name) {\n      sw.name = nameFromFolder(path);\n    }\n    const dev = sw.dev;\n    const optional = sw.optional;\n    const devOptional = dev || optional || sw.devOptional;\n    const peer = sw.peer;\n    const node = new Node({\n      legacyPeerDeps: this.legacyPeerDeps,\n      root: this.virtualTree,\n      path,\n      realpath: path,\n      integrity: sw.integrity,\n      resolved: consistentResolve(sw.resolved, this.path, path),\n      pkg: sw,\n      hasShrinkwrap: sw.hasShrinkwrap,\n      dev,\n      optional,\n      devOptional,\n      peer\n    });\n    // cast to boolean because they're undefined in the lock file when false\n    node.extraneous = !!sw.extraneous;\n    node.devOptional = !!(sw.devOptional || sw.dev || sw.optional);\n    node.peer = !!sw.peer;\n    node.optional = !!sw.optional;\n    node.dev = !!sw.dev;\n    return node;\n  }\n  [loadLink](location, targetLoc, target, meta) {\n    const path = resolve(this.path, location);\n    const link = new Link({\n      legacyPeerDeps: this.legacyPeerDeps,\n      path,\n      realpath: resolve(this.path, targetLoc),\n      target,\n      pkg: target && target.package\n    });\n    link.extraneous = target.extraneous;\n    link.devOptional = target.devOptional;\n    link.peer = target.peer;\n    link.optional = target.optional;\n    link.dev = target.dev;\n    return link;\n  }\n};","map":{"version":3,"names":["localeCompare","require","resolve","nameFromFolder","consistentResolve","Shrinkwrap","Node","Link","relpath","calcDepFlags","rpj","treeCheck","loadFromShrinkwrap","Symbol","resolveNodes","resolveLinks","assignBundles","loadRoot","loadNode","loadLink","loadWorkspaces","for","loadWorkspacesVirtual","flagsSuspect","reCalcDepFlags","checkRootEdges","rootOptionProvided","depsToEdges","type","deps","Object","entries","map","d","module","exports","cls","VirtualLoader","constructor","options","virtualTree","loadVirtual","root","meta","s","load","path","loadedFromDisk","er","Error","assign","code","pj","pkg","catch","data","packages","extraneous","dev","optional","devOptional","peer","links","nodes","originalLockfileVersion","values","node","isRoot","ancientLockfile","lock","get","prod","dependencies","devDependencies","optionalDependencies","peerDependencies","peerOptional","peerDependenciesMeta","name","undefined","keys","lockWS","workspaces","cwd","lockfile","push","lockEdges","sort","atype","aname","btype","bname","rootEdges","edgesOut","e","spec","length","i","Map","location","link","set","targetPath","resolved","targetLoc","target","parent","realpath","package","isLink","inBundle","ppkg","parentBundled","has","bundleDependencies","sw","p","legacyPeerDeps","integrity","hasShrinkwrap"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/load-virtual.js"],"sourcesContent":["// mixin providing the loadVirtual method\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\n\nconst {resolve} = require('path')\n\nconst nameFromFolder = require('@npmcli/name-from-folder')\nconst consistentResolve = require('../consistent-resolve.js')\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst relpath = require('../relpath.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst rpj = require('read-package-json-fast')\nconst treeCheck = require('../tree-check.js')\n\nconst loadFromShrinkwrap = Symbol('loadFromShrinkwrap')\nconst resolveNodes = Symbol('resolveNodes')\nconst resolveLinks = Symbol('resolveLinks')\nconst assignBundles = Symbol('assignBundles')\nconst loadRoot = Symbol('loadRoot')\nconst loadNode = Symbol('loadVirtualNode')\nconst loadLink = Symbol('loadVirtualLink')\nconst loadWorkspaces = Symbol.for('loadWorkspaces')\nconst loadWorkspacesVirtual = Symbol.for('loadWorkspacesVirtual')\nconst flagsSuspect = Symbol.for('flagsSuspect')\nconst reCalcDepFlags = Symbol('reCalcDepFlags')\nconst checkRootEdges = Symbol('checkRootEdges')\nconst rootOptionProvided = Symbol('rootOptionProvided')\n\nconst depsToEdges = (type, deps) =>\n  Object.entries(deps).map(d => [type, ...d])\n\nmodule.exports = cls => class VirtualLoader extends cls {\n  constructor (options) {\n    super(options)\n\n    // the virtual tree we load from a shrinkwrap\n    this.virtualTree = options.virtualTree\n    this[flagsSuspect] = false\n  }\n\n  // public method\n  async loadVirtual (options = {}) {\n    if (this.virtualTree) {\n      return this.virtualTree\n    }\n\n    // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n    options = { ...this.options, ...options }\n\n    if (options.root && options.root.meta) {\n      await this[loadFromShrinkwrap](options.root.meta, options.root)\n      return treeCheck(this.virtualTree)\n    }\n\n    const s = await Shrinkwrap.load({ path: this.path })\n    if (!s.loadedFromDisk && !options.root) {\n      const er = new Error('loadVirtual requires existing shrinkwrap file')\n      throw Object.assign(er, { code: 'ENOLOCK' })\n    }\n\n    // when building the ideal tree, we pass in a root node to this function\n    // otherwise, load it from the root package json or the lockfile\n    const {\n      root = await this[loadRoot](s),\n    } = options\n\n    this[rootOptionProvided] = options.root\n\n    await this[loadFromShrinkwrap](s, root)\n    return treeCheck(this.virtualTree)\n  }\n\n  async [loadRoot] (s) {\n    const pj = this.path + '/package.json'\n    const pkg = await rpj(pj).catch(() => s.data.packages['']) || {}\n    return this[loadWorkspaces](this[loadNode]('', pkg))\n  }\n\n  async [loadFromShrinkwrap] (s, root) {\n    if (!this[rootOptionProvided]) {\n      // root is never any of these things, but might be a brand new\n      // baby Node object that never had its dep flags calculated.\n      root.extraneous = false\n      root.dev = false\n      root.optional = false\n      root.devOptional = false\n      root.peer = false\n    } else {\n      this[flagsSuspect] = true\n    }\n\n    this[checkRootEdges](s, root)\n    root.meta = s\n    this.virtualTree = root\n    const {links, nodes} = this[resolveNodes](s, root)\n    await this[resolveLinks](links, nodes)\n    if (!(s.originalLockfileVersion >= 2)) {\n      this[assignBundles](nodes)\n    }\n    if (this[flagsSuspect]) {\n      this[reCalcDepFlags](nodes.values())\n    }\n    return root\n  }\n\n  [reCalcDepFlags] (nodes) {\n    // reset all dep flags\n    // can't use inventory here, because virtualTree might not be root\n    for (const node of nodes) {\n      if (node.isRoot || node === this[rootOptionProvided]) {\n        continue\n      }\n      node.extraneous = true\n      node.dev = true\n      node.optional = true\n      node.devOptional = true\n      node.peer = true\n    }\n    calcDepFlags(this.virtualTree, !this[rootOptionProvided])\n  }\n\n  // check the lockfile deps, and see if they match.  if they do not\n  // then we have to reset dep flags at the end.  for example, if the\n  // user manually edits their package.json file, then we need to know\n  // that the idealTree is no longer entirely trustworthy.\n  [checkRootEdges] (s, root) {\n    // loaded virtually from tree, no chance of being out of sync\n    // ancient lockfiles are critically damaged by this process,\n    // so we need to just hope for the best in those cases.\n    if (!s.loadedFromDisk || s.ancientLockfile) {\n      return\n    }\n\n    const lock = s.get('')\n    const prod = lock.dependencies || {}\n    const dev = lock.devDependencies || {}\n    const optional = lock.optionalDependencies || {}\n    const peer = lock.peerDependencies || {}\n    const peerOptional = {}\n    if (lock.peerDependenciesMeta) {\n      for (const [name, meta] of Object.entries(lock.peerDependenciesMeta)) {\n        if (meta.optional && peer[name] !== undefined) {\n          peerOptional[name] = peer[name]\n          delete peer[name]\n        }\n      }\n    }\n    for (const name of Object.keys(optional)) {\n      delete prod[name]\n    }\n\n    const lockWS = []\n    const workspaces = this[loadWorkspacesVirtual]({\n      cwd: this.path,\n      lockfile: s.data,\n    })\n    for (const [name, path] of workspaces.entries()) {\n      lockWS.push(['workspace', name, `file:${path}`])\n    }\n\n    const lockEdges = [\n      ...depsToEdges('prod', prod),\n      ...depsToEdges('dev', dev),\n      ...depsToEdges('optional', optional),\n      ...depsToEdges('peer', peer),\n      ...depsToEdges('peerOptional', peerOptional),\n      ...lockWS,\n    ].sort(([atype, aname], [btype, bname]) =>\n      localeCompare(atype, btype) || localeCompare(aname, bname))\n\n    const rootEdges = [...root.edgesOut.values()]\n      .map(e => [e.type, e.name, e.spec])\n      .sort(([atype, aname], [btype, bname]) =>\n        localeCompare(atype, btype) || localeCompare(aname, bname))\n\n    if (rootEdges.length !== lockEdges.length) {\n      // something added or removed\n      return this[flagsSuspect] = true\n    }\n\n    for (let i = 0; i < lockEdges.length; i++) {\n      if (rootEdges[i][0] !== lockEdges[i][0] ||\n          rootEdges[i][1] !== lockEdges[i][1] ||\n          rootEdges[i][2] !== lockEdges[i][2]) {\n        return this[flagsSuspect] = true\n      }\n    }\n  }\n\n  // separate out link metadatas, and create Node objects for nodes\n  [resolveNodes] (s, root) {\n    const links = new Map()\n    const nodes = new Map([['', root]])\n    for (const [location, meta] of Object.entries(s.data.packages)) {\n      // skip the root because we already got it\n      if (!location) {\n        continue\n      }\n\n      if (meta.link) {\n        links.set(location, meta)\n      } else {\n        nodes.set(location, this[loadNode](location, meta))\n      }\n    }\n    return {links, nodes}\n  }\n\n  // links is the set of metadata, and nodes is the map of non-Link nodes\n  // Set the targets to nodes in the set, if we have them (we might not)\n  async [resolveLinks] (links, nodes) {\n    for (const [location, meta] of links.entries()) {\n      const targetPath = resolve(this.path, meta.resolved)\n      const targetLoc = relpath(this.path, targetPath)\n      const target = nodes.get(targetLoc)\n      const link = this[loadLink](location, targetLoc, target, meta)\n      nodes.set(location, link)\n      nodes.set(targetLoc, link.target)\n\n      // we always need to read the package.json for link targets\n      // outside node_modules because they can be changed by the local user\n      if (!link.target.parent) {\n        const pj = link.realpath + '/package.json'\n        const pkg = await rpj(pj).catch(() => null)\n        if (pkg) {\n          link.target.package = pkg\n        }\n      }\n    }\n  }\n\n  [assignBundles] (nodes) {\n    for (const [location, node] of nodes) {\n      // Skip assignment of parentage for the root package\n      if (!location || node.isLink && !node.target.location) {\n        continue\n      }\n      const { name, parent, package: { inBundle }} = node\n\n      if (!parent) {\n        continue\n      }\n\n      // read inBundle from package because 'package' here is\n      // actually a v2 lockfile metadata entry.\n      // If the *parent* is also bundled, though, or if the parent has\n      // no dependency on it, then we assume that it's being pulled in\n      // just by virtue of its parent or a transitive dep being bundled.\n      const { package: ppkg } = parent\n      const { inBundle: parentBundled } = ppkg\n      if (inBundle && !parentBundled && parent.edgesOut.has(node.name)) {\n        if (!ppkg.bundleDependencies) {\n          ppkg.bundleDependencies = [name]\n        } else {\n          ppkg.bundleDependencies.push(name)\n        }\n      }\n    }\n  }\n\n  [loadNode] (location, sw) {\n    const p = this.virtualTree ? this.virtualTree.realpath : this.path\n    const path = resolve(p, location)\n    // shrinkwrap doesn't include package name unless necessary\n    if (!sw.name) {\n      sw.name = nameFromFolder(path)\n    }\n\n    const dev = sw.dev\n    const optional = sw.optional\n    const devOptional = dev || optional || sw.devOptional\n    const peer = sw.peer\n\n    const node = new Node({\n      legacyPeerDeps: this.legacyPeerDeps,\n      root: this.virtualTree,\n      path,\n      realpath: path,\n      integrity: sw.integrity,\n      resolved: consistentResolve(sw.resolved, this.path, path),\n      pkg: sw,\n      hasShrinkwrap: sw.hasShrinkwrap,\n      dev,\n      optional,\n      devOptional,\n      peer,\n    })\n    // cast to boolean because they're undefined in the lock file when false\n    node.extraneous = !!sw.extraneous\n    node.devOptional = !!(sw.devOptional || sw.dev || sw.optional)\n    node.peer = !!sw.peer\n    node.optional = !!sw.optional\n    node.dev = !!sw.dev\n    return node\n  }\n\n  [loadLink] (location, targetLoc, target, meta) {\n    const path = resolve(this.path, location)\n    const link = new Link({\n      legacyPeerDeps: this.legacyPeerDeps,\n      path,\n      realpath: resolve(this.path, targetLoc),\n      target,\n      pkg: target && target.package,\n    })\n    link.extraneous = target.extraneous\n    link.devOptional = target.devOptional\n    link.peer = target.peer\n    link.optional = target.optional\n    link.dev = target.dev\n    return link\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}