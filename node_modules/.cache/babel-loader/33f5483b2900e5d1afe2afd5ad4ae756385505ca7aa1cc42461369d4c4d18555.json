{"ast":null,"code":"// mixin implementing the buildIdealTree method\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\nconst rpj = require('read-package-json-fast');\nconst npa = require('npm-package-arg');\nconst pacote = require('pacote');\nconst cacache = require('cacache');\nconst promiseCallLimit = require('promise-call-limit');\nconst realpath = require('../../lib/realpath.js');\nconst {\n  resolve,\n  dirname\n} = require('path');\nconst {\n  promisify\n} = require('util');\nconst treeCheck = require('../tree-check.js');\nconst readdir = promisify(require('readdir-scoped-modules'));\nconst fs = require('fs');\nconst lstat = promisify(fs.lstat);\nconst readlink = promisify(fs.readlink);\nconst {\n  depth\n} = require('treeverse');\nconst {\n  OK,\n  REPLACE,\n  CONFLICT\n} = require('../can-place-dep.js');\nconst PlaceDep = require('../place-dep.js');\nconst debug = require('../debug.js');\nconst fromPath = require('../from-path.js');\nconst calcDepFlags = require('../calc-dep-flags.js');\nconst Shrinkwrap = require('../shrinkwrap.js');\nconst Node = require('../node.js');\nconst Link = require('../link.js');\nconst addRmPkgDeps = require('../add-rm-pkg-deps.js');\nconst optionalSet = require('../optional-set.js');\nconst {\n  checkEngine,\n  checkPlatform\n} = require('npm-install-checks');\nconst relpath = require('../relpath.js');\n\n// note: some of these symbols are shared so we can hit\n// them with unit tests and reuse them across mixins\nconst _complete = Symbol('complete');\nconst _depsSeen = Symbol('depsSeen');\nconst _depsQueue = Symbol('depsQueue');\nconst _currentDep = Symbol('currentDep');\nconst _updateAll = Symbol('updateAll');\nconst _mutateTree = Symbol('mutateTree');\nconst _flagsSuspect = Symbol.for('flagsSuspect');\nconst _workspaces = Symbol.for('workspaces');\nconst _prune = Symbol('prune');\nconst _preferDedupe = Symbol('preferDedupe');\nconst _legacyBundling = Symbol('legacyBundling');\nconst _parseSettings = Symbol('parseSettings');\nconst _initTree = Symbol('initTree');\nconst _applyUserRequests = Symbol('applyUserRequests');\nconst _applyUserRequestsToNode = Symbol('applyUserRequestsToNode');\nconst _inflateAncientLockfile = Symbol('inflateAncientLockfile');\nconst _buildDeps = Symbol('buildDeps');\nconst _buildDepStep = Symbol('buildDepStep');\nconst _nodeFromEdge = Symbol('nodeFromEdge');\nconst _nodeFromSpec = Symbol('nodeFromSpec');\nconst _fetchManifest = Symbol('fetchManifest');\nconst _problemEdges = Symbol('problemEdges');\nconst _manifests = Symbol('manifests');\nconst _loadWorkspaces = Symbol.for('loadWorkspaces');\nconst _linkFromSpec = Symbol('linkFromSpec');\nconst _loadPeerSet = Symbol('loadPeerSet');\nconst _updateNames = Symbol.for('updateNames');\nconst _fixDepFlags = Symbol('fixDepFlags');\nconst _resolveLinks = Symbol('resolveLinks');\nconst _rootNodeFromPackage = Symbol('rootNodeFromPackage');\nconst _add = Symbol('add');\nconst _resolvedAdd = Symbol.for('resolvedAdd');\nconst _queueNamedUpdates = Symbol('queueNamedUpdates');\nconst _queueVulnDependents = Symbol('queueVulnDependents');\nconst _avoidRange = Symbol('avoidRange');\nconst _shouldUpdateNode = Symbol('shouldUpdateNode');\nconst resetDepFlags = require('../reset-dep-flags.js');\nconst _loadFailures = Symbol('loadFailures');\nconst _pruneFailedOptional = Symbol('pruneFailedOptional');\nconst _linkNodes = Symbol('linkNodes');\nconst _follow = Symbol('follow');\nconst _globalStyle = Symbol('globalStyle');\nconst _globalRootNode = Symbol('globalRootNode');\nconst _isVulnerable = Symbol.for('isVulnerable');\nconst _usePackageLock = Symbol.for('usePackageLock');\nconst _rpcache = Symbol.for('realpathCache');\nconst _stcache = Symbol.for('statCache');\nconst _updateFilePath = Symbol('updateFilePath');\nconst _followSymlinkPath = Symbol('followSymlinkPath');\nconst _getRelpathSpec = Symbol('getRelpathSpec');\nconst _retrieveSpecName = Symbol('retrieveSpecName');\nconst _strictPeerDeps = Symbol('strictPeerDeps');\nconst _checkEngineAndPlatform = Symbol('checkEngineAndPlatform');\nconst _checkEngine = Symbol('checkEngine');\nconst _checkPlatform = Symbol('checkPlatform');\nconst _virtualRoots = Symbol('virtualRoots');\nconst _virtualRoot = Symbol('virtualRoot');\nconst _failPeerConflict = Symbol('failPeerConflict');\nconst _explainPeerConflict = Symbol('explainPeerConflict');\nconst _edgesOverridden = Symbol('edgesOverridden');\n// exposed symbol for unit testing the placeDep method directly\nconst _peerSetSource = Symbol.for('peerSetSource');\n\n// used by Reify mixin\nconst _force = Symbol.for('force');\nconst _explicitRequests = Symbol('explicitRequests');\nconst _global = Symbol.for('global');\nconst _idealTreePrune = Symbol.for('idealTreePrune');\nmodule.exports = cls => class IdealTreeBuilder extends cls {\n  constructor(options) {\n    super(options);\n\n    // normalize trailing slash\n    const registry = options.registry || 'https://registry.npmjs.org';\n    options.registry = this.registry = registry.replace(/\\/+$/, '') + '/';\n    const {\n      idealTree = null,\n      global = false,\n      follow = false,\n      globalStyle = false,\n      legacyPeerDeps = false,\n      force = false,\n      packageLock = true,\n      strictPeerDeps = false,\n      workspaces = []\n    } = options;\n    this[_workspaces] = workspaces || [];\n    this[_force] = !!force;\n    this[_strictPeerDeps] = !!strictPeerDeps;\n    this.idealTree = idealTree;\n    this.legacyPeerDeps = legacyPeerDeps;\n    this[_usePackageLock] = packageLock;\n    this[_global] = !!global;\n    this[_globalStyle] = this[_global] || globalStyle;\n    this[_follow] = !!follow;\n    if (this[_workspaces].length && this[_global]) {\n      throw new Error('Cannot operate on workspaces in global mode');\n    }\n    this[_explicitRequests] = new Set();\n    this[_preferDedupe] = false;\n    this[_legacyBundling] = false;\n    this[_depsSeen] = new Set();\n    this[_depsQueue] = [];\n    this[_currentDep] = null;\n    this[_updateNames] = [];\n    this[_updateAll] = false;\n    this[_mutateTree] = false;\n    this[_loadFailures] = new Set();\n    this[_linkNodes] = new Set();\n    this[_manifests] = new Map();\n    this[_edgesOverridden] = new Set();\n    this[_resolvedAdd] = [];\n\n    // a map of each module in a peer set to the thing that depended on\n    // that set of peers in the first place.  Use a WeakMap so that we\n    // don't hold onto references for nodes that are garbage collected.\n    this[_peerSetSource] = new WeakMap();\n    this[_virtualRoots] = new Map();\n  }\n  get explicitRequests() {\n    return new Set(this[_explicitRequests]);\n  }\n\n  // public method\n  async buildIdealTree(options = {}) {\n    if (this.idealTree) {\n      return Promise.resolve(this.idealTree);\n    }\n\n    // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n    options = {\n      ...this.options,\n      ...options\n    };\n\n    // an empty array or any falsey value is the same as null\n    if (!options.add || options.add.length === 0) {\n      options.add = null;\n    }\n    if (!options.rm || options.rm.length === 0) {\n      options.rm = null;\n    }\n    process.emit('time', 'idealTree');\n    if (!options.add && !options.rm && !options.update && this[_global]) {\n      const er = new Error('global requires add, rm, or update option');\n      return Promise.reject(er);\n    }\n\n    // first get the virtual tree, if possible.  If there's a lockfile, then\n    // that defines the ideal tree, unless the root package.json is not\n    // satisfied by what the ideal tree provides.\n    // from there, we start adding nodes to it to satisfy the deps requested\n    // by the package.json in the root.\n\n    this[_parseSettings](options);\n\n    // start tracker block\n    this.addTracker('idealTree');\n    try {\n      await this[_initTree]();\n      await this[_inflateAncientLockfile]();\n      await this[_applyUserRequests](options);\n      await this[_buildDeps]();\n      await this[_fixDepFlags]();\n      await this[_pruneFailedOptional]();\n      await this[_checkEngineAndPlatform]();\n    } finally {\n      process.emit('timeEnd', 'idealTree');\n      this.finishTracker('idealTree');\n    }\n    return treeCheck(this.idealTree);\n  }\n  async [_checkEngineAndPlatform]() {\n    for (const node of this.idealTree.inventory.values()) {\n      if (!node.optional) {\n        this[_checkEngine](node);\n        this[_checkPlatform](node);\n      }\n    }\n  }\n  [_checkPlatform](node) {\n    checkPlatform(node.package, this[_force]);\n  }\n  [_checkEngine](node) {\n    const {\n      engineStrict,\n      npmVersion,\n      nodeVersion\n    } = this.options;\n    const c = () => checkEngine(node.package, npmVersion, nodeVersion, this[_force]);\n    if (engineStrict) {\n      c();\n    } else {\n      try {\n        c();\n      } catch (er) {\n        this.log.warn(er.code, er.message, {\n          package: er.pkgid,\n          required: er.required,\n          current: er.current\n        });\n      }\n    }\n  }\n  [_parseSettings](options) {\n    const update = options.update === true ? {\n      all: true\n    } : Array.isArray(options.update) ? {\n      names: options.update\n    } : options.update || {};\n    if (update.all || !Array.isArray(update.names)) {\n      update.names = [];\n    }\n    this[_complete] = !!options.complete;\n    this[_preferDedupe] = !!options.preferDedupe;\n    this[_legacyBundling] = !!options.legacyBundling;\n    this[_updateNames] = update.names;\n    this[_updateAll] = update.all;\n    // we prune by default unless explicitly set to boolean false\n    this[_prune] = options.prune !== false;\n\n    // set if we add anything, but also set here if we know we'll make\n    // changes and thus have to maybe prune later.\n    this[_mutateTree] = !!(options.add || options.rm || update.all || update.names.length);\n  }\n\n  // load the initial tree, either the virtualTree from a shrinkwrap,\n  // or just the root node from a package.json\n  [_initTree]() {\n    process.emit('time', 'idealTree:init');\n    return (this[_global] ? this[_globalRootNode]() : rpj(this.path + '/package.json').then(pkg => this[_rootNodeFromPackage](pkg), er => {\n      if (er.code === 'EJSONPARSE') {\n        throw er;\n      }\n      return this[_rootNodeFromPackage]({});\n    })).then(root => this[_loadWorkspaces](root))\n    // ok to not have a virtual tree.  probably initial install.\n    // When updating all, we load the shrinkwrap, but don't bother\n    // to build out the full virtual tree from it, since we'll be\n    // reconstructing it anyway.\n    .then(root => this[_global] ? root : !this[_usePackageLock] || this[_updateAll] ? Shrinkwrap.reset({\n      path: this.path\n    }).then(meta => Object.assign(root, {\n      meta\n    })) : this.loadVirtual({\n      root\n    }))\n\n    // if we don't have a lockfile to go from, then start with the\n    // actual tree, so we only make the minimum required changes.\n    // don't do this for global installs or updates, because in those\n    // cases we don't use a lockfile anyway.\n    // Load on a new Arborist object, so the Nodes aren't the same,\n    // or else it'll get super confusing when we change them!\n    .then(async root => {\n      if (!this[_updateAll] && !this[_global] && !root.meta.loadedFromDisk) {\n        await new this.constructor(this.options).loadActual({\n          root\n        });\n        const tree = root.target;\n        // even though we didn't load it from a package-lock.json FILE,\n        // we still loaded it \"from disk\", meaning we have to reset\n        // dep flags before assuming that any mutations were reflected.\n        if (tree.children.size) {\n          root.meta.loadedFromDisk = true;\n        }\n      }\n      return root;\n    }).then(tree => {\n      // null the virtual tree, because we're about to hack away at it\n      // if you want another one, load another copy.\n      this.idealTree = tree;\n      this.virtualTree = null;\n      process.emit('timeEnd', 'idealTree:init');\n    });\n  }\n  async [_globalRootNode]() {\n    const root = await this[_rootNodeFromPackage]({\n      dependencies: {}\n    });\n    // this is a gross kludge to handle the fact that we don't save\n    // metadata on the root node in global installs, because the \"root\"\n    // node is something like /usr/local/lib.\n    const meta = new Shrinkwrap({\n      path: this.path\n    });\n    meta.reset();\n    root.meta = meta;\n    return root;\n  }\n  async [_rootNodeFromPackage](pkg) {\n    // if the path doesn't exist, then we explode at this point. Note that\n    // this is not a problem for reify(), since it creates the root path\n    // before ever loading trees.\n    // TODO: make buildIdealTree() and loadActual handle a missing root path,\n    // or a symlink to a missing target, and let reify() create it as needed.\n    const real = await realpath(this.path, this[_rpcache], this[_stcache]);\n    const Cls = real === this.path ? Node : Link;\n    const root = new Cls({\n      path: this.path,\n      realpath: real,\n      pkg,\n      extraneous: false,\n      dev: false,\n      devOptional: false,\n      peer: false,\n      optional: false,\n      global: this[_global],\n      legacyPeerDeps: this.legacyPeerDeps\n    });\n    if (root.isLink) {\n      root.target = new Node({\n        path: real,\n        realpath: real,\n        pkg,\n        extraneous: false,\n        dev: false,\n        devOptional: false,\n        peer: false,\n        optional: false,\n        global: this[_global],\n        legacyPeerDeps: this.legacyPeerDeps,\n        root\n      });\n    }\n    return root;\n  }\n\n  // process the add/rm requests by modifying the root node, and the\n  // update.names request by queueing nodes dependent on those named.\n  async [_applyUserRequests](options) {\n    process.emit('time', 'idealTree:userRequests');\n    const tree = this.idealTree.target;\n    if (!this[_workspaces].length) {\n      await this[_applyUserRequestsToNode](tree, options);\n    } else {\n      await Promise.all(this.workspaceNodes(tree, this[_workspaces]).map(node => this[_applyUserRequestsToNode](node, options)));\n    }\n    process.emit('timeEnd', 'idealTree:userRequests');\n  }\n  async [_applyUserRequestsToNode](tree, options) {\n    // If we have a list of package names to update, and we know it's\n    // going to update them wherever they are, add any paths into those\n    // named nodes to the buildIdealTree queue.\n    if (!this[_global] && this[_updateNames].length) {\n      this[_queueNamedUpdates]();\n    }\n\n    // global updates only update the globalTop nodes, but we need to know\n    // that they're there, and not reinstall the world unnecessarily.\n    const globalExplicitUpdateNames = [];\n    if (this[_global] && (this[_updateAll] || this[_updateNames].length)) {\n      const nm = resolve(this.path, 'node_modules');\n      for (const name of await readdir(nm).catch(() => [])) {\n        tree.package.dependencies = tree.package.dependencies || {};\n        const updateName = this[_updateNames].includes(name);\n        if (this[_updateAll] || updateName) {\n          if (updateName) {\n            globalExplicitUpdateNames.push(name);\n          }\n          const dir = resolve(nm, name);\n          const st = await lstat(dir).catch( /* istanbul ignore next */er => null);\n          if (st && st.isSymbolicLink()) {\n            const target = await readlink(dir);\n            const real = resolve(dirname(dir), target);\n            tree.package.dependencies[name] = `file:${real}`;\n          } else {\n            tree.package.dependencies[name] = '*';\n          }\n        }\n      }\n    }\n    if (this.auditReport && this.auditReport.size > 0) {\n      await this[_queueVulnDependents](options);\n    }\n    const {\n      add,\n      rm\n    } = options;\n    if (rm && rm.length) {\n      addRmPkgDeps.rm(tree.package, rm);\n      for (const name of rm) {\n        this[_explicitRequests].add({\n          from: tree,\n          name,\n          action: 'DELETE'\n        });\n      }\n    }\n    if (add && add.length) {\n      await this[_add](tree, options);\n    }\n\n    // triggers a refresh of all edgesOut.  this has to be done BEFORE\n    // adding the edges to explicitRequests, because the package setter\n    // resets all edgesOut.\n    if (add && add.length || rm && rm.length || this[_global]) {\n      tree.package = tree.package;\n    }\n    for (const spec of this[_resolvedAdd]) {\n      if (spec.tree === tree) {\n        this[_explicitRequests].add(tree.edgesOut.get(spec.name));\n      }\n    }\n    for (const name of globalExplicitUpdateNames) {\n      this[_explicitRequests].add(tree.edgesOut.get(name));\n    }\n    this[_depsQueue].push(tree);\n  }\n\n  // This returns a promise because we might not have the name yet,\n  // and need to call pacote.manifest to find the name.\n  [_add](tree, {\n    add,\n    saveType = null,\n    saveBundle = false\n  }) {\n    // get the name for each of the specs in the list.\n    // ie, doing `foo@bar` we just return foo\n    // but if it's a url or git, we don't know the name until we\n    // fetch it and look in its manifest.\n    return Promise.all(add.map(async rawSpec => {\n      // We do NOT provide the path to npa here, because user-additions\n      // need to be resolved relative to the CWD the user is in.\n      const spec = await this[_retrieveSpecName](npa(rawSpec)).then(spec => this[_updateFilePath](spec)).then(spec => this[_followSymlinkPath](spec));\n      spec.tree = tree;\n      return spec;\n    })).then(add => {\n      this[_resolvedAdd].push(...add);\n      // now add is a list of spec objects with names.\n      // find a home for each of them!\n      addRmPkgDeps.add({\n        pkg: tree.package,\n        add,\n        saveBundle,\n        saveType,\n        path: this.path,\n        log: this.log\n      });\n    });\n  }\n  async [_retrieveSpecName](spec) {\n    // if it's just @'' then we reload whatever's there, or get latest\n    // if it's an explicit tag, we need to install that specific tag version\n    const isTag = spec.rawSpec && spec.type === 'tag';\n    if (spec.name && !isTag) {\n      return spec;\n    }\n    const mani = await pacote.manifest(spec, {\n      ...this.options\n    });\n    // if it's a tag type, then we need to run it down to an actual version\n    if (isTag) {\n      return npa(`${mani.name}@${mani.version}`);\n    }\n    spec.name = mani.name;\n    return spec;\n  }\n  async [_updateFilePath](spec) {\n    if (spec.type === 'file') {\n      return this[_getRelpathSpec](spec, spec.fetchSpec);\n    }\n    return spec;\n  }\n  async [_followSymlinkPath](spec) {\n    if (spec.type === 'directory') {\n      const real = await realpath(spec.fetchSpec, this[_rpcache], this[_stcache])\n      // TODO: create synthetic test case to simulate realpath failure\n      .catch( /* istanbul ignore next */() => null);\n      return this[_getRelpathSpec](spec, real);\n    }\n    return spec;\n  }\n  [_getRelpathSpec](spec, filepath) {\n    /* istanbul ignore else - should also be covered by realpath failure */\n    if (filepath) {\n      const {\n        name\n      } = spec;\n      const tree = this.idealTree.target;\n      spec = npa(`file:${relpath(tree.path, filepath)}`, tree.path);\n      spec.name = name;\n    }\n    return spec;\n  }\n\n  // TODO: provide a way to fix bundled deps by exposing metadata about\n  // what's in the bundle at each published manifest.  Without that, we\n  // can't possibly fix bundled deps without breaking a ton of other stuff,\n  // and leaving the user subject to getting it overwritten later anyway.\n  async [_queueVulnDependents](options) {\n    for (const vuln of this.auditReport.values()) {\n      for (const node of vuln.nodes) {\n        const bundler = node.getBundler();\n\n        // XXX this belongs in the audit report itself, not here.\n        // We shouldn't even get these things here, and they shouldn't\n        // be printed by npm-audit-report as if they can be fixed, because\n        // they can't.\n        if (bundler) {\n          this.log.warn(`audit fix ${node.name}@${node.version}`, `${node.location}\\nis a bundled dependency of\\n${bundler.name}@${bundler.version} at ${bundler.location}\\n` + 'It cannot be fixed automatically.\\n' + `Check for updates to the ${bundler.name} package.`);\n          continue;\n        }\n        for (const edge of node.edgesIn) {\n          this.addTracker('idealTree', edge.from.name, edge.from.location);\n          this[_depsQueue].push(edge.from);\n        }\n      }\n    }\n\n    // note any that can't be fixed at the root level without --force\n    // if there's a fix, we use that.  otherwise, the user has to remove it,\n    // find a different thing, fix the upstream, etc.\n    //\n    // XXX: how to handle top nodes that aren't the root?  Maybe the report\n    // just tells the user to cd into that directory and fix it?\n    if (this[_force] && this.auditReport && this.auditReport.topVulns.size) {\n      options.add = options.add || [];\n      options.rm = options.rm || [];\n      const nodesTouched = new Set();\n      for (const [name, topVuln] of this.auditReport.topVulns.entries()) {\n        const {\n          simpleRange,\n          topNodes,\n          fixAvailable\n        } = topVuln;\n        for (const node of topNodes) {\n          if (!node.isProjectRoot && !node.isWorkspace) {\n            // not something we're going to fix, sorry.  have to cd into\n            // that directory and fix it yourself.\n            this.log.warn('audit', 'Manual fix required in linked project ' + `at ./${node.location} for ${name}@${simpleRange}.\\n` + `'cd ./${node.location}' and run 'npm audit' for details.`);\n            continue;\n          }\n          if (!fixAvailable) {\n            this.log.warn('audit', `No fix available for ${name}@${simpleRange}`);\n            continue;\n          }\n          const {\n            isSemVerMajor,\n            version\n          } = fixAvailable;\n          const breakingMessage = isSemVerMajor ? 'a SemVer major change' : 'outside your stated dependency range';\n          this.log.warn('audit', `Updating ${name} to ${version},` + `which is ${breakingMessage}.`);\n          await this[_add](node, {\n            add: [`${name}@${version}`]\n          });\n          nodesTouched.add(node);\n        }\n      }\n      for (const node of nodesTouched) {\n        node.package = node.package;\n      }\n    }\n  }\n  [_isVulnerable](node) {\n    return this.auditReport && this.auditReport.isVulnerable(node);\n  }\n  [_avoidRange](name) {\n    if (!this.auditReport) {\n      return null;\n    }\n    const vuln = this.auditReport.get(name);\n    if (!vuln) {\n      return null;\n    }\n    return vuln.range;\n  }\n  [_queueNamedUpdates]() {\n    // ignore top nodes, since they are not loaded the same way, and\n    // probably have their own project associated with them.\n\n    // for every node with one of the names on the list, we add its\n    // dependents to the queue to be evaluated.  in buildDepStep,\n    // anything on the update names list will get refreshed, even if\n    // it isn't a problem.\n\n    // XXX this could be faster by doing a series of inventory.query('name')\n    // calls rather than walking over everything in the tree.\n    const set = this.idealTree.inventory.filter(n => this[_shouldUpdateNode](n));\n    for (const node of set) {\n      for (const edge of node.edgesIn) {\n        this.addTracker('idealTree', edge.from.name, edge.from.location);\n        this[_depsQueue].push(edge.from);\n      }\n    }\n  }\n  [_shouldUpdateNode](node) {\n    return this[_updateNames].includes(node.name) && !node.isTop && !node.inDepBundle && !node.inShrinkwrap;\n  }\n  async [_inflateAncientLockfile]() {\n    const {\n      meta,\n      inventory\n    } = this.idealTree;\n    const ancient = meta.ancientLockfile;\n    const old = meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2);\n    if (inventory.size === 0 || !ancient && !old) {\n      return;\n    }\n\n    // if the lockfile is from node v5 or earlier, then we'll have to reload\n    // all the manifests of everything we encounter.  this is costly, but at\n    // least it's just a one-time hit.\n    process.emit('time', 'idealTree:inflate');\n    const heading = ancient ? 'ancient lockfile' : 'old lockfile';\n    this.log.warn(heading, `\nThe ${meta.type} file was created with an old version of npm,\nso supplemental metadata must be fetched from the registry.\n\nThis is a one-time fix-up, please be patient...\n`);\n    this.addTracker('idealTree:inflate');\n    const queue = [];\n    for (const node of inventory.values()) {\n      if (node.isProjectRoot) {\n        continue;\n      }\n      queue.push(async () => {\n        this.log.silly('inflate', node.location);\n        const {\n          resolved,\n          version,\n          path,\n          name,\n          location,\n          integrity\n        } = node;\n        // don't try to hit the registry for linked deps\n        const useResolved = resolved && (!version || resolved.startsWith('file:'));\n        const id = useResolved ? resolved : version || `file:${node.path}`;\n        const spec = npa.resolve(name, id, dirname(path));\n        const sloc = location.substr('node_modules/'.length);\n        const t = `idealTree:inflate:${sloc}`;\n        this.addTracker(t);\n        await pacote.manifest(spec, {\n          ...this.options,\n          resolved: resolved,\n          integrity: integrity,\n          fullMetadata: false\n        }).then(mani => {\n          node.package = {\n            ...mani,\n            _id: `${mani.name}@${mani.version}`\n          };\n        }).catch(er => {\n          const warning = `Could not fetch metadata for ${name}@${id}`;\n          this.log.warn(heading, warning, er);\n        });\n        this.finishTracker(t);\n      });\n    }\n    await promiseCallLimit(queue);\n\n    // have to re-calc dep flags, because the nodes don't have edges\n    // until their packages get assigned, so everything looks extraneous\n    calcDepFlags(this.idealTree);\n\n    // yes, yes, this isn't the \"original\" version, but now that it's been\n    // upgraded, we need to make sure we don't do the work to upgrade it\n    // again, since it's now as new as can be.\n    meta.originalLockfileVersion = 2;\n    this.finishTracker('idealTree:inflate');\n    process.emit('timeEnd', 'idealTree:inflate');\n  }\n\n  // at this point we have a virtual tree with the actual root node's\n  // package deps, which may be partly or entirely incomplete, invalid\n  // or extraneous.\n  [_buildDeps]() {\n    process.emit('time', 'idealTree:buildDeps');\n    const tree = this.idealTree.target;\n    this[_depsQueue].push(tree);\n    this.log.silly('idealTree', 'buildDeps');\n    this.addTracker('idealTree', tree.name, '');\n    return this[_buildDepStep]().then(() => process.emit('timeEnd', 'idealTree:buildDeps'));\n  }\n  async [_buildDepStep]() {\n    // removes tracker of previous dependency in the queue\n    if (this[_currentDep]) {\n      const {\n        location,\n        name\n      } = this[_currentDep];\n      process.emit('timeEnd', `idealTree:${location || '#root'}`);\n      this.finishTracker('idealTree', name, location);\n      this[_currentDep] = null;\n    }\n    if (!this[_depsQueue].length) {\n      return this[_resolveLinks]();\n    }\n\n    // sort physically shallower deps up to the front of the queue,\n    // because they'll affect things deeper in, then alphabetical\n    this[_depsQueue].sort((a, b) => a.depth - b.depth || localeCompare(a.path, b.path));\n    const node = this[_depsQueue].shift();\n    const bd = node.package.bundleDependencies;\n    const hasBundle = bd && Array.isArray(bd) && bd.length;\n    const {\n      hasShrinkwrap\n    } = node;\n\n    // if the node was already visited, or has since been removed from the\n    // tree, skip over it and process the rest of the queue.  If a node has\n    // a shrinkwrap, also skip it, because it's going to get its deps\n    // satisfied by whatever's in that file anyway.\n    if (this[_depsSeen].has(node) || node.root !== this.idealTree || hasShrinkwrap && !this[_complete]) {\n      return this[_buildDepStep]();\n    }\n    this[_depsSeen].add(node);\n    this[_currentDep] = node;\n    process.emit('time', `idealTree:${node.location || '#root'}`);\n\n    // if we're loading a _complete_ ideal tree, for a --package-lock-only\n    // installation for example, we have to crack open the tarball and\n    // look inside if it has bundle deps or shrinkwraps.  note that this is\n    // not necessary during a reification, because we just update the\n    // ideal tree by reading bundles/shrinkwraps in place.\n    // Don't bother if the node is from the actual tree and hasn't\n    // been resolved, because we can't fetch it anyway, could be anything!\n    const crackOpen = this[_complete] && node !== this.idealTree && node.resolved && (hasBundle || hasShrinkwrap);\n    if (crackOpen) {\n      const Arborist = this.constructor;\n      const opt = {\n        ...this.options\n      };\n      await cacache.tmp.withTmp(this.cache, opt, async path => {\n        await pacote.extract(node.resolved, path, {\n          ...opt,\n          resolved: node.resolved,\n          integrity: node.integrity\n        });\n        if (hasShrinkwrap) {\n          await new Arborist({\n            ...this.options,\n            path\n          }).loadVirtual({\n            root: node\n          });\n        }\n        if (hasBundle) {\n          await new Arborist({\n            ...this.options,\n            path\n          }).loadActual({\n            root: node,\n            ignoreMissing: true\n          });\n        }\n      });\n    }\n\n    // if any deps are missing or invalid, then we fetch the manifest for\n    // the thing we want, and build a new dep node from that.\n    // Then, find the ideal placement for that node.  The ideal placement\n    // searches from the node's deps (or parent deps in the case of non-root\n    // peer deps), and walks up the tree until it finds the highest spot\n    // where it doesn't cause any conflicts.\n    //\n    // A conflict can be:\n    // - A node by that name already exists at that location.\n    // - The parent has a peer dep on that name\n    // - One of the node's peer deps conflicts at that location, unless the\n    //   peer dep is met by a node at that location, which is fine.\n    //\n    // If we create a new node, then build its ideal deps as well.\n    //\n    // Note: this is the same \"maximally naive\" deduping tree-building\n    // algorithm that npm has used since v3.  In a case like this:\n    //\n    // root -> (a@1, b@1||2)\n    // a -> (b@1)\n    //\n    // You'll end up with a tree like this:\n    //\n    // root\n    // +-- a@1\n    // |   +-- b@1\n    // +-- b@2\n    //\n    // rather than this, more deduped, but just as correct tree:\n    //\n    // root\n    // +-- a@1\n    // +-- b@1\n    //\n    // Another way to look at it is that this algorithm favors getting higher\n    // version deps at higher levels in the tree, even if that reduces\n    // potential deduplication.\n    //\n    // Set `preferDedupe: true` in the options to replace the shallower\n    // dep if allowed.\n\n    const tasks = [];\n    const peerSource = this[_peerSetSource].get(node) || node;\n    for (const edge of this[_problemEdges](node)) {\n      if (edge.overridden) {\n        continue;\n      }\n\n      // peerSetSource is only relevant when we have a peerEntryEdge\n      // otherwise we're setting regular non-peer deps as if they have\n      // a virtual root of whatever brought in THIS node.\n      // so we VR the node itself if the edge is not a peer\n      const source = edge.peer ? peerSource : node;\n      const virtualRoot = this[_virtualRoot](source, true);\n      // reuse virtual root if we already have one, but don't\n      // try to do the override ahead of time, since we MAY be able\n      // to create a more correct tree than the virtual root could.\n      const vrEdge = virtualRoot && virtualRoot.edgesOut.get(edge.name);\n      const vrDep = vrEdge && vrEdge.valid && vrEdge.to;\n      // only re-use the virtualRoot if it's a peer edge we're placing.\n      // otherwise, we end up in situations where we override peer deps that\n      // we could have otherwise found homes for.  Eg:\n      // xy -> (x, y)\n      // x -> PEER(z@1)\n      // y -> PEER(z@2)\n      // If xy is a dependency, we can resolve this like:\n      // project\n      // +-- xy\n      // |   +-- y\n      // |   +-- z@2\n      // +-- x\n      // +-- z@1\n      // But if x and y are loaded in the same virtual root, then they will\n      // be forced to agree on a version of z.\n      const required = new Set([edge.from]);\n      const parent = edge.peer ? virtualRoot : null;\n      const dep = vrDep && vrDep.satisfies(edge) ? vrDep : await this[_nodeFromEdge](edge, parent, null, required);\n\n      /* istanbul ignore next */\n      debug(() => {\n        if (!dep) {\n          throw new Error('no dep??');\n        }\n      });\n      tasks.push({\n        edge,\n        dep\n      });\n    }\n    const placeDeps = tasks.sort((a, b) => localeCompare(a.edge.name, b.edge.name)).map(({\n      edge,\n      dep\n    }) => new PlaceDep({\n      edge,\n      dep,\n      explicitRequest: this[_explicitRequests].has(edge),\n      updateNames: this[_updateNames],\n      auditReport: this.auditReport,\n      force: this[_force],\n      preferDedupe: this[_preferDedupe],\n      legacyBundling: this[_legacyBundling],\n      strictPeerDeps: this[_strictPeerDeps],\n      legacyPeerDeps: this.legacyPeerDeps,\n      globalStyle: this[_globalStyle]\n    }));\n    const promises = [];\n    for (const pd of placeDeps) {\n      // placing a dep is actually a tree of placing the dep itself\n      // and all of its peer group that aren't already met by the tree\n      depth({\n        tree: pd,\n        getChildren: pd => pd.children,\n        visit: pd => {\n          const {\n            placed,\n            edge,\n            canPlace: cpd\n          } = pd;\n          // if we didn't place anything, nothing to do here\n          if (!placed) {\n            return;\n          }\n\n          // we placed something, that means we changed the tree\n          if (placed.errors.length) {\n            this[_loadFailures].add(placed);\n          }\n          this[_mutateTree] = true;\n          if (cpd.canPlaceSelf === OK) {\n            for (const edgeIn of placed.edgesIn) {\n              if (edgeIn === edge) {\n                continue;\n              }\n              const {\n                from,\n                valid,\n                overridden\n              } = edgeIn;\n              if (!overridden && !valid && !this[_depsSeen].has(from)) {\n                this.addTracker('idealTree', from.name, from.location);\n                this[_depsQueue].push(edgeIn.from);\n              }\n            }\n          } else {\n            /* istanbul ignore else - should be only OK or REPLACE here */\n            if (cpd.canPlaceSelf === REPLACE) {\n              // this may also create some invalid edges, for example if we're\n              // intentionally causing something to get nested which was\n              // previously placed in this location.\n              for (const edgeIn of placed.edgesIn) {\n                if (edgeIn === edge) {\n                  continue;\n                }\n                const {\n                  valid,\n                  overridden\n                } = edgeIn;\n                if (!valid && !overridden) {\n                  // if it's already been visited, we have to re-visit\n                  // otherwise, just enqueue normally.\n                  this[_depsSeen].delete(edgeIn.from);\n                  this[_depsQueue].push(edgeIn.from);\n                }\n              }\n            }\n          }\n\n          /* istanbul ignore if - should be impossible */\n          if (cpd.canPlaceSelf === CONFLICT) {\n            debug(() => {\n              const er = new Error('placed with canPlaceSelf=CONFLICT');\n              throw Object.assign(er, {\n                placeDep: pd\n              });\n            });\n            return;\n          }\n\n          // lastly, also check for the missing deps of the node we placed,\n          // and any holes created by pruning out conflicted peer sets.\n          this[_depsQueue].push(placed);\n          for (const dep of pd.needEvaluation) {\n            this[_depsSeen].delete(dep);\n            this[_depsQueue].push(dep);\n          }\n\n          // pre-fetch any problem edges, since we'll need these soon\n          // if it fails at this point, though, dont' worry because it\n          // may well be an optional dep that has gone missing.  it'll\n          // fail later anyway.\n          const from = fromPath(placed);\n          promises.push(...this[_problemEdges](placed).map(e => this[_fetchManifest](npa.resolve(e.name, e.spec, from)).catch(er => null)));\n        }\n      });\n    }\n    for (const {\n      to\n    } of node.edgesOut.values()) {\n      if (to && to.isLink && to.target) {\n        this[_linkNodes].add(to);\n      }\n    }\n    await Promise.all(promises);\n    return this[_buildDepStep]();\n  }\n\n  // loads a node from an edge, and then loads its peer deps (and their\n  // peer deps, on down the line) into a virtual root parent.\n  async [_nodeFromEdge](edge, parent_, secondEdge, required) {\n    // create a virtual root node with the same deps as the node that\n    // is requesting this one, so that we can get all the peer deps in\n    // a context where they're likely to be resolvable.\n    // Note that the virtual root will also have virtual copies of the\n    // targets of any child Links, so that they resolve appropriately.\n    const parent = parent_ || this[_virtualRoot](edge.from);\n    const spec = npa.resolve(edge.name, edge.spec, edge.from.path);\n    const first = await this[_nodeFromSpec](edge.name, spec, parent, edge);\n\n    // we might have a case where the parent has a peer dependency on\n    // `foo@*` which resolves to v2, but another dep in the set has a\n    // peerDependency on `foo@1`.  In that case, if we force it to be v2,\n    // we're unnecessarily triggering an ERESOLVE.\n    // If we have a second edge to worry about, and it's not satisfied\n    // by the first node, try a second and see if that satisfies the\n    // original edge here.\n    const spec2 = secondEdge && npa.resolve(edge.name, secondEdge.spec, secondEdge.from.path);\n    const second = secondEdge && !secondEdge.valid ? await this[_nodeFromSpec](edge.name, spec2, parent, secondEdge) : null;\n\n    // pick the second one if they're both happy with that, otherwise first\n    const node = second && edge.valid ? second : first;\n    // ensure the one we want is the one that's placed\n    node.parent = parent;\n    if (required.has(edge.from) && edge.type !== 'peerOptional' || secondEdge && required.has(secondEdge.from) && secondEdge.type !== 'peerOptional') {\n      required.add(node);\n    }\n\n    // keep track of the thing that caused this node to be included.\n    const src = parent.sourceReference;\n    this[_peerSetSource].set(node, src);\n\n    // do not load the peers along with the set if this is a global top pkg\n    // otherwise we'll be tempted to put peers as other top-level installed\n    // things, potentially clobbering what's there already, which is not\n    // what we want.  the missing edges will be picked up on the next pass.\n    if (this[_global] && edge.from.isProjectRoot) {\n      return node;\n    }\n\n    // otherwise, we have to make sure that our peers can go along with us.\n    return this[_loadPeerSet](node, required);\n  }\n  [_virtualRoot](node, reuse = false) {\n    if (reuse && this[_virtualRoots].has(node)) {\n      return this[_virtualRoots].get(node);\n    }\n    const vr = new Node({\n      path: node.realpath,\n      sourceReference: node,\n      legacyPeerDeps: this.legacyPeerDeps\n    });\n\n    // also need to set up any targets from any link deps, so that\n    // they are properly reflected in the virtual environment\n    for (const child of node.children.values()) {\n      if (child.isLink) {\n        new Node({\n          path: child.realpath,\n          sourceReference: child.target,\n          root: vr\n        });\n      }\n    }\n    this[_virtualRoots].set(node, vr);\n    return vr;\n  }\n  [_problemEdges](node) {\n    // skip over any bundled deps, they're not our problem.\n    // Note that this WILL fetch bundled meta-deps which are also dependencies\n    // but not listed as bundled deps.  When reifying, we first unpack any\n    // nodes that have bundleDependencies, then do a loadActual on them, move\n    // the nodes into the ideal tree, and then prune.  So, fetching those\n    // possibly-bundled meta-deps at this point doesn't cause any worse\n    // problems than a few unnecessary packument fetches.\n\n    // also skip over any nodes in the tree that failed to load, since those\n    // will crash the install later on anyway.\n    const bd = node.isProjectRoot || node.isWorkspace ? null : node.package.bundleDependencies;\n    const bundled = new Set(bd || []);\n    return [...node.edgesOut.values()].filter(edge => {\n      // If it's included in a bundle, we take whatever is specified.\n      if (bundled.has(edge.name)) {\n        return false;\n      }\n\n      // If it's already been logged as a load failure, skip it.\n      if (edge.to && this[_loadFailures].has(edge.to)) {\n        return false;\n      }\n\n      // If it's shrinkwrapped, we use what the shrinkwap wants.\n      if (edge.to && edge.to.inShrinkwrap) {\n        return false;\n      }\n\n      // If the edge has no destination, that's a problem, unless\n      // if it's peerOptional and not explicitly requested.\n      if (!edge.to) {\n        return edge.type !== 'peerOptional' || this[_explicitRequests].has(edge);\n      }\n\n      // If the edge has an error, there's a problem.\n      if (!edge.valid) {\n        return true;\n      }\n\n      // user explicitly asked to update this package by name, problem\n      if (this[_updateNames].includes(edge.name)) {\n        return true;\n      }\n\n      // fixing a security vulnerability with this package, problem\n      if (this[_isVulnerable](edge.to)) {\n        return true;\n      }\n\n      // user has explicitly asked to install this package, problem\n      if (this[_explicitRequests].has(edge)) {\n        return true;\n      }\n\n      // No problems!\n      return false;\n    });\n  }\n  async [_fetchManifest](spec) {\n    const options = {\n      ...this.options,\n      avoid: this[_avoidRange](spec.name)\n    };\n    // get the intended spec and stored metadata from yarn.lock file,\n    // if available and valid.\n    spec = this.idealTree.meta.checkYarnLock(spec, options);\n    if (this[_manifests].has(spec.raw)) {\n      return this[_manifests].get(spec.raw);\n    } else {\n      this.log.silly('fetch manifest', spec.raw);\n      const p = pacote.manifest(spec, options).then(mani => {\n        this[_manifests].set(spec.raw, mani);\n        return mani;\n      });\n      this[_manifests].set(spec.raw, p);\n      return p;\n    }\n  }\n  [_nodeFromSpec](name, spec, parent, edge) {\n    // pacote will slap integrity on its options, so we have to clone\n    // the object so it doesn't get mutated.\n    // Don't bother to load the manifest for link deps, because the target\n    // might be within another package that doesn't exist yet.\n    const {\n      legacyPeerDeps\n    } = this;\n    return spec.type === 'directory' ? this[_linkFromSpec](name, spec, parent, edge) : this[_fetchManifest](spec).then(pkg => new Node({\n      name,\n      pkg,\n      parent,\n      legacyPeerDeps\n    }), error => {\n      error.requiredBy = edge.from.location || '.';\n\n      // failed to load the spec, either because of enotarget or\n      // fetch failure of some other sort.  save it so we can verify\n      // later that it's optional, otherwise the error is fatal.\n      const n = new Node({\n        name,\n        parent,\n        error,\n        legacyPeerDeps\n      });\n      this[_loadFailures].add(n);\n      return n;\n    });\n  }\n  [_linkFromSpec](name, spec, parent, edge) {\n    const realpath = spec.fetchSpec;\n    const {\n      legacyPeerDeps\n    } = this;\n    return rpj(realpath + '/package.json').catch(() => ({})).then(pkg => {\n      const link = new Link({\n        name,\n        parent,\n        realpath,\n        pkg,\n        legacyPeerDeps\n      });\n      this[_linkNodes].add(link);\n      return link;\n    });\n  }\n\n  // load all peer deps and meta-peer deps into the node's parent\n  // At the end of this, the node's peer-type outward edges are all\n  // resolved, and so are all of theirs, but other dep types are not.\n  // We prefer to get peer deps that meet the requiring node's dependency,\n  // if possible, since that almost certainly works (since that package was\n  // developed with this set of deps) and will typically be more restrictive.\n  // Note that the peers in the set can conflict either with each other,\n  // or with a direct dependency from the virtual root parent!  In strict\n  // mode, this is always an error.  In force mode, it never is, and we\n  // prefer the parent's non-peer dep over a peer dep, or the version that\n  // gets placed first.  In non-strict mode, we behave strictly if the\n  // virtual root is based on the root project, and allow non-peer parent\n  // deps to override, but throw if no preference can be determined.\n  async [_loadPeerSet](node, required) {\n    const peerEdges = [...node.edgesOut.values()]\n    // we typically only install non-optional peers, but we have to\n    // factor them into the peerSet so that we can avoid conflicts\n    .filter(e => e.peer && !(e.valid && e.to)).sort(({\n      name: a\n    }, {\n      name: b\n    }) => localeCompare(a, b));\n    for (const edge of peerEdges) {\n      // already placed this one, and we're happy with it.\n      if (edge.valid && edge.to) {\n        continue;\n      }\n      const parentEdge = node.parent.edgesOut.get(edge.name);\n      const {\n        isProjectRoot,\n        isWorkspace\n      } = node.parent.sourceReference;\n      const isMine = isProjectRoot || isWorkspace;\n      const conflictOK = this[_force] || !isMine && !this[_strictPeerDeps];\n      if (!edge.to) {\n        if (!parentEdge) {\n          // easy, just put the thing there\n          await this[_nodeFromEdge](edge, node.parent, null, required);\n          continue;\n        } else {\n          // if the parent's edge is very broad like >=1, and the edge in\n          // question is something like 1.x, then we want to get a 1.x, not\n          // a 2.x.  pass along the child edge as an advisory guideline.\n          // if the parent edge doesn't satisfy the child edge, and the\n          // child edge doesn't satisfy the parent edge, then we have\n          // a conflict.  this is always a problem in strict mode, never\n          // in force mode, and a problem in non-strict mode if this isn't\n          // on behalf of our project.  in all such cases, we warn at least.\n          const dep = await this[_nodeFromEdge](parentEdge, node.parent, edge, required);\n\n          // hooray! that worked!\n          if (edge.valid) {\n            continue;\n          }\n\n          // allow it.  either we're overriding, or it's not something\n          // that will be installed by default anyway, and we'll fail when\n          // we get to the point where we need to, if we need to.\n          if (conflictOK || !required.has(dep)) {\n            edge.overridden = true;\n            continue;\n          }\n\n          // problem\n          this[_failPeerConflict](edge, parentEdge);\n        }\n      }\n\n      // There is something present already, and we're not happy about it\n      // See if the thing we WOULD be happy with is also going to satisfy\n      // the other dependents on the current node.\n      const current = edge.to;\n      const dep = await this[_nodeFromEdge](edge, null, null, required);\n      if (dep.canReplace(current)) {\n        await this[_nodeFromEdge](edge, node.parent, null, required);\n        continue;\n      }\n\n      // at this point we know that there is a dep there, and\n      // we don't like it.  always fail strictly, always allow forcibly or\n      // in non-strict mode if it's not our fault.  don't warn here, because\n      // we are going to warn again when we place the deps, if we end up\n      // overriding for something else.  If the thing that has this dep\n      // isn't also required, then there's a good chance we won't need it,\n      // so allow it for now and let it conflict if it turns out to actually\n      // be necessary for the installation.\n      if (conflictOK || !required.has(edge.from)) {\n        continue;\n      }\n\n      // ok, it's the root, or we're in unforced strict mode, so this is bad\n      this[_failPeerConflict](edge, parentEdge);\n    }\n    return node;\n  }\n  [_failPeerConflict](edge, currentEdge) {\n    const expl = this[_explainPeerConflict](edge, currentEdge);\n    throw Object.assign(new Error('unable to resolve dependency tree'), expl);\n  }\n  [_explainPeerConflict](edge, currentEdge) {\n    const node = edge.from;\n    const curNode = node.resolve(edge.name);\n    const current = curNode.explain();\n    return {\n      code: 'ERESOLVE',\n      current,\n      // it SHOULD be impossible to get here without a current node in place,\n      // but this at least gives us something report on when bugs creep into\n      // the tree handling logic.\n      currentEdge: currentEdge ? currentEdge.explain() : null,\n      edge: edge.explain(),\n      strictPeerDeps: this[_strictPeerDeps],\n      force: this[_force]\n    };\n  }\n\n  // go through all the links in the this[_linkNodes] set\n  // for each one:\n  // - if outside the root, ignore it, assume it's fine, it's not our problem\n  // - if a node in the tree already, assign the target to that node.\n  // - if a path under an existing node, then assign that as the fsParent,\n  //   and add it to the _depsQueue\n  //\n  // call buildDepStep if anything was added to the queue, otherwise we're done\n  [_resolveLinks]() {\n    for (const link of this[_linkNodes]) {\n      this[_linkNodes].delete(link);\n\n      // link we never ended up placing, skip it\n      if (link.root !== this.idealTree) {\n        continue;\n      }\n      const tree = this.idealTree.target;\n      const external = !link.target.isDescendantOf(tree);\n\n      // outside the root, somebody else's problem, ignore it\n      if (external && !this[_follow]) {\n        continue;\n      }\n\n      // didn't find a parent for it or it has not been seen yet\n      // so go ahead and process it.\n      const unseenLink = (link.target.parent || link.target.fsParent) && !this[_depsSeen].has(link.target);\n      if (this[_follow] && !link.target.parent && !link.target.fsParent || unseenLink) {\n        this.addTracker('idealTree', link.target.name, link.target.location);\n        this[_depsQueue].push(link.target);\n      }\n    }\n    if (this[_depsQueue].length) {\n      return this[_buildDepStep]();\n    }\n  }\n  [_fixDepFlags]() {\n    process.emit('time', 'idealTree:fixDepFlags');\n    const metaFromDisk = this.idealTree.meta.loadedFromDisk;\n    const flagsSuspect = this[_flagsSuspect];\n    const mutateTree = this[_mutateTree];\n    // if the options set prune:false, then we don't prune, but we still\n    // mark the extraneous items in the tree if we modified it at all.\n    // If we did no modifications, we just iterate over the extraneous nodes.\n    // if we started with an empty tree, then the dep flags are already\n    // all set to true, and there can be nothing extraneous, so there's\n    // nothing to prune, because we built it from scratch.  if we didn't\n    // add or remove anything, then also nothing to do.\n    if (metaFromDisk && mutateTree) {\n      resetDepFlags(this.idealTree);\n    }\n\n    // update all the dev/optional/etc flags in the tree\n    // either we started with a fresh tree, or we\n    // reset all the flags to find the extraneous nodes.\n    //\n    // if we started from a blank slate, or changed something, then\n    // the dep flags will be all set to true.\n    if (!metaFromDisk || mutateTree) {\n      calcDepFlags(this.idealTree);\n    } else {\n      // otherwise just unset all the flags on the root node\n      // since they will sometimes have the default value\n      this.idealTree.extraneous = false;\n      this.idealTree.dev = false;\n      this.idealTree.optional = false;\n      this.idealTree.devOptional = false;\n      this.idealTree.peer = false;\n    }\n\n    // at this point, any node marked as extraneous should be pruned.\n    // if we started from a shrinkwrap, and then added/removed something,\n    // then the tree is suspect.  Prune what is marked as extraneous.\n    // otherwise, don't bother.\n    const needPrune = metaFromDisk && (mutateTree || flagsSuspect);\n    if (this[_prune] && needPrune) {\n      this[_idealTreePrune]();\n    }\n    process.emit('timeEnd', 'idealTree:fixDepFlags');\n  }\n  [_idealTreePrune]() {\n    for (const node of this.idealTree.inventory.filter(n => n.extraneous)) {\n      node.parent = null;\n    }\n  }\n  [_pruneFailedOptional]() {\n    for (const node of this[_loadFailures]) {\n      if (!node.optional) {\n        throw node.errors[0];\n      }\n      const set = optionalSet(node);\n      for (const node of set) {\n        node.parent = null;\n      }\n    }\n  }\n};","map":{"version":3,"names":["localeCompare","require","rpj","npa","pacote","cacache","promiseCallLimit","realpath","resolve","dirname","promisify","treeCheck","readdir","fs","lstat","readlink","depth","OK","REPLACE","CONFLICT","PlaceDep","debug","fromPath","calcDepFlags","Shrinkwrap","Node","Link","addRmPkgDeps","optionalSet","checkEngine","checkPlatform","relpath","_complete","Symbol","_depsSeen","_depsQueue","_currentDep","_updateAll","_mutateTree","_flagsSuspect","for","_workspaces","_prune","_preferDedupe","_legacyBundling","_parseSettings","_initTree","_applyUserRequests","_applyUserRequestsToNode","_inflateAncientLockfile","_buildDeps","_buildDepStep","_nodeFromEdge","_nodeFromSpec","_fetchManifest","_problemEdges","_manifests","_loadWorkspaces","_linkFromSpec","_loadPeerSet","_updateNames","_fixDepFlags","_resolveLinks","_rootNodeFromPackage","_add","_resolvedAdd","_queueNamedUpdates","_queueVulnDependents","_avoidRange","_shouldUpdateNode","resetDepFlags","_loadFailures","_pruneFailedOptional","_linkNodes","_follow","_globalStyle","_globalRootNode","_isVulnerable","_usePackageLock","_rpcache","_stcache","_updateFilePath","_followSymlinkPath","_getRelpathSpec","_retrieveSpecName","_strictPeerDeps","_checkEngineAndPlatform","_checkEngine","_checkPlatform","_virtualRoots","_virtualRoot","_failPeerConflict","_explainPeerConflict","_edgesOverridden","_peerSetSource","_force","_explicitRequests","_global","_idealTreePrune","module","exports","cls","IdealTreeBuilder","constructor","options","registry","replace","idealTree","global","follow","globalStyle","legacyPeerDeps","force","packageLock","strictPeerDeps","workspaces","length","Error","Set","Map","WeakMap","explicitRequests","buildIdealTree","Promise","add","rm","process","emit","update","er","reject","addTracker","finishTracker","node","inventory","values","optional","package","engineStrict","npmVersion","nodeVersion","c","log","warn","code","message","pkgid","required","current","all","Array","isArray","names","complete","preferDedupe","legacyBundling","prune","path","then","pkg","root","reset","meta","Object","assign","loadVirtual","loadedFromDisk","loadActual","tree","target","children","size","virtualTree","dependencies","real","Cls","extraneous","dev","devOptional","peer","isLink","workspaceNodes","map","globalExplicitUpdateNames","nm","name","catch","updateName","includes","push","dir","st","isSymbolicLink","auditReport","from","action","spec","edgesOut","get","saveType","saveBundle","rawSpec","isTag","type","mani","manifest","version","fetchSpec","filepath","vuln","nodes","bundler","getBundler","location","edge","edgesIn","topVulns","nodesTouched","topVuln","entries","simpleRange","topNodes","fixAvailable","isProjectRoot","isWorkspace","isSemVerMajor","breakingMessage","isVulnerable","range","set","filter","n","isTop","inDepBundle","inShrinkwrap","ancient","ancientLockfile","old","originalLockfileVersion","heading","queue","silly","resolved","integrity","useResolved","startsWith","id","sloc","substr","t","fullMetadata","_id","warning","sort","a","b","shift","bd","bundleDependencies","hasBundle","hasShrinkwrap","has","crackOpen","Arborist","opt","tmp","withTmp","cache","extract","ignoreMissing","tasks","peerSource","overridden","source","virtualRoot","vrEdge","vrDep","valid","to","parent","dep","satisfies","placeDeps","explicitRequest","updateNames","promises","pd","getChildren","visit","placed","canPlace","cpd","errors","canPlaceSelf","edgeIn","delete","placeDep","needEvaluation","e","parent_","secondEdge","first","spec2","second","src","sourceReference","reuse","vr","child","bundled","avoid","checkYarnLock","raw","p","error","requiredBy","link","peerEdges","parentEdge","isMine","conflictOK","canReplace","currentEdge","expl","curNode","explain","external","isDescendantOf","unseenLink","fsParent","metaFromDisk","flagsSuspect","mutateTree","needPrune"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/build-ideal-tree.js"],"sourcesContent":["// mixin implementing the buildIdealTree method\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst rpj = require('read-package-json-fast')\nconst npa = require('npm-package-arg')\nconst pacote = require('pacote')\nconst cacache = require('cacache')\nconst promiseCallLimit = require('promise-call-limit')\nconst realpath = require('../../lib/realpath.js')\nconst { resolve, dirname } = require('path')\nconst { promisify } = require('util')\nconst treeCheck = require('../tree-check.js')\nconst readdir = promisify(require('readdir-scoped-modules'))\nconst fs = require('fs')\nconst lstat = promisify(fs.lstat)\nconst readlink = promisify(fs.readlink)\nconst { depth } = require('treeverse')\n\nconst {\n  OK,\n  REPLACE,\n  CONFLICT,\n} = require('../can-place-dep.js')\nconst PlaceDep = require('../place-dep.js')\n\nconst debug = require('../debug.js')\nconst fromPath = require('../from-path.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst addRmPkgDeps = require('../add-rm-pkg-deps.js')\nconst optionalSet = require('../optional-set.js')\nconst {checkEngine, checkPlatform} = require('npm-install-checks')\n\nconst relpath = require('../relpath.js')\n\n// note: some of these symbols are shared so we can hit\n// them with unit tests and reuse them across mixins\nconst _complete = Symbol('complete')\nconst _depsSeen = Symbol('depsSeen')\nconst _depsQueue = Symbol('depsQueue')\nconst _currentDep = Symbol('currentDep')\nconst _updateAll = Symbol('updateAll')\nconst _mutateTree = Symbol('mutateTree')\nconst _flagsSuspect = Symbol.for('flagsSuspect')\nconst _workspaces = Symbol.for('workspaces')\nconst _prune = Symbol('prune')\nconst _preferDedupe = Symbol('preferDedupe')\nconst _legacyBundling = Symbol('legacyBundling')\nconst _parseSettings = Symbol('parseSettings')\nconst _initTree = Symbol('initTree')\nconst _applyUserRequests = Symbol('applyUserRequests')\nconst _applyUserRequestsToNode = Symbol('applyUserRequestsToNode')\nconst _inflateAncientLockfile = Symbol('inflateAncientLockfile')\nconst _buildDeps = Symbol('buildDeps')\nconst _buildDepStep = Symbol('buildDepStep')\nconst _nodeFromEdge = Symbol('nodeFromEdge')\nconst _nodeFromSpec = Symbol('nodeFromSpec')\nconst _fetchManifest = Symbol('fetchManifest')\nconst _problemEdges = Symbol('problemEdges')\nconst _manifests = Symbol('manifests')\nconst _loadWorkspaces = Symbol.for('loadWorkspaces')\nconst _linkFromSpec = Symbol('linkFromSpec')\nconst _loadPeerSet = Symbol('loadPeerSet')\nconst _updateNames = Symbol.for('updateNames')\nconst _fixDepFlags = Symbol('fixDepFlags')\nconst _resolveLinks = Symbol('resolveLinks')\nconst _rootNodeFromPackage = Symbol('rootNodeFromPackage')\nconst _add = Symbol('add')\nconst _resolvedAdd = Symbol.for('resolvedAdd')\nconst _queueNamedUpdates = Symbol('queueNamedUpdates')\nconst _queueVulnDependents = Symbol('queueVulnDependents')\nconst _avoidRange = Symbol('avoidRange')\nconst _shouldUpdateNode = Symbol('shouldUpdateNode')\nconst resetDepFlags = require('../reset-dep-flags.js')\nconst _loadFailures = Symbol('loadFailures')\nconst _pruneFailedOptional = Symbol('pruneFailedOptional')\nconst _linkNodes = Symbol('linkNodes')\nconst _follow = Symbol('follow')\nconst _globalStyle = Symbol('globalStyle')\nconst _globalRootNode = Symbol('globalRootNode')\nconst _isVulnerable = Symbol.for('isVulnerable')\nconst _usePackageLock = Symbol.for('usePackageLock')\nconst _rpcache = Symbol.for('realpathCache')\nconst _stcache = Symbol.for('statCache')\nconst _updateFilePath = Symbol('updateFilePath')\nconst _followSymlinkPath = Symbol('followSymlinkPath')\nconst _getRelpathSpec = Symbol('getRelpathSpec')\nconst _retrieveSpecName = Symbol('retrieveSpecName')\nconst _strictPeerDeps = Symbol('strictPeerDeps')\nconst _checkEngineAndPlatform = Symbol('checkEngineAndPlatform')\nconst _checkEngine = Symbol('checkEngine')\nconst _checkPlatform = Symbol('checkPlatform')\nconst _virtualRoots = Symbol('virtualRoots')\nconst _virtualRoot = Symbol('virtualRoot')\n\nconst _failPeerConflict = Symbol('failPeerConflict')\nconst _explainPeerConflict = Symbol('explainPeerConflict')\nconst _edgesOverridden = Symbol('edgesOverridden')\n// exposed symbol for unit testing the placeDep method directly\nconst _peerSetSource = Symbol.for('peerSetSource')\n\n// used by Reify mixin\nconst _force = Symbol.for('force')\nconst _explicitRequests = Symbol('explicitRequests')\nconst _global = Symbol.for('global')\nconst _idealTreePrune = Symbol.for('idealTreePrune')\n\nmodule.exports = cls => class IdealTreeBuilder extends cls {\n  constructor (options) {\n    super(options)\n\n    // normalize trailing slash\n    const registry = options.registry || 'https://registry.npmjs.org'\n    options.registry = this.registry = registry.replace(/\\/+$/, '') + '/'\n\n    const {\n      idealTree = null,\n      global = false,\n      follow = false,\n      globalStyle = false,\n      legacyPeerDeps = false,\n      force = false,\n      packageLock = true,\n      strictPeerDeps = false,\n      workspaces = [],\n    } = options\n\n    this[_workspaces] = workspaces || []\n    this[_force] = !!force\n    this[_strictPeerDeps] = !!strictPeerDeps\n\n    this.idealTree = idealTree\n    this.legacyPeerDeps = legacyPeerDeps\n\n    this[_usePackageLock] = packageLock\n    this[_global] = !!global\n    this[_globalStyle] = this[_global] || globalStyle\n    this[_follow] = !!follow\n\n    if (this[_workspaces].length && this[_global]) {\n      throw new Error('Cannot operate on workspaces in global mode')\n    }\n\n    this[_explicitRequests] = new Set()\n    this[_preferDedupe] = false\n    this[_legacyBundling] = false\n    this[_depsSeen] = new Set()\n    this[_depsQueue] = []\n    this[_currentDep] = null\n    this[_updateNames] = []\n    this[_updateAll] = false\n    this[_mutateTree] = false\n    this[_loadFailures] = new Set()\n    this[_linkNodes] = new Set()\n    this[_manifests] = new Map()\n    this[_edgesOverridden] = new Set()\n    this[_resolvedAdd] = []\n\n    // a map of each module in a peer set to the thing that depended on\n    // that set of peers in the first place.  Use a WeakMap so that we\n    // don't hold onto references for nodes that are garbage collected.\n    this[_peerSetSource] = new WeakMap()\n    this[_virtualRoots] = new Map()\n  }\n\n  get explicitRequests () {\n    return new Set(this[_explicitRequests])\n  }\n\n  // public method\n  async buildIdealTree (options = {}) {\n    if (this.idealTree) {\n      return Promise.resolve(this.idealTree)\n    }\n\n    // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n    options = { ...this.options, ...options }\n\n    // an empty array or any falsey value is the same as null\n    if (!options.add || options.add.length === 0) {\n      options.add = null\n    }\n    if (!options.rm || options.rm.length === 0) {\n      options.rm = null\n    }\n\n    process.emit('time', 'idealTree')\n\n    if (!options.add && !options.rm && !options.update && this[_global]) {\n      const er = new Error('global requires add, rm, or update option')\n      return Promise.reject(er)\n    }\n\n    // first get the virtual tree, if possible.  If there's a lockfile, then\n    // that defines the ideal tree, unless the root package.json is not\n    // satisfied by what the ideal tree provides.\n    // from there, we start adding nodes to it to satisfy the deps requested\n    // by the package.json in the root.\n\n    this[_parseSettings](options)\n\n    // start tracker block\n    this.addTracker('idealTree')\n\n    try {\n      await this[_initTree]()\n      await this[_inflateAncientLockfile]()\n      await this[_applyUserRequests](options)\n      await this[_buildDeps]()\n      await this[_fixDepFlags]()\n      await this[_pruneFailedOptional]()\n      await this[_checkEngineAndPlatform]()\n    } finally {\n      process.emit('timeEnd', 'idealTree')\n      this.finishTracker('idealTree')\n    }\n\n    return treeCheck(this.idealTree)\n  }\n\n  async [_checkEngineAndPlatform] () {\n    for (const node of this.idealTree.inventory.values()) {\n      if (!node.optional) {\n        this[_checkEngine](node)\n        this[_checkPlatform](node)\n      }\n    }\n  }\n\n  [_checkPlatform] (node) {\n    checkPlatform(node.package, this[_force])\n  }\n\n  [_checkEngine] (node) {\n    const { engineStrict, npmVersion, nodeVersion } = this.options\n    const c = () =>\n      checkEngine(node.package, npmVersion, nodeVersion, this[_force])\n\n    if (engineStrict) {\n      c()\n    } else {\n      try {\n        c()\n      } catch (er) {\n        this.log.warn(er.code, er.message, {\n          package: er.pkgid,\n          required: er.required,\n          current: er.current,\n        })\n      }\n    }\n  }\n\n  [_parseSettings] (options) {\n    const update = options.update === true ? { all: true }\n      : Array.isArray(options.update) ? { names: options.update }\n      : options.update || {}\n\n    if (update.all || !Array.isArray(update.names)) {\n      update.names = []\n    }\n\n    this[_complete] = !!options.complete\n    this[_preferDedupe] = !!options.preferDedupe\n    this[_legacyBundling] = !!options.legacyBundling\n    this[_updateNames] = update.names\n\n    this[_updateAll] = update.all\n    // we prune by default unless explicitly set to boolean false\n    this[_prune] = options.prune !== false\n\n    // set if we add anything, but also set here if we know we'll make\n    // changes and thus have to maybe prune later.\n    this[_mutateTree] = !!(\n      options.add ||\n      options.rm ||\n      update.all ||\n      update.names.length\n    )\n  }\n\n  // load the initial tree, either the virtualTree from a shrinkwrap,\n  // or just the root node from a package.json\n  [_initTree] () {\n    process.emit('time', 'idealTree:init')\n    return (\n      this[_global] ? this[_globalRootNode]()\n      : rpj(this.path + '/package.json').then(\n        pkg => this[_rootNodeFromPackage](pkg),\n        er => {\n          if (er.code === 'EJSONPARSE') {\n            throw er\n          }\n          return this[_rootNodeFromPackage]({})\n        }\n      ))\n      .then(root => this[_loadWorkspaces](root))\n      // ok to not have a virtual tree.  probably initial install.\n      // When updating all, we load the shrinkwrap, but don't bother\n      // to build out the full virtual tree from it, since we'll be\n      // reconstructing it anyway.\n      .then(root => this[_global] ? root\n      : !this[_usePackageLock] || this[_updateAll]\n        ? Shrinkwrap.reset({ path: this.path })\n          .then(meta => Object.assign(root, {meta}))\n        : this.loadVirtual({ root }))\n\n      // if we don't have a lockfile to go from, then start with the\n      // actual tree, so we only make the minimum required changes.\n      // don't do this for global installs or updates, because in those\n      // cases we don't use a lockfile anyway.\n      // Load on a new Arborist object, so the Nodes aren't the same,\n      // or else it'll get super confusing when we change them!\n      .then(async root => {\n        if (!this[_updateAll] && !this[_global] && !root.meta.loadedFromDisk) {\n          await new this.constructor(this.options).loadActual({ root })\n          const tree = root.target\n          // even though we didn't load it from a package-lock.json FILE,\n          // we still loaded it \"from disk\", meaning we have to reset\n          // dep flags before assuming that any mutations were reflected.\n          if (tree.children.size) {\n            root.meta.loadedFromDisk = true\n          }\n        }\n        return root\n      })\n\n      .then(tree => {\n        // null the virtual tree, because we're about to hack away at it\n        // if you want another one, load another copy.\n        this.idealTree = tree\n        this.virtualTree = null\n        process.emit('timeEnd', 'idealTree:init')\n      })\n  }\n\n  async [_globalRootNode] () {\n    const root = await this[_rootNodeFromPackage]({ dependencies: {} })\n    // this is a gross kludge to handle the fact that we don't save\n    // metadata on the root node in global installs, because the \"root\"\n    // node is something like /usr/local/lib.\n    const meta = new Shrinkwrap({ path: this.path })\n    meta.reset()\n    root.meta = meta\n    return root\n  }\n\n  async [_rootNodeFromPackage] (pkg) {\n    // if the path doesn't exist, then we explode at this point. Note that\n    // this is not a problem for reify(), since it creates the root path\n    // before ever loading trees.\n    // TODO: make buildIdealTree() and loadActual handle a missing root path,\n    // or a symlink to a missing target, and let reify() create it as needed.\n    const real = await realpath(this.path, this[_rpcache], this[_stcache])\n    const Cls = real === this.path ? Node : Link\n    const root = new Cls({\n      path: this.path,\n      realpath: real,\n      pkg,\n      extraneous: false,\n      dev: false,\n      devOptional: false,\n      peer: false,\n      optional: false,\n      global: this[_global],\n      legacyPeerDeps: this.legacyPeerDeps,\n    })\n    if (root.isLink) {\n      root.target = new Node({\n        path: real,\n        realpath: real,\n        pkg,\n        extraneous: false,\n        dev: false,\n        devOptional: false,\n        peer: false,\n        optional: false,\n        global: this[_global],\n        legacyPeerDeps: this.legacyPeerDeps,\n        root,\n      })\n    }\n    return root\n  }\n\n  // process the add/rm requests by modifying the root node, and the\n  // update.names request by queueing nodes dependent on those named.\n  async [_applyUserRequests] (options) {\n    process.emit('time', 'idealTree:userRequests')\n    const tree = this.idealTree.target\n\n    if (!this[_workspaces].length) {\n      await this[_applyUserRequestsToNode](tree, options)\n    } else {\n      await Promise.all(this.workspaceNodes(tree, this[_workspaces])\n        .map(node => this[_applyUserRequestsToNode](node, options)))\n    }\n\n    process.emit('timeEnd', 'idealTree:userRequests')\n  }\n\n  async [_applyUserRequestsToNode] (tree, options) {\n    // If we have a list of package names to update, and we know it's\n    // going to update them wherever they are, add any paths into those\n    // named nodes to the buildIdealTree queue.\n    if (!this[_global] && this[_updateNames].length) {\n      this[_queueNamedUpdates]()\n    }\n\n    // global updates only update the globalTop nodes, but we need to know\n    // that they're there, and not reinstall the world unnecessarily.\n    const globalExplicitUpdateNames = []\n    if (this[_global] && (this[_updateAll] || this[_updateNames].length)) {\n      const nm = resolve(this.path, 'node_modules')\n      for (const name of await readdir(nm).catch(() => [])) {\n        tree.package.dependencies = tree.package.dependencies || {}\n        const updateName = this[_updateNames].includes(name)\n        if (this[_updateAll] || updateName) {\n          if (updateName) {\n            globalExplicitUpdateNames.push(name)\n          }\n          const dir = resolve(nm, name)\n          const st = await lstat(dir)\n            .catch(/* istanbul ignore next */ er => null)\n          if (st && st.isSymbolicLink()) {\n            const target = await readlink(dir)\n            const real = resolve(dirname(dir), target)\n            tree.package.dependencies[name] = `file:${real}`\n          } else {\n            tree.package.dependencies[name] = '*'\n          }\n        }\n      }\n    }\n\n    if (this.auditReport && this.auditReport.size > 0) {\n      await this[_queueVulnDependents](options)\n    }\n\n    const { add, rm } = options\n\n    if (rm && rm.length) {\n      addRmPkgDeps.rm(tree.package, rm)\n      for (const name of rm) {\n        this[_explicitRequests].add({ from: tree, name, action: 'DELETE' })\n      }\n    }\n\n    if (add && add.length) {\n      await this[_add](tree, options)\n    }\n\n    // triggers a refresh of all edgesOut.  this has to be done BEFORE\n    // adding the edges to explicitRequests, because the package setter\n    // resets all edgesOut.\n    if (add && add.length || rm && rm.length || this[_global]) {\n      tree.package = tree.package\n    }\n\n    for (const spec of this[_resolvedAdd]) {\n      if (spec.tree === tree) {\n        this[_explicitRequests].add(tree.edgesOut.get(spec.name))\n      }\n    }\n    for (const name of globalExplicitUpdateNames) {\n      this[_explicitRequests].add(tree.edgesOut.get(name))\n    }\n\n    this[_depsQueue].push(tree)\n  }\n\n  // This returns a promise because we might not have the name yet,\n  // and need to call pacote.manifest to find the name.\n  [_add] (tree, {add, saveType = null, saveBundle = false}) {\n    // get the name for each of the specs in the list.\n    // ie, doing `foo@bar` we just return foo\n    // but if it's a url or git, we don't know the name until we\n    // fetch it and look in its manifest.\n    return Promise.all(add.map(async rawSpec => {\n      // We do NOT provide the path to npa here, because user-additions\n      // need to be resolved relative to the CWD the user is in.\n      const spec = await this[_retrieveSpecName](npa(rawSpec))\n        .then(spec => this[_updateFilePath](spec))\n        .then(spec => this[_followSymlinkPath](spec))\n      spec.tree = tree\n      return spec\n    })).then(add => {\n      this[_resolvedAdd].push(...add)\n      // now add is a list of spec objects with names.\n      // find a home for each of them!\n      addRmPkgDeps.add({\n        pkg: tree.package,\n        add,\n        saveBundle,\n        saveType,\n        path: this.path,\n        log: this.log,\n      })\n    })\n  }\n\n  async [_retrieveSpecName] (spec) {\n    // if it's just @'' then we reload whatever's there, or get latest\n    // if it's an explicit tag, we need to install that specific tag version\n    const isTag = spec.rawSpec && spec.type === 'tag'\n\n    if (spec.name && !isTag) {\n      return spec\n    }\n\n    const mani = await pacote.manifest(spec, { ...this.options })\n    // if it's a tag type, then we need to run it down to an actual version\n    if (isTag) {\n      return npa(`${mani.name}@${mani.version}`)\n    }\n\n    spec.name = mani.name\n    return spec\n  }\n\n  async [_updateFilePath] (spec) {\n    if (spec.type === 'file') {\n      return this[_getRelpathSpec](spec, spec.fetchSpec)\n    }\n\n    return spec\n  }\n\n  async [_followSymlinkPath] (spec) {\n    if (spec.type === 'directory') {\n      const real = await (\n        realpath(spec.fetchSpec, this[_rpcache], this[_stcache])\n          // TODO: create synthetic test case to simulate realpath failure\n          .catch(/* istanbul ignore next */() => null)\n      )\n\n      return this[_getRelpathSpec](spec, real)\n    }\n    return spec\n  }\n\n  [_getRelpathSpec] (spec, filepath) {\n    /* istanbul ignore else - should also be covered by realpath failure */\n    if (filepath) {\n      const { name } = spec\n      const tree = this.idealTree.target\n      spec = npa(`file:${relpath(tree.path, filepath)}`, tree.path)\n      spec.name = name\n    }\n    return spec\n  }\n\n  // TODO: provide a way to fix bundled deps by exposing metadata about\n  // what's in the bundle at each published manifest.  Without that, we\n  // can't possibly fix bundled deps without breaking a ton of other stuff,\n  // and leaving the user subject to getting it overwritten later anyway.\n  async [_queueVulnDependents] (options) {\n    for (const vuln of this.auditReport.values()) {\n      for (const node of vuln.nodes) {\n        const bundler = node.getBundler()\n\n        // XXX this belongs in the audit report itself, not here.\n        // We shouldn't even get these things here, and they shouldn't\n        // be printed by npm-audit-report as if they can be fixed, because\n        // they can't.\n        if (bundler) {\n          this.log.warn(`audit fix ${node.name}@${node.version}`,\n            `${node.location}\\nis a bundled dependency of\\n${\n            bundler.name}@${bundler.version} at ${bundler.location}\\n` +\n            'It cannot be fixed automatically.\\n' +\n            `Check for updates to the ${bundler.name} package.`)\n          continue\n        }\n\n        for (const edge of node.edgesIn) {\n          this.addTracker('idealTree', edge.from.name, edge.from.location)\n          this[_depsQueue].push(edge.from)\n        }\n      }\n    }\n\n    // note any that can't be fixed at the root level without --force\n    // if there's a fix, we use that.  otherwise, the user has to remove it,\n    // find a different thing, fix the upstream, etc.\n    //\n    // XXX: how to handle top nodes that aren't the root?  Maybe the report\n    // just tells the user to cd into that directory and fix it?\n    if (this[_force] && this.auditReport && this.auditReport.topVulns.size) {\n      options.add = options.add || []\n      options.rm = options.rm || []\n      const nodesTouched = new Set()\n      for (const [name, topVuln] of this.auditReport.topVulns.entries()) {\n        const {\n          simpleRange,\n          topNodes,\n          fixAvailable,\n        } = topVuln\n        for (const node of topNodes) {\n          if (!node.isProjectRoot && !node.isWorkspace) {\n            // not something we're going to fix, sorry.  have to cd into\n            // that directory and fix it yourself.\n            this.log.warn('audit', 'Manual fix required in linked project ' +\n              `at ./${node.location} for ${name}@${simpleRange}.\\n` +\n              `'cd ./${node.location}' and run 'npm audit' for details.`)\n            continue\n          }\n\n          if (!fixAvailable) {\n            this.log.warn('audit', `No fix available for ${name}@${simpleRange}`)\n            continue\n          }\n\n          const { isSemVerMajor, version } = fixAvailable\n          const breakingMessage = isSemVerMajor\n            ? 'a SemVer major change'\n            : 'outside your stated dependency range'\n          this.log.warn('audit', `Updating ${name} to ${version},` +\n            `which is ${breakingMessage}.`)\n\n          await this[_add](node, { add: [`${name}@${version}`] })\n          nodesTouched.add(node)\n        }\n      }\n      for (const node of nodesTouched) {\n        node.package = node.package\n      }\n    }\n  }\n\n  [_isVulnerable] (node) {\n    return this.auditReport && this.auditReport.isVulnerable(node)\n  }\n\n  [_avoidRange] (name) {\n    if (!this.auditReport) {\n      return null\n    }\n    const vuln = this.auditReport.get(name)\n    if (!vuln) {\n      return null\n    }\n    return vuln.range\n  }\n\n  [_queueNamedUpdates] () {\n    // ignore top nodes, since they are not loaded the same way, and\n    // probably have their own project associated with them.\n\n    // for every node with one of the names on the list, we add its\n    // dependents to the queue to be evaluated.  in buildDepStep,\n    // anything on the update names list will get refreshed, even if\n    // it isn't a problem.\n\n    // XXX this could be faster by doing a series of inventory.query('name')\n    // calls rather than walking over everything in the tree.\n    const set = this.idealTree.inventory\n      .filter(n => this[_shouldUpdateNode](n))\n    for (const node of set) {\n      for (const edge of node.edgesIn) {\n        this.addTracker('idealTree', edge.from.name, edge.from.location)\n        this[_depsQueue].push(edge.from)\n      }\n    }\n  }\n\n  [_shouldUpdateNode] (node) {\n    return this[_updateNames].includes(node.name) &&\n      !node.isTop &&\n      !node.inDepBundle &&\n      !node.inShrinkwrap\n  }\n\n  async [_inflateAncientLockfile] () {\n    const { meta, inventory } = this.idealTree\n    const ancient = meta.ancientLockfile\n    const old = meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2)\n\n    if (inventory.size === 0 || !ancient && !old) {\n      return\n    }\n\n    // if the lockfile is from node v5 or earlier, then we'll have to reload\n    // all the manifests of everything we encounter.  this is costly, but at\n    // least it's just a one-time hit.\n    process.emit('time', 'idealTree:inflate')\n\n    const heading = ancient ? 'ancient lockfile' : 'old lockfile'\n    this.log.warn(heading,\n      `\nThe ${meta.type} file was created with an old version of npm,\nso supplemental metadata must be fetched from the registry.\n\nThis is a one-time fix-up, please be patient...\n`)\n\n    this.addTracker('idealTree:inflate')\n    const queue = []\n    for (const node of inventory.values()) {\n      if (node.isProjectRoot) {\n        continue\n      }\n\n      queue.push(async () => {\n        this.log.silly('inflate', node.location)\n        const { resolved, version, path, name, location, integrity } = node\n        // don't try to hit the registry for linked deps\n        const useResolved = resolved && (\n          !version || resolved.startsWith('file:')\n        )\n        const id = useResolved ? resolved\n          : version || `file:${node.path}`\n        const spec = npa.resolve(name, id, dirname(path))\n        const sloc = location.substr('node_modules/'.length)\n        const t = `idealTree:inflate:${sloc}`\n        this.addTracker(t)\n        await pacote.manifest(spec, {\n          ...this.options,\n          resolved: resolved,\n          integrity: integrity,\n          fullMetadata: false,\n        }).then(mani => {\n          node.package = { ...mani, _id: `${mani.name}@${mani.version}` }\n        }).catch((er) => {\n          const warning = `Could not fetch metadata for ${name}@${id}`\n          this.log.warn(heading, warning, er)\n        })\n        this.finishTracker(t)\n      })\n    }\n    await promiseCallLimit(queue)\n\n    // have to re-calc dep flags, because the nodes don't have edges\n    // until their packages get assigned, so everything looks extraneous\n    calcDepFlags(this.idealTree)\n\n    // yes, yes, this isn't the \"original\" version, but now that it's been\n    // upgraded, we need to make sure we don't do the work to upgrade it\n    // again, since it's now as new as can be.\n    meta.originalLockfileVersion = 2\n    this.finishTracker('idealTree:inflate')\n    process.emit('timeEnd', 'idealTree:inflate')\n  }\n\n  // at this point we have a virtual tree with the actual root node's\n  // package deps, which may be partly or entirely incomplete, invalid\n  // or extraneous.\n  [_buildDeps] () {\n    process.emit('time', 'idealTree:buildDeps')\n    const tree = this.idealTree.target\n    this[_depsQueue].push(tree)\n    this.log.silly('idealTree', 'buildDeps')\n    this.addTracker('idealTree', tree.name, '')\n    return this[_buildDepStep]()\n      .then(() => process.emit('timeEnd', 'idealTree:buildDeps'))\n  }\n\n  async [_buildDepStep] () {\n    // removes tracker of previous dependency in the queue\n    if (this[_currentDep]) {\n      const { location, name } = this[_currentDep]\n      process.emit('timeEnd', `idealTree:${location || '#root'}`)\n      this.finishTracker('idealTree', name, location)\n      this[_currentDep] = null\n    }\n\n    if (!this[_depsQueue].length) {\n      return this[_resolveLinks]()\n    }\n\n    // sort physically shallower deps up to the front of the queue,\n    // because they'll affect things deeper in, then alphabetical\n    this[_depsQueue].sort((a, b) =>\n      (a.depth - b.depth) || localeCompare(a.path, b.path))\n\n    const node = this[_depsQueue].shift()\n    const bd = node.package.bundleDependencies\n    const hasBundle = bd && Array.isArray(bd) && bd.length\n    const { hasShrinkwrap } = node\n\n    // if the node was already visited, or has since been removed from the\n    // tree, skip over it and process the rest of the queue.  If a node has\n    // a shrinkwrap, also skip it, because it's going to get its deps\n    // satisfied by whatever's in that file anyway.\n    if (this[_depsSeen].has(node) ||\n        node.root !== this.idealTree ||\n        hasShrinkwrap && !this[_complete]) {\n      return this[_buildDepStep]()\n    }\n\n    this[_depsSeen].add(node)\n    this[_currentDep] = node\n    process.emit('time', `idealTree:${node.location || '#root'}`)\n\n    // if we're loading a _complete_ ideal tree, for a --package-lock-only\n    // installation for example, we have to crack open the tarball and\n    // look inside if it has bundle deps or shrinkwraps.  note that this is\n    // not necessary during a reification, because we just update the\n    // ideal tree by reading bundles/shrinkwraps in place.\n    // Don't bother if the node is from the actual tree and hasn't\n    // been resolved, because we can't fetch it anyway, could be anything!\n    const crackOpen = this[_complete] &&\n      node !== this.idealTree &&\n      node.resolved &&\n      (hasBundle || hasShrinkwrap)\n    if (crackOpen) {\n      const Arborist = this.constructor\n      const opt = { ...this.options }\n      await cacache.tmp.withTmp(this.cache, opt, async path => {\n        await pacote.extract(node.resolved, path, {\n          ...opt,\n          resolved: node.resolved,\n          integrity: node.integrity,\n        })\n\n        if (hasShrinkwrap) {\n          await new Arborist({ ...this.options, path })\n            .loadVirtual({ root: node })\n        }\n\n        if (hasBundle) {\n          await new Arborist({ ...this.options, path })\n            .loadActual({ root: node, ignoreMissing: true })\n        }\n      })\n    }\n\n    // if any deps are missing or invalid, then we fetch the manifest for\n    // the thing we want, and build a new dep node from that.\n    // Then, find the ideal placement for that node.  The ideal placement\n    // searches from the node's deps (or parent deps in the case of non-root\n    // peer deps), and walks up the tree until it finds the highest spot\n    // where it doesn't cause any conflicts.\n    //\n    // A conflict can be:\n    // - A node by that name already exists at that location.\n    // - The parent has a peer dep on that name\n    // - One of the node's peer deps conflicts at that location, unless the\n    //   peer dep is met by a node at that location, which is fine.\n    //\n    // If we create a new node, then build its ideal deps as well.\n    //\n    // Note: this is the same \"maximally naive\" deduping tree-building\n    // algorithm that npm has used since v3.  In a case like this:\n    //\n    // root -> (a@1, b@1||2)\n    // a -> (b@1)\n    //\n    // You'll end up with a tree like this:\n    //\n    // root\n    // +-- a@1\n    // |   +-- b@1\n    // +-- b@2\n    //\n    // rather than this, more deduped, but just as correct tree:\n    //\n    // root\n    // +-- a@1\n    // +-- b@1\n    //\n    // Another way to look at it is that this algorithm favors getting higher\n    // version deps at higher levels in the tree, even if that reduces\n    // potential deduplication.\n    //\n    // Set `preferDedupe: true` in the options to replace the shallower\n    // dep if allowed.\n\n    const tasks = []\n    const peerSource = this[_peerSetSource].get(node) || node\n    for (const edge of this[_problemEdges](node)) {\n      if (edge.overridden) {\n        continue\n      }\n\n      // peerSetSource is only relevant when we have a peerEntryEdge\n      // otherwise we're setting regular non-peer deps as if they have\n      // a virtual root of whatever brought in THIS node.\n      // so we VR the node itself if the edge is not a peer\n      const source = edge.peer ? peerSource : node\n\n      const virtualRoot = this[_virtualRoot](source, true)\n      // reuse virtual root if we already have one, but don't\n      // try to do the override ahead of time, since we MAY be able\n      // to create a more correct tree than the virtual root could.\n      const vrEdge = virtualRoot && virtualRoot.edgesOut.get(edge.name)\n      const vrDep = vrEdge && vrEdge.valid && vrEdge.to\n      // only re-use the virtualRoot if it's a peer edge we're placing.\n      // otherwise, we end up in situations where we override peer deps that\n      // we could have otherwise found homes for.  Eg:\n      // xy -> (x, y)\n      // x -> PEER(z@1)\n      // y -> PEER(z@2)\n      // If xy is a dependency, we can resolve this like:\n      // project\n      // +-- xy\n      // |   +-- y\n      // |   +-- z@2\n      // +-- x\n      // +-- z@1\n      // But if x and y are loaded in the same virtual root, then they will\n      // be forced to agree on a version of z.\n      const required = new Set([edge.from])\n      const parent = edge.peer ? virtualRoot : null\n      const dep = vrDep && vrDep.satisfies(edge) ? vrDep\n        : await this[_nodeFromEdge](edge, parent, null, required)\n\n      /* istanbul ignore next */\n      debug(() => {\n        if (!dep) {\n          throw new Error('no dep??')\n        }\n      })\n\n      tasks.push({edge, dep})\n    }\n\n    const placeDeps = tasks\n      .sort((a, b) => localeCompare(a.edge.name, b.edge.name))\n      .map(({ edge, dep }) => new PlaceDep({\n        edge,\n        dep,\n\n        explicitRequest: this[_explicitRequests].has(edge),\n        updateNames: this[_updateNames],\n        auditReport: this.auditReport,\n        force: this[_force],\n        preferDedupe: this[_preferDedupe],\n        legacyBundling: this[_legacyBundling],\n        strictPeerDeps: this[_strictPeerDeps],\n        legacyPeerDeps: this.legacyPeerDeps,\n        globalStyle: this[_globalStyle],\n      }))\n\n    const promises = []\n    for (const pd of placeDeps) {\n      // placing a dep is actually a tree of placing the dep itself\n      // and all of its peer group that aren't already met by the tree\n      depth({\n        tree: pd,\n        getChildren: pd => pd.children,\n        visit: pd => {\n          const { placed, edge, canPlace: cpd } = pd\n          // if we didn't place anything, nothing to do here\n          if (!placed) {\n            return\n          }\n\n          // we placed something, that means we changed the tree\n          if (placed.errors.length) {\n            this[_loadFailures].add(placed)\n          }\n          this[_mutateTree] = true\n          if (cpd.canPlaceSelf === OK) {\n            for (const edgeIn of placed.edgesIn) {\n              if (edgeIn === edge) {\n                continue\n              }\n              const { from, valid, overridden } = edgeIn\n              if (!overridden && !valid && !this[_depsSeen].has(from)) {\n                this.addTracker('idealTree', from.name, from.location)\n                this[_depsQueue].push(edgeIn.from)\n              }\n            }\n          } else {\n            /* istanbul ignore else - should be only OK or REPLACE here */\n            if (cpd.canPlaceSelf === REPLACE) {\n              // this may also create some invalid edges, for example if we're\n              // intentionally causing something to get nested which was\n              // previously placed in this location.\n              for (const edgeIn of placed.edgesIn) {\n                if (edgeIn === edge) {\n                  continue\n                }\n\n                const { valid, overridden } = edgeIn\n                if (!valid && !overridden) {\n                  // if it's already been visited, we have to re-visit\n                  // otherwise, just enqueue normally.\n                  this[_depsSeen].delete(edgeIn.from)\n                  this[_depsQueue].push(edgeIn.from)\n                }\n              }\n            }\n          }\n\n          /* istanbul ignore if - should be impossible */\n          if (cpd.canPlaceSelf === CONFLICT) {\n            debug(() => {\n              const er = new Error('placed with canPlaceSelf=CONFLICT')\n              throw Object.assign(er, { placeDep: pd })\n            })\n            return\n          }\n\n          // lastly, also check for the missing deps of the node we placed,\n          // and any holes created by pruning out conflicted peer sets.\n          this[_depsQueue].push(placed)\n          for (const dep of pd.needEvaluation) {\n            this[_depsSeen].delete(dep)\n            this[_depsQueue].push(dep)\n          }\n\n          // pre-fetch any problem edges, since we'll need these soon\n          // if it fails at this point, though, dont' worry because it\n          // may well be an optional dep that has gone missing.  it'll\n          // fail later anyway.\n          const from = fromPath(placed)\n          promises.push(...this[_problemEdges](placed).map(e =>\n            this[_fetchManifest](npa.resolve(e.name, e.spec, from))\n              .catch(er => null)))\n        },\n      })\n    }\n\n    for (const { to } of node.edgesOut.values()) {\n      if (to && to.isLink && to.target) {\n        this[_linkNodes].add(to)\n      }\n    }\n\n    await Promise.all(promises)\n    return this[_buildDepStep]()\n  }\n\n  // loads a node from an edge, and then loads its peer deps (and their\n  // peer deps, on down the line) into a virtual root parent.\n  async [_nodeFromEdge] (edge, parent_, secondEdge, required) {\n    // create a virtual root node with the same deps as the node that\n    // is requesting this one, so that we can get all the peer deps in\n    // a context where they're likely to be resolvable.\n    // Note that the virtual root will also have virtual copies of the\n    // targets of any child Links, so that they resolve appropriately.\n    const parent = parent_ || this[_virtualRoot](edge.from)\n\n    const spec = npa.resolve(edge.name, edge.spec, edge.from.path)\n    const first = await this[_nodeFromSpec](edge.name, spec, parent, edge)\n\n    // we might have a case where the parent has a peer dependency on\n    // `foo@*` which resolves to v2, but another dep in the set has a\n    // peerDependency on `foo@1`.  In that case, if we force it to be v2,\n    // we're unnecessarily triggering an ERESOLVE.\n    // If we have a second edge to worry about, and it's not satisfied\n    // by the first node, try a second and see if that satisfies the\n    // original edge here.\n    const spec2 = secondEdge && npa.resolve(\n      edge.name,\n      secondEdge.spec,\n      secondEdge.from.path\n    )\n    const second = secondEdge && !secondEdge.valid\n      ? await this[_nodeFromSpec](edge.name, spec2, parent, secondEdge)\n      : null\n\n    // pick the second one if they're both happy with that, otherwise first\n    const node = second && edge.valid ? second : first\n    // ensure the one we want is the one that's placed\n    node.parent = parent\n\n    if (required.has(edge.from) && edge.type !== 'peerOptional' ||\n        secondEdge && (\n          required.has(secondEdge.from) && secondEdge.type !== 'peerOptional')) {\n      required.add(node)\n    }\n\n    // keep track of the thing that caused this node to be included.\n    const src = parent.sourceReference\n    this[_peerSetSource].set(node, src)\n\n    // do not load the peers along with the set if this is a global top pkg\n    // otherwise we'll be tempted to put peers as other top-level installed\n    // things, potentially clobbering what's there already, which is not\n    // what we want.  the missing edges will be picked up on the next pass.\n    if (this[_global] && edge.from.isProjectRoot) {\n      return node\n    }\n\n    // otherwise, we have to make sure that our peers can go along with us.\n    return this[_loadPeerSet](node, required)\n  }\n\n  [_virtualRoot] (node, reuse = false) {\n    if (reuse && this[_virtualRoots].has(node)) {\n      return this[_virtualRoots].get(node)\n    }\n\n    const vr = new Node({\n      path: node.realpath,\n      sourceReference: node,\n      legacyPeerDeps: this.legacyPeerDeps,\n    })\n\n    // also need to set up any targets from any link deps, so that\n    // they are properly reflected in the virtual environment\n    for (const child of node.children.values()) {\n      if (child.isLink) {\n        new Node({\n          path: child.realpath,\n          sourceReference: child.target,\n          root: vr,\n        })\n      }\n    }\n\n    this[_virtualRoots].set(node, vr)\n    return vr\n  }\n\n  [_problemEdges] (node) {\n    // skip over any bundled deps, they're not our problem.\n    // Note that this WILL fetch bundled meta-deps which are also dependencies\n    // but not listed as bundled deps.  When reifying, we first unpack any\n    // nodes that have bundleDependencies, then do a loadActual on them, move\n    // the nodes into the ideal tree, and then prune.  So, fetching those\n    // possibly-bundled meta-deps at this point doesn't cause any worse\n    // problems than a few unnecessary packument fetches.\n\n    // also skip over any nodes in the tree that failed to load, since those\n    // will crash the install later on anyway.\n    const bd = node.isProjectRoot || node.isWorkspace ? null\n      : node.package.bundleDependencies\n    const bundled = new Set(bd || [])\n\n    return [...node.edgesOut.values()]\n      .filter(edge => {\n        // If it's included in a bundle, we take whatever is specified.\n        if (bundled.has(edge.name)) {\n          return false\n        }\n\n        // If it's already been logged as a load failure, skip it.\n        if (edge.to && this[_loadFailures].has(edge.to)) {\n          return false\n        }\n\n        // If it's shrinkwrapped, we use what the shrinkwap wants.\n        if (edge.to && edge.to.inShrinkwrap) {\n          return false\n        }\n\n        // If the edge has no destination, that's a problem, unless\n        // if it's peerOptional and not explicitly requested.\n        if (!edge.to) {\n          return edge.type !== 'peerOptional' ||\n            this[_explicitRequests].has(edge)\n        }\n\n        // If the edge has an error, there's a problem.\n        if (!edge.valid) {\n          return true\n        }\n\n        // user explicitly asked to update this package by name, problem\n        if (this[_updateNames].includes(edge.name)) {\n          return true\n        }\n\n        // fixing a security vulnerability with this package, problem\n        if (this[_isVulnerable](edge.to)) {\n          return true\n        }\n\n        // user has explicitly asked to install this package, problem\n        if (this[_explicitRequests].has(edge)) {\n          return true\n        }\n\n        // No problems!\n        return false\n      })\n  }\n\n  async [_fetchManifest] (spec) {\n    const options = {\n      ...this.options,\n      avoid: this[_avoidRange](spec.name),\n    }\n    // get the intended spec and stored metadata from yarn.lock file,\n    // if available and valid.\n    spec = this.idealTree.meta.checkYarnLock(spec, options)\n\n    if (this[_manifests].has(spec.raw)) {\n      return this[_manifests].get(spec.raw)\n    } else {\n      this.log.silly('fetch manifest', spec.raw)\n      const p = pacote.manifest(spec, options)\n        .then(mani => {\n          this[_manifests].set(spec.raw, mani)\n          return mani\n        })\n      this[_manifests].set(spec.raw, p)\n      return p\n    }\n  }\n\n  [_nodeFromSpec] (name, spec, parent, edge) {\n    // pacote will slap integrity on its options, so we have to clone\n    // the object so it doesn't get mutated.\n    // Don't bother to load the manifest for link deps, because the target\n    // might be within another package that doesn't exist yet.\n    const { legacyPeerDeps } = this\n    return spec.type === 'directory'\n      ? this[_linkFromSpec](name, spec, parent, edge)\n      : this[_fetchManifest](spec)\n        .then(pkg => new Node({ name, pkg, parent, legacyPeerDeps }), error => {\n          error.requiredBy = edge.from.location || '.'\n\n          // failed to load the spec, either because of enotarget or\n          // fetch failure of some other sort.  save it so we can verify\n          // later that it's optional, otherwise the error is fatal.\n          const n = new Node({\n            name,\n            parent,\n            error,\n            legacyPeerDeps,\n          })\n          this[_loadFailures].add(n)\n          return n\n        })\n  }\n\n  [_linkFromSpec] (name, spec, parent, edge) {\n    const realpath = spec.fetchSpec\n    const { legacyPeerDeps } = this\n    return rpj(realpath + '/package.json').catch(() => ({})).then(pkg => {\n      const link = new Link({ name, parent, realpath, pkg, legacyPeerDeps })\n      this[_linkNodes].add(link)\n      return link\n    })\n  }\n\n  // load all peer deps and meta-peer deps into the node's parent\n  // At the end of this, the node's peer-type outward edges are all\n  // resolved, and so are all of theirs, but other dep types are not.\n  // We prefer to get peer deps that meet the requiring node's dependency,\n  // if possible, since that almost certainly works (since that package was\n  // developed with this set of deps) and will typically be more restrictive.\n  // Note that the peers in the set can conflict either with each other,\n  // or with a direct dependency from the virtual root parent!  In strict\n  // mode, this is always an error.  In force mode, it never is, and we\n  // prefer the parent's non-peer dep over a peer dep, or the version that\n  // gets placed first.  In non-strict mode, we behave strictly if the\n  // virtual root is based on the root project, and allow non-peer parent\n  // deps to override, but throw if no preference can be determined.\n  async [_loadPeerSet] (node, required) {\n    const peerEdges = [...node.edgesOut.values()]\n      // we typically only install non-optional peers, but we have to\n      // factor them into the peerSet so that we can avoid conflicts\n      .filter(e => e.peer && !(e.valid && e.to))\n      .sort(({name: a}, {name: b}) => localeCompare(a, b))\n\n    for (const edge of peerEdges) {\n      // already placed this one, and we're happy with it.\n      if (edge.valid && edge.to) {\n        continue\n      }\n\n      const parentEdge = node.parent.edgesOut.get(edge.name)\n      const {isProjectRoot, isWorkspace} = node.parent.sourceReference\n      const isMine = isProjectRoot || isWorkspace\n      const conflictOK = this[_force] || !isMine && !this[_strictPeerDeps]\n\n      if (!edge.to) {\n        if (!parentEdge) {\n          // easy, just put the thing there\n          await this[_nodeFromEdge](edge, node.parent, null, required)\n          continue\n        } else {\n          // if the parent's edge is very broad like >=1, and the edge in\n          // question is something like 1.x, then we want to get a 1.x, not\n          // a 2.x.  pass along the child edge as an advisory guideline.\n          // if the parent edge doesn't satisfy the child edge, and the\n          // child edge doesn't satisfy the parent edge, then we have\n          // a conflict.  this is always a problem in strict mode, never\n          // in force mode, and a problem in non-strict mode if this isn't\n          // on behalf of our project.  in all such cases, we warn at least.\n          const dep = await this[_nodeFromEdge](\n            parentEdge,\n            node.parent,\n            edge,\n            required\n          )\n\n          // hooray! that worked!\n          if (edge.valid) {\n            continue\n          }\n\n          // allow it.  either we're overriding, or it's not something\n          // that will be installed by default anyway, and we'll fail when\n          // we get to the point where we need to, if we need to.\n          if (conflictOK || !required.has(dep)) {\n            edge.overridden = true\n            continue\n          }\n\n          // problem\n          this[_failPeerConflict](edge, parentEdge)\n        }\n      }\n\n      // There is something present already, and we're not happy about it\n      // See if the thing we WOULD be happy with is also going to satisfy\n      // the other dependents on the current node.\n      const current = edge.to\n      const dep = await this[_nodeFromEdge](edge, null, null, required)\n      if (dep.canReplace(current)) {\n        await this[_nodeFromEdge](edge, node.parent, null, required)\n        continue\n      }\n\n      // at this point we know that there is a dep there, and\n      // we don't like it.  always fail strictly, always allow forcibly or\n      // in non-strict mode if it's not our fault.  don't warn here, because\n      // we are going to warn again when we place the deps, if we end up\n      // overriding for something else.  If the thing that has this dep\n      // isn't also required, then there's a good chance we won't need it,\n      // so allow it for now and let it conflict if it turns out to actually\n      // be necessary for the installation.\n      if (conflictOK || !required.has(edge.from)) {\n        continue\n      }\n\n      // ok, it's the root, or we're in unforced strict mode, so this is bad\n      this[_failPeerConflict](edge, parentEdge)\n    }\n    return node\n  }\n\n  [_failPeerConflict] (edge, currentEdge) {\n    const expl = this[_explainPeerConflict](edge, currentEdge)\n    throw Object.assign(new Error('unable to resolve dependency tree'), expl)\n  }\n\n  [_explainPeerConflict] (edge, currentEdge) {\n    const node = edge.from\n    const curNode = node.resolve(edge.name)\n    const current = curNode.explain()\n    return {\n      code: 'ERESOLVE',\n      current,\n      // it SHOULD be impossible to get here without a current node in place,\n      // but this at least gives us something report on when bugs creep into\n      // the tree handling logic.\n      currentEdge: currentEdge ? currentEdge.explain() : null,\n      edge: edge.explain(),\n      strictPeerDeps: this[_strictPeerDeps],\n      force: this[_force],\n    }\n  }\n\n  // go through all the links in the this[_linkNodes] set\n  // for each one:\n  // - if outside the root, ignore it, assume it's fine, it's not our problem\n  // - if a node in the tree already, assign the target to that node.\n  // - if a path under an existing node, then assign that as the fsParent,\n  //   and add it to the _depsQueue\n  //\n  // call buildDepStep if anything was added to the queue, otherwise we're done\n  [_resolveLinks] () {\n    for (const link of this[_linkNodes]) {\n      this[_linkNodes].delete(link)\n\n      // link we never ended up placing, skip it\n      if (link.root !== this.idealTree) {\n        continue\n      }\n\n      const tree = this.idealTree.target\n      const external = !link.target.isDescendantOf(tree)\n\n      // outside the root, somebody else's problem, ignore it\n      if (external && !this[_follow]) {\n        continue\n      }\n\n      // didn't find a parent for it or it has not been seen yet\n      // so go ahead and process it.\n      const unseenLink = (link.target.parent || link.target.fsParent) &&\n        !this[_depsSeen].has(link.target)\n\n      if (this[_follow] &&\n          !link.target.parent &&\n          !link.target.fsParent ||\n          unseenLink) {\n        this.addTracker('idealTree', link.target.name, link.target.location)\n        this[_depsQueue].push(link.target)\n      }\n    }\n\n    if (this[_depsQueue].length) {\n      return this[_buildDepStep]()\n    }\n  }\n\n  [_fixDepFlags] () {\n    process.emit('time', 'idealTree:fixDepFlags')\n    const metaFromDisk = this.idealTree.meta.loadedFromDisk\n    const flagsSuspect = this[_flagsSuspect]\n    const mutateTree = this[_mutateTree]\n    // if the options set prune:false, then we don't prune, but we still\n    // mark the extraneous items in the tree if we modified it at all.\n    // If we did no modifications, we just iterate over the extraneous nodes.\n    // if we started with an empty tree, then the dep flags are already\n    // all set to true, and there can be nothing extraneous, so there's\n    // nothing to prune, because we built it from scratch.  if we didn't\n    // add or remove anything, then also nothing to do.\n    if (metaFromDisk && mutateTree) {\n      resetDepFlags(this.idealTree)\n    }\n\n    // update all the dev/optional/etc flags in the tree\n    // either we started with a fresh tree, or we\n    // reset all the flags to find the extraneous nodes.\n    //\n    // if we started from a blank slate, or changed something, then\n    // the dep flags will be all set to true.\n    if (!metaFromDisk || mutateTree) {\n      calcDepFlags(this.idealTree)\n    } else {\n      // otherwise just unset all the flags on the root node\n      // since they will sometimes have the default value\n      this.idealTree.extraneous = false\n      this.idealTree.dev = false\n      this.idealTree.optional = false\n      this.idealTree.devOptional = false\n      this.idealTree.peer = false\n    }\n\n    // at this point, any node marked as extraneous should be pruned.\n    // if we started from a shrinkwrap, and then added/removed something,\n    // then the tree is suspect.  Prune what is marked as extraneous.\n    // otherwise, don't bother.\n    const needPrune = metaFromDisk && (mutateTree || flagsSuspect)\n    if (this[_prune] && needPrune) {\n      this[_idealTreePrune]()\n    }\n\n    process.emit('timeEnd', 'idealTree:fixDepFlags')\n  }\n\n  [_idealTreePrune] () {\n    for (const node of this.idealTree.inventory.filter(n => n.extraneous)) {\n      node.parent = null\n    }\n  }\n\n  [_pruneFailedOptional] () {\n    for (const node of this[_loadFailures]) {\n      if (!node.optional) {\n        throw node.errors[0]\n      }\n\n      const set = optionalSet(node)\n      for (const node of set) {\n        node.parent = null\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}