{"ast":null,"code":"const {\n  dirname,\n  relative,\n  join,\n  resolve,\n  basename\n} = require('path');\nconst linkGently = require('./link-gently.js');\nconst manTarget = require('./man-target.js');\nconst linkMans = ({\n  path,\n  pkg,\n  top,\n  force\n}) => {\n  const target = manTarget({\n    path,\n    top\n  });\n  if (!target || !pkg.man || !Array.isArray(pkg.man) || !pkg.man.length) return Promise.resolve([]);\n\n  // break any links to c:\\\\blah or /foo/blah or ../blah\n  // and filter out duplicates\n  const set = [...new Set(pkg.man.map(man => man ? join('/', man).replace(/\\\\|:/g, '/').substr(1) : null).filter(man => typeof man === 'string'))];\n  return Promise.all(set.map(man => {\n    const parseMan = man.match(/(.*\\.([0-9]+)(\\.gz)?)$/);\n    if (!parseMan) {\n      return Promise.reject(Object.assign(new Error('invalid man entry name\\n' + 'Man files must end with a number, ' + 'and optionally a .gz suffix if they are compressed.'), {\n        code: 'EBADMAN',\n        path,\n        pkgid: pkg._id,\n        man\n      }));\n    }\n    const stem = parseMan[1];\n    const sxn = parseMan[2];\n    const base = basename(stem);\n    const absFrom = resolve(path, man);\n    /* istanbul ignore if - that unpossible */\n    if (absFrom.indexOf(path) !== 0) {\n      return Promise.reject(Object.assign(new Error('invalid man entry'), {\n        code: 'EBADMAN',\n        path,\n        pkgid: pkg._id,\n        man\n      }));\n    }\n    const to = resolve(target, 'man' + sxn, base);\n    const from = relative(dirname(to), absFrom);\n    return linkGently({\n      from,\n      to,\n      path,\n      absFrom,\n      force\n    });\n  }));\n};\nmodule.exports = linkMans;","map":{"version":3,"names":["dirname","relative","join","resolve","basename","require","linkGently","manTarget","linkMans","path","pkg","top","force","target","man","Array","isArray","length","Promise","set","Set","map","replace","substr","filter","all","parseMan","match","reject","Object","assign","Error","code","pkgid","_id","stem","sxn","base","absFrom","indexOf","to","from","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/bin-links/lib/link-mans.js"],"sourcesContent":["const { dirname, relative, join, resolve, basename } = require('path')\nconst linkGently = require('./link-gently.js')\nconst manTarget = require('./man-target.js')\n\nconst linkMans = ({path, pkg, top, force}) => {\n  const target = manTarget({path, top})\n  if (!target || !pkg.man || !Array.isArray(pkg.man) || !pkg.man.length)\n    return Promise.resolve([])\n\n  // break any links to c:\\\\blah or /foo/blah or ../blah\n  // and filter out duplicates\n  const set = [...new Set(pkg.man.map(man =>\n    man ? join('/', man).replace(/\\\\|:/g, '/').substr(1) : null)\n    .filter(man => typeof man === 'string'))]\n\n  return Promise.all(set.map(man => {\n    const parseMan = man.match(/(.*\\.([0-9]+)(\\.gz)?)$/)\n    if (!parseMan) {\n      return Promise.reject(Object.assign(new Error('invalid man entry name\\n' +\n        'Man files must end with a number, ' +\n        'and optionally a .gz suffix if they are compressed.'\n      ), {\n        code: 'EBADMAN',\n        path,\n        pkgid: pkg._id,\n        man,\n      }))\n    }\n\n    const stem = parseMan[1]\n    const sxn = parseMan[2]\n    const base = basename(stem)\n    const absFrom = resolve(path, man)\n    /* istanbul ignore if - that unpossible */\n    if (absFrom.indexOf(path) !== 0) {\n      return Promise.reject(Object.assign(new Error('invalid man entry'), {\n        code: 'EBADMAN',\n        path,\n        pkgid: pkg._id,\n        man,\n      }))\n    }\n\n    const to = resolve(target, 'man' + sxn, base)\n    const from = relative(dirname(to), absFrom)\n\n    return linkGently({from, to, path, absFrom, force})\n  }))\n}\n\nmodule.exports = linkMans\n"],"mappings":"AAAA,MAAM;EAAEA,OAAO;EAAEC,QAAQ;EAAEC,IAAI;EAAEC,OAAO;EAAEC;AAAS,CAAC,GAAGC,OAAO,CAAC,MAAM,CAAC;AACtE,MAAMC,UAAU,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AAC9C,MAAME,SAAS,GAAGF,OAAO,CAAC,iBAAiB,CAAC;AAE5C,MAAMG,QAAQ,GAAGA,CAAC;EAACC,IAAI;EAAEC,GAAG;EAAEC,GAAG;EAAEC;AAAK,CAAC,KAAK;EAC5C,MAAMC,MAAM,GAAGN,SAAS,CAAC;IAACE,IAAI;IAAEE;EAAG,CAAC,CAAC;EACrC,IAAI,CAACE,MAAM,IAAI,CAACH,GAAG,CAACI,GAAG,IAAI,CAACC,KAAK,CAACC,OAAO,CAACN,GAAG,CAACI,GAAG,CAAC,IAAI,CAACJ,GAAG,CAACI,GAAG,CAACG,MAAM,EACnE,OAAOC,OAAO,CAACf,OAAO,CAAC,EAAE,CAAC;;EAE5B;EACA;EACA,MAAMgB,GAAG,GAAG,CAAC,GAAG,IAAIC,GAAG,CAACV,GAAG,CAACI,GAAG,CAACO,GAAG,CAACP,GAAG,IACrCA,GAAG,GAAGZ,IAAI,CAAC,GAAG,EAAEY,GAAG,CAAC,CAACQ,OAAO,CAAC,OAAO,EAAE,GAAG,CAAC,CAACC,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAC3DC,MAAM,CAACV,GAAG,IAAI,OAAOA,GAAG,KAAK,QAAQ,CAAC,CAAC,CAAC;EAE3C,OAAOI,OAAO,CAACO,GAAG,CAACN,GAAG,CAACE,GAAG,CAACP,GAAG,IAAI;IAChC,MAAMY,QAAQ,GAAGZ,GAAG,CAACa,KAAK,CAAC,wBAAwB,CAAC;IACpD,IAAI,CAACD,QAAQ,EAAE;MACb,OAAOR,OAAO,CAACU,MAAM,CAACC,MAAM,CAACC,MAAM,CAAC,IAAIC,KAAK,CAAC,0BAA0B,GACtE,oCAAoC,GACpC,qDACF,CAAC,EAAE;QACDC,IAAI,EAAE,SAAS;QACfvB,IAAI;QACJwB,KAAK,EAAEvB,GAAG,CAACwB,GAAG;QACdpB;MACF,CAAC,CAAC,CAAC;IACL;IAEA,MAAMqB,IAAI,GAAGT,QAAQ,CAAC,CAAC,CAAC;IACxB,MAAMU,GAAG,GAAGV,QAAQ,CAAC,CAAC,CAAC;IACvB,MAAMW,IAAI,GAAGjC,QAAQ,CAAC+B,IAAI,CAAC;IAC3B,MAAMG,OAAO,GAAGnC,OAAO,CAACM,IAAI,EAAEK,GAAG,CAAC;IAClC;IACA,IAAIwB,OAAO,CAACC,OAAO,CAAC9B,IAAI,CAAC,KAAK,CAAC,EAAE;MAC/B,OAAOS,OAAO,CAACU,MAAM,CAACC,MAAM,CAACC,MAAM,CAAC,IAAIC,KAAK,CAAC,mBAAmB,CAAC,EAAE;QAClEC,IAAI,EAAE,SAAS;QACfvB,IAAI;QACJwB,KAAK,EAAEvB,GAAG,CAACwB,GAAG;QACdpB;MACF,CAAC,CAAC,CAAC;IACL;IAEA,MAAM0B,EAAE,GAAGrC,OAAO,CAACU,MAAM,EAAE,KAAK,GAAGuB,GAAG,EAAEC,IAAI,CAAC;IAC7C,MAAMI,IAAI,GAAGxC,QAAQ,CAACD,OAAO,CAACwC,EAAE,CAAC,EAAEF,OAAO,CAAC;IAE3C,OAAOhC,UAAU,CAAC;MAACmC,IAAI;MAAED,EAAE;MAAE/B,IAAI;MAAE6B,OAAO;MAAE1B;IAAK,CAAC,CAAC;EACrD,CAAC,CAAC,CAAC;AACL,CAAC;AAED8B,MAAM,CAACC,OAAO,GAAGnC,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}