{"ast":null,"code":"// Perform a depth-first walk of a tree.\n//\n// `visit(node)` is called when the node is first encountered.\n// `leave(node, children)` is called when all of the node's children\n// have been left or (in the case of cyclic graphs) visited.\n//\n// Only one of visit or leave is required.  (Technically both are optional,\n// but if you don't provide at least one, the tree is just walked without\n// doing anything, which is a bit pointless.)  If visit is provided, and\n// leave is not, then this is a root->leaf traversal.  If leave is provided,\n// and visit is not, then it's leaf->root.  Both can be provided for a\n// map-reduce operation.\n//\n// If either visit or leave return a Promise for any node, then the\n// walk returns a Promise.\n\nconst depthDescent = require('./depth-descent.js');\nconst depth = ({\n  visit,\n  leave,\n  filter = () => true,\n  seen = new Map(),\n  getChildren,\n  tree\n}) => {\n  if (!leave) return depthDescent({\n    visit,\n    filter,\n    getChildren,\n    tree\n  });\n  if (seen.has(tree)) return seen.get(tree);\n  seen.set(tree, null);\n  const visitNode = () => {\n    const res = visit ? visit(tree) : tree;\n    if (isPromise(res)) {\n      const fullResult = res.then(res => {\n        seen.set(tree, res);\n        return kidNodes();\n      });\n      seen.set(tree, fullResult);\n      return fullResult;\n    } else {\n      seen.set(tree, res);\n      return kidNodes();\n    }\n  };\n  const kidNodes = () => {\n    const kids = getChildren(tree, seen.get(tree));\n    return isPromise(kids) ? kids.then(processKids) : processKids(kids);\n  };\n  const processKids = kidNodes => {\n    const kids = (kidNodes || []).filter(filter).map(kid => depth({\n      visit,\n      leave,\n      filter,\n      seen,\n      getChildren,\n      tree: kid\n    }));\n    return kids.some(isPromise) ? Promise.all(kids).then(leaveNode) : leaveNode(kids);\n  };\n  const leaveNode = kids => {\n    const res = leave(seen.get(tree), kids);\n    seen.set(tree, res);\n    // if it's a promise at this point, the caller deals with it\n    return res;\n  };\n  return visitNode();\n};\nconst isPromise = p => p && typeof p.then === 'function';\nmodule.exports = depth;","map":{"version":3,"names":["depthDescent","require","depth","visit","leave","filter","seen","Map","getChildren","tree","has","get","set","visitNode","res","isPromise","fullResult","then","kidNodes","kids","processKids","map","kid","some","Promise","all","leaveNode","p","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/treeverse/lib/depth.js"],"sourcesContent":["// Perform a depth-first walk of a tree.\n//\n// `visit(node)` is called when the node is first encountered.\n// `leave(node, children)` is called when all of the node's children\n// have been left or (in the case of cyclic graphs) visited.\n//\n// Only one of visit or leave is required.  (Technically both are optional,\n// but if you don't provide at least one, the tree is just walked without\n// doing anything, which is a bit pointless.)  If visit is provided, and\n// leave is not, then this is a root->leaf traversal.  If leave is provided,\n// and visit is not, then it's leaf->root.  Both can be provided for a\n// map-reduce operation.\n//\n// If either visit or leave return a Promise for any node, then the\n// walk returns a Promise.\n\nconst depthDescent = require('./depth-descent.js')\nconst depth = ({\n  visit,\n  leave,\n  filter = () => true,\n  seen = new Map(),\n  getChildren,\n  tree,\n}) => {\n  if (!leave)\n    return depthDescent({ visit, filter, getChildren, tree })\n\n  if (seen.has(tree))\n    return seen.get(tree)\n\n  seen.set(tree, null)\n\n  const visitNode = () => {\n    const res = visit ? visit(tree) : tree\n    if (isPromise(res)) {\n      const fullResult = res.then(res => {\n        seen.set(tree, res)\n        return kidNodes()\n      })\n      seen.set(tree, fullResult)\n      return fullResult\n    } else {\n      seen.set(tree, res)\n      return kidNodes()\n    }\n  }\n\n  const kidNodes = () => {\n    const kids = getChildren(tree, seen.get(tree))\n    return isPromise(kids) ? kids.then(processKids) : processKids(kids)\n  }\n\n  const processKids = kidNodes => {\n    const kids = (kidNodes || []).filter(filter).map(kid =>\n      depth({visit, leave, filter, seen, getChildren, tree: kid}))\n    return kids.some(isPromise)\n      ? Promise.all(kids).then(leaveNode)\n      : leaveNode(kids)\n  }\n\n  const leaveNode = kids => {\n    const res = leave(seen.get(tree), kids)\n    seen.set(tree, res)\n    // if it's a promise at this point, the caller deals with it\n    return res\n  }\n\n  return visitNode()\n}\n\nconst isPromise = p => p && typeof p.then === 'function'\n\nmodule.exports = depth\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAClD,MAAMC,KAAK,GAAGA,CAAC;EACbC,KAAK;EACLC,KAAK;EACLC,MAAM,GAAGA,CAAA,KAAM,IAAI;EACnBC,IAAI,GAAG,IAAIC,GAAG,CAAC,CAAC;EAChBC,WAAW;EACXC;AACF,CAAC,KAAK;EACJ,IAAI,CAACL,KAAK,EACR,OAAOJ,YAAY,CAAC;IAAEG,KAAK;IAAEE,MAAM;IAAEG,WAAW;IAAEC;EAAK,CAAC,CAAC;EAE3D,IAAIH,IAAI,CAACI,GAAG,CAACD,IAAI,CAAC,EAChB,OAAOH,IAAI,CAACK,GAAG,CAACF,IAAI,CAAC;EAEvBH,IAAI,CAACM,GAAG,CAACH,IAAI,EAAE,IAAI,CAAC;EAEpB,MAAMI,SAAS,GAAGA,CAAA,KAAM;IACtB,MAAMC,GAAG,GAAGX,KAAK,GAAGA,KAAK,CAACM,IAAI,CAAC,GAAGA,IAAI;IACtC,IAAIM,SAAS,CAACD,GAAG,CAAC,EAAE;MAClB,MAAME,UAAU,GAAGF,GAAG,CAACG,IAAI,CAACH,GAAG,IAAI;QACjCR,IAAI,CAACM,GAAG,CAACH,IAAI,EAAEK,GAAG,CAAC;QACnB,OAAOI,QAAQ,CAAC,CAAC;MACnB,CAAC,CAAC;MACFZ,IAAI,CAACM,GAAG,CAACH,IAAI,EAAEO,UAAU,CAAC;MAC1B,OAAOA,UAAU;IACnB,CAAC,MAAM;MACLV,IAAI,CAACM,GAAG,CAACH,IAAI,EAAEK,GAAG,CAAC;MACnB,OAAOI,QAAQ,CAAC,CAAC;IACnB;EACF,CAAC;EAED,MAAMA,QAAQ,GAAGA,CAAA,KAAM;IACrB,MAAMC,IAAI,GAAGX,WAAW,CAACC,IAAI,EAAEH,IAAI,CAACK,GAAG,CAACF,IAAI,CAAC,CAAC;IAC9C,OAAOM,SAAS,CAACI,IAAI,CAAC,GAAGA,IAAI,CAACF,IAAI,CAACG,WAAW,CAAC,GAAGA,WAAW,CAACD,IAAI,CAAC;EACrE,CAAC;EAED,MAAMC,WAAW,GAAGF,QAAQ,IAAI;IAC9B,MAAMC,IAAI,GAAG,CAACD,QAAQ,IAAI,EAAE,EAAEb,MAAM,CAACA,MAAM,CAAC,CAACgB,GAAG,CAACC,GAAG,IAClDpB,KAAK,CAAC;MAACC,KAAK;MAAEC,KAAK;MAAEC,MAAM;MAAEC,IAAI;MAAEE,WAAW;MAAEC,IAAI,EAAEa;IAAG,CAAC,CAAC,CAAC;IAC9D,OAAOH,IAAI,CAACI,IAAI,CAACR,SAAS,CAAC,GACvBS,OAAO,CAACC,GAAG,CAACN,IAAI,CAAC,CAACF,IAAI,CAACS,SAAS,CAAC,GACjCA,SAAS,CAACP,IAAI,CAAC;EACrB,CAAC;EAED,MAAMO,SAAS,GAAGP,IAAI,IAAI;IACxB,MAAML,GAAG,GAAGV,KAAK,CAACE,IAAI,CAACK,GAAG,CAACF,IAAI,CAAC,EAAEU,IAAI,CAAC;IACvCb,IAAI,CAACM,GAAG,CAACH,IAAI,EAAEK,GAAG,CAAC;IACnB;IACA,OAAOA,GAAG;EACZ,CAAC;EAED,OAAOD,SAAS,CAAC,CAAC;AACpB,CAAC;AAED,MAAME,SAAS,GAAGY,CAAC,IAAIA,CAAC,IAAI,OAAOA,CAAC,CAACV,IAAI,KAAK,UAAU;AAExDW,MAAM,CAACC,OAAO,GAAG3B,KAAK","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}