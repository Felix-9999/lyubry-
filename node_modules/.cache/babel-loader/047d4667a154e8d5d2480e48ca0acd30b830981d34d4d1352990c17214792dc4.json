{"ast":null,"code":"// to GET CONTENTS for folder at PATH (which may be a PACKAGE):\n// - if PACKAGE, read path/package.json\n//   - if bins in ../node_modules/.bin, add those to result\n// - if depth >= maxDepth, add PATH to result, and finish\n// - readdir(PATH, with file types)\n// - add all FILEs in PATH to result\n// - if PARENT:\n//   - if depth < maxDepth, add GET CONTENTS of all DIRs in PATH\n//   - else, add all DIRs in PATH\n// - if no parent\n//   - if no bundled deps,\n//     - if depth < maxDepth, add GET CONTENTS of DIRs in path except\n//       node_modules\n//     - else, add all DIRs in path other than node_modules\n//   - if has bundled deps,\n//     - get list of bundled deps\n//     - add GET CONTENTS of bundled deps, PACKAGE=true, depth + 1\n\nconst bundled = require('npm-bundled');\nconst {\n  promisify\n} = require('util');\nconst fs = require('fs');\nconst readFile = promisify(fs.readFile);\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst {\n  relative,\n  resolve,\n  basename,\n  dirname\n} = require('path');\nconst normalizePackageBin = require('npm-normalize-package-bin');\nconst readPackage = ({\n  path,\n  packageJsonCache\n}) => packageJsonCache.has(path) ? Promise.resolve(packageJsonCache.get(path)) : readFile(path).then(json => {\n  const pkg = normalizePackageBin(JSON.parse(json));\n  packageJsonCache.set(path, pkg);\n  return pkg;\n}).catch(er => null);\n\n// just normalize bundle deps and bin, that's all we care about here.\nconst normalized = Symbol('package data has been normalized');\nconst rpj = ({\n  path,\n  packageJsonCache\n}) => readPackage({\n  path,\n  packageJsonCache\n}).then(pkg => {\n  if (!pkg || pkg[normalized]) return pkg;\n  if (pkg.bundledDependencies && !pkg.bundleDependencies) {\n    pkg.bundleDependencies = pkg.bundledDependencies;\n    delete pkg.bundledDependencies;\n  }\n  const bd = pkg.bundleDependencies;\n  if (bd === true) {\n    pkg.bundleDependencies = [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.optionalDependencies || {})];\n  }\n  if (typeof bd === 'object' && !Array.isArray(bd)) {\n    pkg.bundleDependencies = Object.keys(bd);\n  }\n  pkg[normalized] = true;\n  return pkg;\n});\nconst pkgContents = async ({\n  path,\n  depth,\n  currentDepth = 0,\n  pkg = null,\n  result = null,\n  packageJsonCache = null\n}) => {\n  if (!result) result = new Set();\n  if (!packageJsonCache) packageJsonCache = new Map();\n  if (pkg === true) {\n    return rpj({\n      path: path + '/package.json',\n      packageJsonCache\n    }).then(pkg => pkgContents({\n      path,\n      depth,\n      currentDepth,\n      pkg,\n      result,\n      packageJsonCache\n    }));\n  }\n  if (pkg) {\n    // add all bins to result if they exist\n    if (pkg.bin) {\n      const dir = dirname(path);\n      const base = basename(path);\n      const scope = basename(dir);\n      const nm = /^@.+/.test(scope) ? dirname(dir) : dir;\n      const binFiles = [];\n      Object.keys(pkg.bin).forEach(b => {\n        const base = resolve(nm, '.bin', b);\n        binFiles.push(base, base + '.cmd', base + '.ps1');\n      });\n      const bins = await Promise.all(binFiles.map(b => stat(b).then(() => b).catch(er => null)));\n      bins.filter(b => b).forEach(b => result.add(b));\n    }\n  }\n  if (currentDepth >= depth) {\n    result.add(path);\n    return result;\n  }\n\n  // we'll need bundle list later, so get that now in parallel\n  const [dirEntries, bundleDeps] = await Promise.all([readdir(path, {\n    withFileTypes: true\n  }), currentDepth === 0 && pkg && pkg.bundleDependencies ? bundled({\n    path,\n    packageJsonCache\n  }) : null]).catch(() => []);\n\n  // not a thing, probably a missing folder\n  if (!dirEntries) return result;\n\n  // empty folder, just add the folder itself to the result\n  if (!dirEntries.length && !bundleDeps && currentDepth !== 0) {\n    result.add(path);\n    return result;\n  }\n  const recursePromises = [];\n\n  // if we didn't get withFileTypes support, tack that on\n  if (typeof dirEntries[0] === 'string') {\n    // use a map so we can return a promise, but we mutate dirEntries in place\n    // this is much slower than getting the entries from the readdir call,\n    // but polyfills support for node versions before 10.10\n    await Promise.all(dirEntries.map(async (name, index) => {\n      const p = resolve(path, name);\n      const st = await lstat(p);\n      dirEntries[index] = Object.assign(st, {\n        name\n      });\n    }));\n  }\n  for (const entry of dirEntries) {\n    const p = resolve(path, entry.name);\n    if (entry.isDirectory() === false) {\n      result.add(p);\n      continue;\n    }\n    if (currentDepth !== 0 || entry.name !== 'node_modules') {\n      if (currentDepth < depth - 1) {\n        recursePromises.push(pkgContents({\n          path: p,\n          packageJsonCache,\n          depth,\n          currentDepth: currentDepth + 1,\n          result\n        }));\n      } else {\n        result.add(p);\n      }\n      continue;\n    }\n  }\n  if (bundleDeps) {\n    // bundle deps are all folders\n    // we always recurse to get pkg bins, but if currentDepth is too high,\n    // it'll return early before walking their contents.\n    recursePromises.push(...bundleDeps.map(dep => {\n      const p = resolve(path, 'node_modules', dep);\n      return pkgContents({\n        path: p,\n        packageJsonCache,\n        pkg: true,\n        depth,\n        currentDepth: currentDepth + 1,\n        result\n      });\n    }));\n  }\n  if (recursePromises.length) await Promise.all(recursePromises);\n  return result;\n};\nmodule.exports = ({\n  path,\n  depth = 1,\n  packageJsonCache\n}) => pkgContents({\n  path: resolve(path),\n  depth,\n  pkg: true,\n  packageJsonCache\n}).then(results => [...results]);\nif (require.main === module) {\n  const options = {\n    path: null,\n    depth: 1\n  };\n  const usage = `Usage:\n  installed-package-contents <path> [-d<n> --depth=<n>]\n\nLists the files installed for a package specified by <path>.\n\nOptions:\n  -d<n> --depth=<n>   Provide a numeric value (\"Infinity\" is allowed)\n                      to specify how deep in the file tree to traverse.\n                      Default=1\n  -h --help           Show this usage information`;\n  process.argv.slice(2).forEach(arg => {\n    let match;\n    if ((match = arg.match(/^--depth=([0-9]+|Infinity)/)) || (match = arg.match(/^-d([0-9]+|Infinity)/))) options.depth = +match[1];else if (arg === '-h' || arg === '--help') {\n      console.log(usage);\n      process.exit(0);\n    } else options.path = arg;\n  });\n  if (!options.path) {\n    console.error('ERROR: no path provided');\n    console.error(usage);\n    process.exit(1);\n  }\n  const cwd = process.cwd();\n  module.exports(options).then(list => list.sort().forEach(p => console.log(relative(cwd, p)))).catch( /* istanbul ignore next - pretty unusual */er => {\n    console.error(er);\n    process.exit(1);\n  });\n}","map":{"version":3,"names":["bundled","require","promisify","fs","readFile","readdir","stat","lstat","relative","resolve","basename","dirname","normalizePackageBin","readPackage","path","packageJsonCache","has","Promise","get","then","json","pkg","JSON","parse","set","catch","er","normalized","Symbol","rpj","bundledDependencies","bundleDependencies","bd","Object","keys","dependencies","optionalDependencies","Array","isArray","pkgContents","depth","currentDepth","result","Set","Map","bin","dir","base","scope","nm","test","binFiles","forEach","b","push","bins","all","map","filter","add","dirEntries","bundleDeps","withFileTypes","length","recursePromises","name","index","p","st","assign","entry","isDirectory","dep","module","exports","results","main","options","usage","process","argv","slice","arg","match","console","log","exit","error","cwd","list","sort"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/installed-package-contents/index.js"],"sourcesContent":["// to GET CONTENTS for folder at PATH (which may be a PACKAGE):\n// - if PACKAGE, read path/package.json\n//   - if bins in ../node_modules/.bin, add those to result\n// - if depth >= maxDepth, add PATH to result, and finish\n// - readdir(PATH, with file types)\n// - add all FILEs in PATH to result\n// - if PARENT:\n//   - if depth < maxDepth, add GET CONTENTS of all DIRs in PATH\n//   - else, add all DIRs in PATH\n// - if no parent\n//   - if no bundled deps,\n//     - if depth < maxDepth, add GET CONTENTS of DIRs in path except\n//       node_modules\n//     - else, add all DIRs in path other than node_modules\n//   - if has bundled deps,\n//     - get list of bundled deps\n//     - add GET CONTENTS of bundled deps, PACKAGE=true, depth + 1\n\nconst bundled = require('npm-bundled')\nconst {promisify} = require('util')\nconst fs = require('fs')\nconst readFile = promisify(fs.readFile)\nconst readdir = promisify(fs.readdir)\nconst stat = promisify(fs.stat)\nconst lstat = promisify(fs.lstat)\nconst {relative, resolve, basename, dirname} = require('path')\nconst normalizePackageBin = require('npm-normalize-package-bin')\n\nconst readPackage = ({ path, packageJsonCache }) =>\n  packageJsonCache.has(path) ? Promise.resolve(packageJsonCache.get(path))\n  : readFile(path).then(json => {\n      const pkg = normalizePackageBin(JSON.parse(json))\n      packageJsonCache.set(path, pkg)\n      return pkg\n    })\n    .catch(er => null)\n\n// just normalize bundle deps and bin, that's all we care about here.\nconst normalized = Symbol('package data has been normalized')\nconst rpj = ({ path, packageJsonCache }) =>\n  readPackage({path, packageJsonCache})\n  .then(pkg => {\n    if (!pkg || pkg[normalized])\n      return pkg\n    if (pkg.bundledDependencies && !pkg.bundleDependencies) {\n      pkg.bundleDependencies = pkg.bundledDependencies\n      delete pkg.bundledDependencies\n    }\n    const bd = pkg.bundleDependencies\n    if (bd === true) {\n      pkg.bundleDependencies = [\n        ...Object.keys(pkg.dependencies || {}),\n        ...Object.keys(pkg.optionalDependencies || {}),\n      ]\n    }\n    if (typeof bd === 'object' && !Array.isArray(bd)) {\n      pkg.bundleDependencies = Object.keys(bd)\n    }\n    pkg[normalized] = true\n    return pkg\n  })\n\n\nconst pkgContents = async ({\n  path,\n  depth,\n  currentDepth = 0,\n  pkg = null,\n  result = null,\n  packageJsonCache = null,\n}) => {\n  if (!result)\n    result = new Set()\n\n  if (!packageJsonCache)\n    packageJsonCache = new Map()\n\n  if (pkg === true) {\n    return rpj({ path: path + '/package.json', packageJsonCache })\n      .then(pkg => pkgContents({\n        path,\n        depth,\n        currentDepth,\n        pkg,\n        result,\n        packageJsonCache,\n      }))\n  }\n\n  if (pkg) {\n    // add all bins to result if they exist\n    if (pkg.bin) {\n      const dir = dirname(path)\n      const base = basename(path)\n      const scope = basename(dir)\n      const nm = /^@.+/.test(scope) ? dirname(dir) : dir\n\n      const binFiles = []\n      Object.keys(pkg.bin).forEach(b => {\n        const base = resolve(nm, '.bin', b)\n        binFiles.push(base, base + '.cmd', base + '.ps1')\n      })\n\n      const bins = await Promise.all(\n        binFiles.map(b => stat(b).then(() => b).catch((er) => null))\n      )\n      bins.filter(b => b).forEach(b => result.add(b))\n    }\n  }\n\n  if (currentDepth >= depth) {\n    result.add(path)\n    return result\n  }\n\n  // we'll need bundle list later, so get that now in parallel\n  const [dirEntries, bundleDeps] = await Promise.all([\n    readdir(path, { withFileTypes: true }),\n    currentDepth === 0 && pkg && pkg.bundleDependencies\n      ? bundled({ path, packageJsonCache }) : null,\n  ]).catch(() => [])\n\n  // not a thing, probably a missing folder\n  if (!dirEntries)\n    return result\n\n  // empty folder, just add the folder itself to the result\n  if (!dirEntries.length && !bundleDeps && currentDepth !== 0) {\n    result.add(path)\n    return result\n  }\n\n  const recursePromises = []\n\n  // if we didn't get withFileTypes support, tack that on\n  if (typeof dirEntries[0] === 'string') {\n    // use a map so we can return a promise, but we mutate dirEntries in place\n    // this is much slower than getting the entries from the readdir call,\n    // but polyfills support for node versions before 10.10\n    await Promise.all(dirEntries.map(async (name, index) => {\n      const p = resolve(path, name)\n      const st = await lstat(p)\n      dirEntries[index] = Object.assign(st, {name})\n    }))\n  }\n\n  for (const entry of dirEntries) {\n    const p = resolve(path, entry.name)\n    if (entry.isDirectory() === false) {\n      result.add(p)\n      continue\n    }\n\n    if (currentDepth !== 0 || entry.name !== 'node_modules') {\n      if (currentDepth < depth - 1) {\n        recursePromises.push(pkgContents({\n          path: p,\n          packageJsonCache,\n          depth,\n          currentDepth: currentDepth + 1,\n          result,\n        }))\n      } else {\n        result.add(p)\n      }\n      continue\n    }\n  }\n\n  if (bundleDeps) {\n    // bundle deps are all folders\n    // we always recurse to get pkg bins, but if currentDepth is too high,\n    // it'll return early before walking their contents.\n    recursePromises.push(...bundleDeps.map(dep => {\n      const p = resolve(path, 'node_modules', dep)\n      return pkgContents({\n        path: p,\n        packageJsonCache,\n        pkg: true,\n        depth,\n        currentDepth: currentDepth + 1,\n        result,\n      })\n    }))\n  }\n\n  if (recursePromises.length)\n    await Promise.all(recursePromises)\n\n  return result\n}\n\nmodule.exports = ({path, depth = 1, packageJsonCache}) => pkgContents({\n  path: resolve(path),\n  depth,\n  pkg: true,\n  packageJsonCache,\n}).then(results => [...results])\n\n\nif (require.main === module) {\n  const options = { path: null, depth: 1 }\n  const usage = `Usage:\n  installed-package-contents <path> [-d<n> --depth=<n>]\n\nLists the files installed for a package specified by <path>.\n\nOptions:\n  -d<n> --depth=<n>   Provide a numeric value (\"Infinity\" is allowed)\n                      to specify how deep in the file tree to traverse.\n                      Default=1\n  -h --help           Show this usage information`\n\n  process.argv.slice(2).forEach(arg => {\n    let match\n    if ((match = arg.match(/^--depth=([0-9]+|Infinity)/)) ||\n        (match = arg.match(/^-d([0-9]+|Infinity)/)))\n      options.depth = +match[1]\n    else if (arg === '-h' || arg === '--help') {\n      console.log(usage)\n      process.exit(0)\n    } else\n      options.path = arg\n  })\n  if (!options.path)  {\n    console.error('ERROR: no path provided')\n    console.error(usage)\n    process.exit(1)\n  }\n  const cwd = process.cwd()\n  module.exports(options)\n    .then(list => list.sort().forEach(p => console.log(relative(cwd, p))))\n    .catch(/* istanbul ignore next - pretty unusual */ er => {\n      console.error(er)\n      process.exit(1)\n    })\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,aAAa,CAAC;AACtC,MAAM;EAACC;AAAS,CAAC,GAAGD,OAAO,CAAC,MAAM,CAAC;AACnC,MAAME,EAAE,GAAGF,OAAO,CAAC,IAAI,CAAC;AACxB,MAAMG,QAAQ,GAAGF,SAAS,CAACC,EAAE,CAACC,QAAQ,CAAC;AACvC,MAAMC,OAAO,GAAGH,SAAS,CAACC,EAAE,CAACE,OAAO,CAAC;AACrC,MAAMC,IAAI,GAAGJ,SAAS,CAACC,EAAE,CAACG,IAAI,CAAC;AAC/B,MAAMC,KAAK,GAAGL,SAAS,CAACC,EAAE,CAACI,KAAK,CAAC;AACjC,MAAM;EAACC,QAAQ;EAAEC,OAAO;EAAEC,QAAQ;EAAEC;AAAO,CAAC,GAAGV,OAAO,CAAC,MAAM,CAAC;AAC9D,MAAMW,mBAAmB,GAAGX,OAAO,CAAC,2BAA2B,CAAC;AAEhE,MAAMY,WAAW,GAAGA,CAAC;EAAEC,IAAI;EAAEC;AAAiB,CAAC,KAC7CA,gBAAgB,CAACC,GAAG,CAACF,IAAI,CAAC,GAAGG,OAAO,CAACR,OAAO,CAACM,gBAAgB,CAACG,GAAG,CAACJ,IAAI,CAAC,CAAC,GACtEV,QAAQ,CAACU,IAAI,CAAC,CAACK,IAAI,CAACC,IAAI,IAAI;EAC1B,MAAMC,GAAG,GAAGT,mBAAmB,CAACU,IAAI,CAACC,KAAK,CAACH,IAAI,CAAC,CAAC;EACjDL,gBAAgB,CAACS,GAAG,CAACV,IAAI,EAAEO,GAAG,CAAC;EAC/B,OAAOA,GAAG;AACZ,CAAC,CAAC,CACDI,KAAK,CAACC,EAAE,IAAI,IAAI,CAAC;;AAEtB;AACA,MAAMC,UAAU,GAAGC,MAAM,CAAC,kCAAkC,CAAC;AAC7D,MAAMC,GAAG,GAAGA,CAAC;EAAEf,IAAI;EAAEC;AAAiB,CAAC,KACrCF,WAAW,CAAC;EAACC,IAAI;EAAEC;AAAgB,CAAC,CAAC,CACpCI,IAAI,CAACE,GAAG,IAAI;EACX,IAAI,CAACA,GAAG,IAAIA,GAAG,CAACM,UAAU,CAAC,EACzB,OAAON,GAAG;EACZ,IAAIA,GAAG,CAACS,mBAAmB,IAAI,CAACT,GAAG,CAACU,kBAAkB,EAAE;IACtDV,GAAG,CAACU,kBAAkB,GAAGV,GAAG,CAACS,mBAAmB;IAChD,OAAOT,GAAG,CAACS,mBAAmB;EAChC;EACA,MAAME,EAAE,GAAGX,GAAG,CAACU,kBAAkB;EACjC,IAAIC,EAAE,KAAK,IAAI,EAAE;IACfX,GAAG,CAACU,kBAAkB,GAAG,CACvB,GAAGE,MAAM,CAACC,IAAI,CAACb,GAAG,CAACc,YAAY,IAAI,CAAC,CAAC,CAAC,EACtC,GAAGF,MAAM,CAACC,IAAI,CAACb,GAAG,CAACe,oBAAoB,IAAI,CAAC,CAAC,CAAC,CAC/C;EACH;EACA,IAAI,OAAOJ,EAAE,KAAK,QAAQ,IAAI,CAACK,KAAK,CAACC,OAAO,CAACN,EAAE,CAAC,EAAE;IAChDX,GAAG,CAACU,kBAAkB,GAAGE,MAAM,CAACC,IAAI,CAACF,EAAE,CAAC;EAC1C;EACAX,GAAG,CAACM,UAAU,CAAC,GAAG,IAAI;EACtB,OAAON,GAAG;AACZ,CAAC,CAAC;AAGJ,MAAMkB,WAAW,GAAG,MAAAA,CAAO;EACzBzB,IAAI;EACJ0B,KAAK;EACLC,YAAY,GAAG,CAAC;EAChBpB,GAAG,GAAG,IAAI;EACVqB,MAAM,GAAG,IAAI;EACb3B,gBAAgB,GAAG;AACrB,CAAC,KAAK;EACJ,IAAI,CAAC2B,MAAM,EACTA,MAAM,GAAG,IAAIC,GAAG,CAAC,CAAC;EAEpB,IAAI,CAAC5B,gBAAgB,EACnBA,gBAAgB,GAAG,IAAI6B,GAAG,CAAC,CAAC;EAE9B,IAAIvB,GAAG,KAAK,IAAI,EAAE;IAChB,OAAOQ,GAAG,CAAC;MAAEf,IAAI,EAAEA,IAAI,GAAG,eAAe;MAAEC;IAAiB,CAAC,CAAC,CAC3DI,IAAI,CAACE,GAAG,IAAIkB,WAAW,CAAC;MACvBzB,IAAI;MACJ0B,KAAK;MACLC,YAAY;MACZpB,GAAG;MACHqB,MAAM;MACN3B;IACF,CAAC,CAAC,CAAC;EACP;EAEA,IAAIM,GAAG,EAAE;IACP;IACA,IAAIA,GAAG,CAACwB,GAAG,EAAE;MACX,MAAMC,GAAG,GAAGnC,OAAO,CAACG,IAAI,CAAC;MACzB,MAAMiC,IAAI,GAAGrC,QAAQ,CAACI,IAAI,CAAC;MAC3B,MAAMkC,KAAK,GAAGtC,QAAQ,CAACoC,GAAG,CAAC;MAC3B,MAAMG,EAAE,GAAG,MAAM,CAACC,IAAI,CAACF,KAAK,CAAC,GAAGrC,OAAO,CAACmC,GAAG,CAAC,GAAGA,GAAG;MAElD,MAAMK,QAAQ,GAAG,EAAE;MACnBlB,MAAM,CAACC,IAAI,CAACb,GAAG,CAACwB,GAAG,CAAC,CAACO,OAAO,CAACC,CAAC,IAAI;QAChC,MAAMN,IAAI,GAAGtC,OAAO,CAACwC,EAAE,EAAE,MAAM,EAAEI,CAAC,CAAC;QACnCF,QAAQ,CAACG,IAAI,CAACP,IAAI,EAAEA,IAAI,GAAG,MAAM,EAAEA,IAAI,GAAG,MAAM,CAAC;MACnD,CAAC,CAAC;MAEF,MAAMQ,IAAI,GAAG,MAAMtC,OAAO,CAACuC,GAAG,CAC5BL,QAAQ,CAACM,GAAG,CAACJ,CAAC,IAAI/C,IAAI,CAAC+C,CAAC,CAAC,CAAClC,IAAI,CAAC,MAAMkC,CAAC,CAAC,CAAC5B,KAAK,CAAEC,EAAE,IAAK,IAAI,CAAC,CAC7D,CAAC;MACD6B,IAAI,CAACG,MAAM,CAACL,CAAC,IAAIA,CAAC,CAAC,CAACD,OAAO,CAACC,CAAC,IAAIX,MAAM,CAACiB,GAAG,CAACN,CAAC,CAAC,CAAC;IACjD;EACF;EAEA,IAAIZ,YAAY,IAAID,KAAK,EAAE;IACzBE,MAAM,CAACiB,GAAG,CAAC7C,IAAI,CAAC;IAChB,OAAO4B,MAAM;EACf;;EAEA;EACA,MAAM,CAACkB,UAAU,EAAEC,UAAU,CAAC,GAAG,MAAM5C,OAAO,CAACuC,GAAG,CAAC,CACjDnD,OAAO,CAACS,IAAI,EAAE;IAAEgD,aAAa,EAAE;EAAK,CAAC,CAAC,EACtCrB,YAAY,KAAK,CAAC,IAAIpB,GAAG,IAAIA,GAAG,CAACU,kBAAkB,GAC/C/B,OAAO,CAAC;IAAEc,IAAI;IAAEC;EAAiB,CAAC,CAAC,GAAG,IAAI,CAC/C,CAAC,CAACU,KAAK,CAAC,MAAM,EAAE,CAAC;;EAElB;EACA,IAAI,CAACmC,UAAU,EACb,OAAOlB,MAAM;;EAEf;EACA,IAAI,CAACkB,UAAU,CAACG,MAAM,IAAI,CAACF,UAAU,IAAIpB,YAAY,KAAK,CAAC,EAAE;IAC3DC,MAAM,CAACiB,GAAG,CAAC7C,IAAI,CAAC;IAChB,OAAO4B,MAAM;EACf;EAEA,MAAMsB,eAAe,GAAG,EAAE;;EAE1B;EACA,IAAI,OAAOJ,UAAU,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;IACrC;IACA;IACA;IACA,MAAM3C,OAAO,CAACuC,GAAG,CAACI,UAAU,CAACH,GAAG,CAAC,OAAOQ,IAAI,EAAEC,KAAK,KAAK;MACtD,MAAMC,CAAC,GAAG1D,OAAO,CAACK,IAAI,EAAEmD,IAAI,CAAC;MAC7B,MAAMG,EAAE,GAAG,MAAM7D,KAAK,CAAC4D,CAAC,CAAC;MACzBP,UAAU,CAACM,KAAK,CAAC,GAAGjC,MAAM,CAACoC,MAAM,CAACD,EAAE,EAAE;QAACH;MAAI,CAAC,CAAC;IAC/C,CAAC,CAAC,CAAC;EACL;EAEA,KAAK,MAAMK,KAAK,IAAIV,UAAU,EAAE;IAC9B,MAAMO,CAAC,GAAG1D,OAAO,CAACK,IAAI,EAAEwD,KAAK,CAACL,IAAI,CAAC;IACnC,IAAIK,KAAK,CAACC,WAAW,CAAC,CAAC,KAAK,KAAK,EAAE;MACjC7B,MAAM,CAACiB,GAAG,CAACQ,CAAC,CAAC;MACb;IACF;IAEA,IAAI1B,YAAY,KAAK,CAAC,IAAI6B,KAAK,CAACL,IAAI,KAAK,cAAc,EAAE;MACvD,IAAIxB,YAAY,GAAGD,KAAK,GAAG,CAAC,EAAE;QAC5BwB,eAAe,CAACV,IAAI,CAACf,WAAW,CAAC;UAC/BzB,IAAI,EAAEqD,CAAC;UACPpD,gBAAgB;UAChByB,KAAK;UACLC,YAAY,EAAEA,YAAY,GAAG,CAAC;UAC9BC;QACF,CAAC,CAAC,CAAC;MACL,CAAC,MAAM;QACLA,MAAM,CAACiB,GAAG,CAACQ,CAAC,CAAC;MACf;MACA;IACF;EACF;EAEA,IAAIN,UAAU,EAAE;IACd;IACA;IACA;IACAG,eAAe,CAACV,IAAI,CAAC,GAAGO,UAAU,CAACJ,GAAG,CAACe,GAAG,IAAI;MAC5C,MAAML,CAAC,GAAG1D,OAAO,CAACK,IAAI,EAAE,cAAc,EAAE0D,GAAG,CAAC;MAC5C,OAAOjC,WAAW,CAAC;QACjBzB,IAAI,EAAEqD,CAAC;QACPpD,gBAAgB;QAChBM,GAAG,EAAE,IAAI;QACTmB,KAAK;QACLC,YAAY,EAAEA,YAAY,GAAG,CAAC;QAC9BC;MACF,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC;EACL;EAEA,IAAIsB,eAAe,CAACD,MAAM,EACxB,MAAM9C,OAAO,CAACuC,GAAG,CAACQ,eAAe,CAAC;EAEpC,OAAOtB,MAAM;AACf,CAAC;AAED+B,MAAM,CAACC,OAAO,GAAG,CAAC;EAAC5D,IAAI;EAAE0B,KAAK,GAAG,CAAC;EAAEzB;AAAgB,CAAC,KAAKwB,WAAW,CAAC;EACpEzB,IAAI,EAAEL,OAAO,CAACK,IAAI,CAAC;EACnB0B,KAAK;EACLnB,GAAG,EAAE,IAAI;EACTN;AACF,CAAC,CAAC,CAACI,IAAI,CAACwD,OAAO,IAAI,CAAC,GAAGA,OAAO,CAAC,CAAC;AAGhC,IAAI1E,OAAO,CAAC2E,IAAI,KAAKH,MAAM,EAAE;EAC3B,MAAMI,OAAO,GAAG;IAAE/D,IAAI,EAAE,IAAI;IAAE0B,KAAK,EAAE;EAAE,CAAC;EACxC,MAAMsC,KAAK,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;EAEhDC,OAAO,CAACC,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC7B,OAAO,CAAC8B,GAAG,IAAI;IACnC,IAAIC,KAAK;IACT,IAAI,CAACA,KAAK,GAAGD,GAAG,CAACC,KAAK,CAAC,4BAA4B,CAAC,MAC/CA,KAAK,GAAGD,GAAG,CAACC,KAAK,CAAC,sBAAsB,CAAC,CAAC,EAC7CN,OAAO,CAACrC,KAAK,GAAG,CAAC2C,KAAK,CAAC,CAAC,CAAC,MACtB,IAAID,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAK,QAAQ,EAAE;MACzCE,OAAO,CAACC,GAAG,CAACP,KAAK,CAAC;MAClBC,OAAO,CAACO,IAAI,CAAC,CAAC,CAAC;IACjB,CAAC,MACCT,OAAO,CAAC/D,IAAI,GAAGoE,GAAG;EACtB,CAAC,CAAC;EACF,IAAI,CAACL,OAAO,CAAC/D,IAAI,EAAG;IAClBsE,OAAO,CAACG,KAAK,CAAC,yBAAyB,CAAC;IACxCH,OAAO,CAACG,KAAK,CAACT,KAAK,CAAC;IACpBC,OAAO,CAACO,IAAI,CAAC,CAAC,CAAC;EACjB;EACA,MAAME,GAAG,GAAGT,OAAO,CAACS,GAAG,CAAC,CAAC;EACzBf,MAAM,CAACC,OAAO,CAACG,OAAO,CAAC,CACpB1D,IAAI,CAACsE,IAAI,IAAIA,IAAI,CAACC,IAAI,CAAC,CAAC,CAACtC,OAAO,CAACe,CAAC,IAAIiB,OAAO,CAACC,GAAG,CAAC7E,QAAQ,CAACgF,GAAG,EAAErB,CAAC,CAAC,CAAC,CAAC,CAAC,CACrE1C,KAAK,EAAC,2CAA4CC,EAAE,IAAI;IACvD0D,OAAO,CAACG,KAAK,CAAC7D,EAAE,CAAC;IACjBqD,OAAO,CAACO,IAAI,CAAC,CAAC,CAAC;EACjB,CAAC,CAAC;AACN","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}