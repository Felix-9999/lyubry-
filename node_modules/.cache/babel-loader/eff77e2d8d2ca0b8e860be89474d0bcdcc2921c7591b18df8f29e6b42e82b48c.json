{"ast":null,"code":"var QRCode = require('./../vendor/QRCode'),\n  QRErrorCorrectLevel = require('./../vendor/QRCode/QRErrorCorrectLevel'),\n  black = \"\\033[40m  \\033[0m\",\n  white = \"\\033[47m  \\033[0m\",\n  toCell = function (isBlack) {\n    return isBlack ? black : white;\n  },\n  repeat = function (color) {\n    return {\n      times: function (count) {\n        return new Array(count).join(color);\n      }\n    };\n  },\n  fill = function (length, value) {\n    var arr = new Array(length);\n    for (var i = 0; i < length; i++) {\n      arr[i] = value;\n    }\n    return arr;\n  };\nmodule.exports = {\n  error: QRErrorCorrectLevel.L,\n  generate: function (input, opts, cb) {\n    if (typeof opts === 'function') {\n      cb = opts;\n      opts = {};\n    }\n    var qrcode = new QRCode(-1, this.error);\n    qrcode.addData(input);\n    qrcode.make();\n    var output = '';\n    if (opts && opts.small) {\n      var BLACK = true,\n        WHITE = false;\n      var moduleCount = qrcode.getModuleCount();\n      var moduleData = qrcode.modules.slice();\n      var oddRow = moduleCount % 2 === 1;\n      if (oddRow) {\n        moduleData.push(fill(moduleCount, WHITE));\n      }\n      var platte = {\n        WHITE_ALL: '\\u2588',\n        WHITE_BLACK: '\\u2580',\n        BLACK_WHITE: '\\u2584',\n        BLACK_ALL: ' '\n      };\n      var borderTop = repeat(platte.BLACK_WHITE).times(moduleCount + 3);\n      var borderBottom = repeat(platte.WHITE_BLACK).times(moduleCount + 3);\n      output += borderTop + '\\n';\n      for (var row = 0; row < moduleCount; row += 2) {\n        output += platte.WHITE_ALL;\n        for (var col = 0; col < moduleCount; col++) {\n          if (moduleData[row][col] === WHITE && moduleData[row + 1][col] === WHITE) {\n            output += platte.WHITE_ALL;\n          } else if (moduleData[row][col] === WHITE && moduleData[row + 1][col] === BLACK) {\n            output += platte.WHITE_BLACK;\n          } else if (moduleData[row][col] === BLACK && moduleData[row + 1][col] === WHITE) {\n            output += platte.BLACK_WHITE;\n          } else {\n            output += platte.BLACK_ALL;\n          }\n        }\n        output += platte.WHITE_ALL + '\\n';\n      }\n      if (!oddRow) {\n        output += borderBottom;\n      }\n    } else {\n      var border = repeat(white).times(qrcode.getModuleCount() + 3);\n      output += border + '\\n';\n      qrcode.modules.forEach(function (row) {\n        output += white;\n        output += row.map(toCell).join('');\n        output += white + '\\n';\n      });\n      output += border;\n    }\n    if (cb) cb(output);else console.log(output);\n  },\n  setErrorLevel: function (error) {\n    this.error = QRErrorCorrectLevel[error] || this.error;\n  }\n};","map":{"version":3,"names":["QRCode","require","QRErrorCorrectLevel","black","white","toCell","isBlack","repeat","color","times","count","Array","join","fill","length","value","arr","i","module","exports","error","L","generate","input","opts","cb","qrcode","addData","make","output","small","BLACK","WHITE","moduleCount","getModuleCount","moduleData","modules","slice","oddRow","push","platte","WHITE_ALL","WHITE_BLACK","BLACK_WHITE","BLACK_ALL","borderTop","borderBottom","row","col","border","forEach","map","console","log","setErrorLevel"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/qrcode-terminal/lib/main.js"],"sourcesContent":["var QRCode = require('./../vendor/QRCode'),\n    QRErrorCorrectLevel = require('./../vendor/QRCode/QRErrorCorrectLevel'),\n    black = \"\\033[40m  \\033[0m\",\n    white = \"\\033[47m  \\033[0m\",\n    toCell = function (isBlack) {\n        return isBlack ? black : white;\n    },\n    repeat = function (color) {\n        return {\n            times: function (count) {\n                return new Array(count).join(color);\n            }\n        };\n    },\n    fill = function(length, value) {\n        var arr = new Array(length);\n        for (var i = 0; i < length; i++) {\n            arr[i] = value;\n        }\n        return arr;\n    };\n\nmodule.exports = {\n\n    error: QRErrorCorrectLevel.L,\n\n    generate: function (input, opts, cb) {\n        if (typeof opts === 'function') {\n            cb = opts;\n            opts = {};\n        }\n\n        var qrcode = new QRCode(-1, this.error);\n        qrcode.addData(input);\n        qrcode.make();\n\n        var output = '';\n        if (opts && opts.small) {\n            var BLACK = true, WHITE = false;\n            var moduleCount = qrcode.getModuleCount();\n            var moduleData = qrcode.modules.slice();\n\n            var oddRow = moduleCount % 2 === 1;\n            if (oddRow) {\n                moduleData.push(fill(moduleCount, WHITE));\n            }\n\n            var platte= {\n                WHITE_ALL: '\\u2588',\n                WHITE_BLACK: '\\u2580',\n                BLACK_WHITE: '\\u2584',\n                BLACK_ALL: ' ',\n            };\n\n            var borderTop = repeat(platte.BLACK_WHITE).times(moduleCount + 3);\n            var borderBottom = repeat(platte.WHITE_BLACK).times(moduleCount + 3);\n            output += borderTop + '\\n';\n\n            for (var row = 0; row < moduleCount; row += 2) {\n                output += platte.WHITE_ALL;\n\n                for (var col = 0; col < moduleCount; col++) {\n                    if (moduleData[row][col] === WHITE && moduleData[row + 1][col] === WHITE) {\n                        output += platte.WHITE_ALL;\n                    } else if (moduleData[row][col] === WHITE && moduleData[row + 1][col] === BLACK) {\n                        output += platte.WHITE_BLACK;\n                    } else if (moduleData[row][col] === BLACK && moduleData[row + 1][col] === WHITE) {\n                        output += platte.BLACK_WHITE;\n                    } else {\n                        output += platte.BLACK_ALL;\n                    }\n                }\n\n                output += platte.WHITE_ALL + '\\n';\n            }\n\n            if (!oddRow) {\n                output += borderBottom;\n            }\n        } else {\n            var border = repeat(white).times(qrcode.getModuleCount() + 3);\n\n            output += border + '\\n';\n            qrcode.modules.forEach(function (row) {\n                output += white;\n                output += row.map(toCell).join(''); \n                output += white + '\\n';\n            });\n            output += border;\n        }\n\n        if (cb) cb(output);\n        else console.log(output);\n    },\n\n    setErrorLevel: function (error) {\n        this.error = QRErrorCorrectLevel[error] || this.error;\n    }\n\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}