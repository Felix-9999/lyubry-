{"ast":null,"code":"const {\n  resolve,\n  relative,\n  sep\n} = require('path');\nconst relativePrefix = `.${sep}`;\nconst {\n  EOL\n} = require('os');\nconst archy = require('archy');\nconst chalk = require('chalk');\nconst Arborist = require('@npmcli/arborist');\nconst {\n  breadth\n} = require('treeverse');\nconst npa = require('npm-package-arg');\nconst completion = require('./utils/completion/installed-deep.js');\nconst _depth = Symbol('depth');\nconst _dedupe = Symbol('dedupe');\nconst _filteredBy = Symbol('filteredBy');\nconst _include = Symbol('include');\nconst _invalid = Symbol('invalid');\nconst _name = Symbol('name');\nconst _missing = Symbol('missing');\nconst _parent = Symbol('parent');\nconst _problems = Symbol('problems');\nconst _required = Symbol('required');\nconst _type = Symbol('type');\nconst ArboristWorkspaceCmd = require('./workspaces/arborist-cmd.js');\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\nclass LS extends ArboristWorkspaceCmd {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description() {\n    return 'List installed packages';\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name() {\n    return 'ls';\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage() {\n    return ['[[<@scope>/]<pkg> ...]'];\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params() {\n    return ['all', 'json', 'long', 'parseable', 'global', 'depth', 'omit', 'link', 'package-lock-only', 'unicode', ...super.params];\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  async completion(opts) {\n    return completion(this.npm, opts);\n  }\n  exec(args, cb) {\n    this.ls(args).then(() => cb()).catch(cb);\n  }\n  async ls(args) {\n    const all = this.npm.config.get('all');\n    const color = this.npm.color;\n    const depth = this.npm.config.get('depth');\n    const dev = this.npm.config.get('dev');\n    const development = this.npm.config.get('development');\n    const global = this.npm.config.get('global');\n    const json = this.npm.config.get('json');\n    const link = this.npm.config.get('link');\n    const long = this.npm.config.get('long');\n    const only = this.npm.config.get('only');\n    const parseable = this.npm.config.get('parseable');\n    const prod = this.npm.config.get('prod');\n    const production = this.npm.config.get('production');\n    const unicode = this.npm.config.get('unicode');\n    const packageLockOnly = this.npm.config.get('package-lock-only');\n    const path = global ? resolve(this.npm.globalDir, '..') : this.npm.prefix;\n    const arb = new Arborist({\n      global,\n      ...this.npm.flatOptions,\n      legacyPeerDeps: false,\n      path\n    });\n    const tree = await this.initTree({\n      arb,\n      args,\n      packageLockOnly\n    });\n\n    // filters by workspaces nodes when using -w <workspace-name>\n    // We only have to filter the first layer of edges, so we don't\n    // explore anything that isn't part of the selected workspace set.\n    let wsNodes;\n    if (this.workspaceNames && this.workspaceNames.length) wsNodes = arb.workspaceNodes(tree, this.workspaceNames);\n    const filterBySelectedWorkspaces = edge => {\n      if (!wsNodes || !wsNodes.length) return true;\n      if (edge.from.isProjectRoot) {\n        return edge.to && edge.to.isWorkspace & wsNodes.includes(edge.to.target);\n      }\n      return true;\n    };\n    const seenItems = new Set();\n    const seenNodes = new Map();\n    const problems = new Set();\n\n    // defines special handling of printed depth when filtering with args\n    const filterDefaultDepth = depth === null ? Infinity : depth;\n    const depthToPrint = all || args.length ? filterDefaultDepth : depth || 0;\n\n    // add root node of tree to list of seenNodes\n    seenNodes.set(tree.path, tree);\n\n    // tree traversal happens here, using treeverse.breadth\n    const result = await breadth({\n      tree,\n      // recursive method, `node` is going to be the current elem (starting from\n      // the `tree` obj) that was just visited in the `visit` method below\n      // `nodeResult` is going to be the returned `item` from `visit`\n      getChildren(node, nodeResult) {\n        const seenPaths = new Set();\n        const workspace = node.isWorkspace;\n        const currentDepth = workspace ? 0 : node[_depth];\n        const shouldSkipChildren = !(node instanceof Arborist.Node) || currentDepth > depthToPrint;\n        return shouldSkipChildren ? [] : [...node.target.edgesOut.values()].filter(filterBySelectedWorkspaces).filter(filterByEdgesTypes({\n          currentDepth,\n          dev,\n          development,\n          link,\n          prod,\n          production,\n          only\n        })).map(mapEdgesToNodes({\n          seenPaths\n        })).concat(appendExtraneousChildren({\n          node,\n          seenPaths\n        })).sort(sortAlphabetically).map(augmentNodesWithMetadata({\n          args,\n          currentDepth,\n          nodeResult,\n          seenNodes\n        }));\n      },\n      // visit each `node` of the `tree`, returning an `item` - these are\n      // the elements that will be used to build the final output\n      visit(node) {\n        node[_problems] = getProblems(node, {\n          global\n        });\n        const item = json ? getJsonOutputItem(node, {\n          global,\n          long\n        }) : parseable ? null : getHumanOutputItem(node, {\n          args,\n          color,\n          global,\n          long\n        });\n\n        // loop through list of node problems to add them to global list\n        if (node[_include]) {\n          for (const problem of node[_problems]) problems.add(problem);\n        }\n        seenItems.add(item);\n\n        // return a promise so we don't blow the stack\n        return Promise.resolve(item);\n      }\n    });\n\n    // handle the special case of a broken package.json in the root folder\n    const [rootError] = tree.errors.filter(e => e.code === 'EJSONPARSE' && e.path === resolve(path, 'package.json'));\n    this.npm.output(json ? jsonOutput({\n      path,\n      problems,\n      result,\n      rootError,\n      seenItems\n    }) : parseable ? parseableOutput({\n      seenNodes,\n      global,\n      long\n    }) : humanOutput({\n      color,\n      result,\n      seenItems,\n      unicode\n    }));\n\n    // if filtering items, should exit with error code on no results\n    if (result && !result[_include] && args.length) process.exitCode = 1;\n    if (rootError) {\n      throw Object.assign(new Error('Failed to parse root package.json'), {\n        code: 'EJSONPARSE'\n      });\n    }\n    const shouldThrow = problems.size && ![...problems].every(problem => problem.startsWith('extraneous:'));\n    if (shouldThrow) {\n      throw Object.assign(new Error([...problems].join(EOL)), {\n        code: 'ELSPROBLEMS'\n      });\n    }\n  }\n  async initTree({\n    arb,\n    args,\n    packageLockOnly\n  }) {\n    const tree = await (packageLockOnly ? arb.loadVirtual() : arb.loadActual());\n    tree[_include] = args.length === 0;\n    tree[_depth] = 0;\n    return tree;\n  }\n}\nmodule.exports = LS;\nconst isGitNode = node => {\n  if (!node.resolved) return;\n  try {\n    const {\n      type\n    } = npa(node.resolved);\n    return type === 'git' || type === 'hosted';\n  } catch (err) {\n    return false;\n  }\n};\nconst isOptional = node => node[_type] === 'optional' || node[_type] === 'peerOptional';\nconst isExtraneous = (node, {\n  global\n}) => node.extraneous && !global;\nconst getProblems = (node, {\n  global\n}) => {\n  const problems = new Set();\n  if (node[_missing] && !isOptional(node)) problems.add(`missing: ${node.pkgid}, required by ${node[_missing]}`);\n  if (node[_invalid]) problems.add(`invalid: ${node.pkgid} ${node.path}`);\n  if (isExtraneous(node, {\n    global\n  })) problems.add(`extraneous: ${node.pkgid} ${node.path}`);\n  return problems;\n};\n\n// annotates _parent and _include metadata into the resulting\n// item obj allowing for filtering out results during output\nconst augmentItemWithIncludeMetadata = (node, item) => {\n  item[_parent] = node[_parent];\n  item[_include] = node[_include];\n\n  // append current item to its parent.nodes which is the\n  // structure expected by archy in order to print tree\n  if (node[_include]) {\n    // includes all ancestors of included node\n    let p = node[_parent];\n    while (p) {\n      p[_include] = true;\n      p = p[_parent];\n    }\n  }\n  return item;\n};\nconst getHumanOutputItem = (node, {\n  args,\n  color,\n  global,\n  long\n}) => {\n  const {\n    pkgid,\n    path\n  } = node;\n  const workspacePkgId = color ? chalk.green(pkgid) : pkgid;\n  let printable = node.isWorkspace ? workspacePkgId : pkgid;\n\n  // special formatting for top-level package name\n  if (node.isRoot) {\n    const hasNoPackageJson = !Object.keys(node.package).length;\n    if (hasNoPackageJson || global) printable = path;else printable += `${long ? EOL : ' '}${path}`;\n  }\n  const highlightDepName = color && args.length && node[_filteredBy];\n  const missingColor = isOptional(node) ? chalk.yellow.bgBlack : chalk.red.bgBlack;\n  const missingMsg = `UNMET ${isOptional(node) ? 'OPTIONAL ' : ''}DEPENDENCY`;\n  const targetLocation = node.root ? relative(node.root.realpath, node.realpath) : node.targetLocation;\n  const invalid = node[_invalid] ? `invalid: ${node[_invalid]}` : '';\n  const label = (node[_missing] ? (color ? missingColor(missingMsg) : missingMsg) + ' ' : '') + `${highlightDepName ? chalk.yellow.bgBlack(printable) : printable}` + (node[_dedupe] ? ' ' + (color ? chalk.gray('deduped') : 'deduped') : '') + (invalid ? ' ' + (color ? chalk.red.bgBlack(invalid) : invalid) : '') + (isExtraneous(node, {\n    global\n  }) ? ' ' + (color ? chalk.green.bgBlack('extraneous') : 'extraneous') : '') + (isGitNode(node) ? ` (${node.resolved})` : '') + (node.isLink ? ` -> ${relativePrefix}${targetLocation}` : '') + (long ? `${EOL}${node.package.description || ''}` : '');\n  return augmentItemWithIncludeMetadata(node, {\n    label,\n    nodes: []\n  });\n};\nconst getJsonOutputItem = (node, {\n  global,\n  long\n}) => {\n  const item = {};\n  if (node.version) item.version = node.version;\n  if (node.resolved) item.resolved = node.resolved;\n  item[_name] = node.name;\n\n  // special formatting for top-level package name\n  const hasPackageJson = node && node.package && Object.keys(node.package).length;\n  if (node.isRoot && hasPackageJson) item.name = node.package.name || node.name;\n  if (long && !node[_missing]) {\n    item.name = item[_name];\n    const {\n      dependencies,\n      ...packageInfo\n    } = node.package;\n    Object.assign(item, packageInfo);\n    item.extraneous = false;\n    item.path = node.path;\n    item._dependencies = {\n      ...node.package.dependencies,\n      ...node.package.optionalDependencies\n    };\n    item.devDependencies = node.package.devDependencies || {};\n    item.peerDependencies = node.package.peerDependencies || {};\n  }\n\n  // augment json output items with extra metadata\n  if (isExtraneous(node, {\n    global\n  })) item.extraneous = true;\n  if (node[_invalid]) item.invalid = node[_invalid];\n  if (node[_missing] && !isOptional(node)) {\n    item.required = node[_required];\n    item.missing = true;\n  }\n  if (node[_include] && node[_problems] && node[_problems].size) item.problems = [...node[_problems]];\n  return augmentItemWithIncludeMetadata(node, item);\n};\nconst filterByEdgesTypes = ({\n  currentDepth,\n  dev,\n  development,\n  link,\n  prod,\n  production,\n  only\n}) => {\n  // filter deps by type, allows for: `npm ls --dev`, `npm ls --prod`,\n  // `npm ls --link`, `npm ls --only=dev`, etc\n  const filterDev = currentDepth === 0 && (dev || development || /^dev(elopment)?$/.test(only));\n  const filterProd = currentDepth === 0 && (prod || production || /^prod(uction)?$/.test(only));\n  const filterLink = currentDepth === 0 && link;\n  return edge => (filterDev ? edge.dev : true) && (filterProd ? !edge.dev && !edge.peer && !edge.peerOptional : true) && (filterLink ? edge.to && edge.to.isLink : true);\n};\nconst appendExtraneousChildren = ({\n  node,\n  seenPaths\n}) =>\n// extraneous children are not represented\n// in edges out, so here we add them to the list:\n[...node.children.values()].filter(i => !seenPaths.has(i.path) && i.extraneous);\nconst mapEdgesToNodes = ({\n  seenPaths\n}) => edge => {\n  let node = edge.to;\n\n  // if the edge is linking to a missing node, we go ahead\n  // and create a new obj that will represent the missing node\n  if (edge.missing || edge.optional && !node) {\n    const {\n      name,\n      spec\n    } = edge;\n    const pkgid = `${name}@${spec}`;\n    node = {\n      name,\n      pkgid,\n      [_missing]: edge.from.pkgid\n    };\n  }\n\n  // keeps track of a set of seen paths to avoid the edge case in which a tree\n  // item would appear twice given that it's a children of an extraneous item,\n  // so it's marked extraneous but it will ALSO show up in edgesOuts of\n  // its parent so it ends up as two diff nodes if we don't track it\n  if (node.path) seenPaths.add(node.path);\n  node[_required] = edge.spec || '*';\n  node[_type] = edge.type;\n  if (edge.invalid) {\n    const spec = JSON.stringify(node[_required]);\n    const from = edge.from.location || 'the root project';\n    node[_invalid] = (node[_invalid] ? node[_invalid] + ', ' : '') + `${spec} from ${from}`;\n  }\n  return node;\n};\nconst filterByPositionalArgs = (args, {\n  node\n}) => args.length > 0 ? args.some(spec => node.satisfies && node.satisfies(spec)) : true;\nconst augmentNodesWithMetadata = ({\n  args,\n  currentDepth,\n  nodeResult,\n  seenNodes\n}) => node => {\n  // if the original edge was a deduped dep, treeverse will fail to\n  // revisit that node in tree traversal logic, so we make it so that\n  // we have a diff obj for deduped nodes:\n  if (seenNodes.has(node.path)) {\n    const {\n      realpath,\n      root\n    } = node;\n    const targetLocation = root ? relative(root.realpath, realpath) : node.targetLocation;\n    node = {\n      name: node.name,\n      version: node.version,\n      pkgid: node.pkgid,\n      package: node.package,\n      path: node.path,\n      isLink: node.isLink,\n      realpath: node.realpath,\n      targetLocation,\n      [_type]: node[_type],\n      [_invalid]: node[_invalid],\n      [_missing]: node[_missing],\n      // if it's missing, it's not deduped, it's just missing\n      [_dedupe]: !node[_missing]\n    };\n  } else {\n    // keeps track of already seen nodes in order to check for dedupes\n    seenNodes.set(node.path, node);\n  }\n\n  // _parent is going to be a ref to a treeverse-visited node (returned from\n  // getHumanOutputItem, getJsonOutputItem, etc) so that we have an easy\n  // shortcut to place new nodes in their right place during tree traversal\n  node[_parent] = nodeResult;\n  // _include is the property that allow us to filter based on position args\n  // e.g: `npm ls foo`, `npm ls simple-output@2`\n  // _filteredBy is used to apply extra color info to the item that\n  // was used in args in order to filter\n  node[_filteredBy] = node[_include] = filterByPositionalArgs(args, {\n    node: seenNodes.get(node.path)\n  });\n  // _depth keeps track of how many levels deep tree traversal currently is\n  // so that we can `npm ls --depth=1`\n  node[_depth] = currentDepth + 1;\n  return node;\n};\nconst sortAlphabetically = ({\n  pkgid: a\n}, {\n  pkgid: b\n}) => localeCompare(a, b);\nconst humanOutput = ({\n  color,\n  result,\n  seenItems,\n  unicode\n}) => {\n  // we need to traverse the entire tree in order to determine which items\n  // should be included (since a nested transitive included dep will make it\n  // so that all its ancestors should be displayed)\n  // here is where we put items in their expected place for archy output\n  for (const item of seenItems) {\n    if (item[_include] && item[_parent]) item[_parent].nodes.push(item);\n  }\n  if (!result.nodes.length) result.nodes = ['(empty)'];\n  const archyOutput = archy(result, '', {\n    unicode\n  });\n  return color ? chalk.reset(archyOutput) : archyOutput;\n};\nconst jsonOutput = ({\n  path,\n  problems,\n  result,\n  rootError,\n  seenItems\n}) => {\n  if (problems.size) result.problems = [...problems];\n  if (rootError) {\n    result.problems = [...(result.problems || []), ...[`error in ${path}: Failed to parse root package.json`]];\n    result.invalid = true;\n  }\n\n  // we need to traverse the entire tree in order to determine which items\n  // should be included (since a nested transitive included dep will make it\n  // so that all its ancestors should be displayed)\n  // here is where we put items in their expected place for json output\n  for (const item of seenItems) {\n    // append current item to its parent item.dependencies obj in order\n    // to provide a json object structure that represents the installed tree\n    if (item[_include] && item[_parent]) {\n      if (!item[_parent].dependencies) item[_parent].dependencies = {};\n      item[_parent].dependencies[item[_name]] = item;\n    }\n  }\n  return JSON.stringify(result, null, 2);\n};\nconst parseableOutput = ({\n  global,\n  long,\n  seenNodes\n}) => {\n  let out = '';\n  for (const node of seenNodes.values()) {\n    if (node.path && node[_include]) {\n      out += node.path;\n      if (long) {\n        out += `:${node.pkgid}`;\n        out += node.path !== node.realpath ? `:${node.realpath}` : '';\n        out += isExtraneous(node, {\n          global\n        }) ? ':EXTRANEOUS' : '';\n        out += node[_invalid] ? ':INVALID' : '';\n      }\n      out += EOL;\n    }\n  }\n  return out.trim();\n};","map":{"version":3,"names":["resolve","relative","sep","require","relativePrefix","EOL","archy","chalk","Arborist","breadth","npa","completion","_depth","Symbol","_dedupe","_filteredBy","_include","_invalid","_name","_missing","_parent","_problems","_required","_type","ArboristWorkspaceCmd","localeCompare","LS","description","name","usage","params","opts","npm","exec","args","cb","ls","then","catch","all","config","get","color","depth","dev","development","global","json","link","long","only","parseable","prod","production","unicode","packageLockOnly","path","globalDir","prefix","arb","flatOptions","legacyPeerDeps","tree","initTree","wsNodes","workspaceNames","length","workspaceNodes","filterBySelectedWorkspaces","edge","from","isProjectRoot","to","isWorkspace","includes","target","seenItems","Set","seenNodes","Map","problems","filterDefaultDepth","Infinity","depthToPrint","set","result","getChildren","node","nodeResult","seenPaths","workspace","currentDepth","shouldSkipChildren","Node","edgesOut","values","filter","filterByEdgesTypes","map","mapEdgesToNodes","concat","appendExtraneousChildren","sort","sortAlphabetically","augmentNodesWithMetadata","visit","getProblems","item","getJsonOutputItem","getHumanOutputItem","problem","add","Promise","rootError","errors","e","code","output","jsonOutput","parseableOutput","humanOutput","process","exitCode","Object","assign","Error","shouldThrow","size","every","startsWith","join","loadVirtual","loadActual","module","exports","isGitNode","resolved","type","err","isOptional","isExtraneous","extraneous","pkgid","augmentItemWithIncludeMetadata","p","workspacePkgId","green","printable","isRoot","hasNoPackageJson","keys","package","highlightDepName","missingColor","yellow","bgBlack","red","missingMsg","targetLocation","root","realpath","invalid","label","gray","isLink","nodes","version","hasPackageJson","dependencies","packageInfo","_dependencies","optionalDependencies","devDependencies","peerDependencies","required","missing","filterDev","test","filterProd","filterLink","peer","peerOptional","children","i","has","optional","spec","JSON","stringify","location","filterByPositionalArgs","some","satisfies","a","b","push","archyOutput","reset","out","trim"],"sources":["C:/Users/Felo/node_modules/npm/lib/ls.js"],"sourcesContent":["const { resolve, relative, sep } = require('path')\nconst relativePrefix = `.${sep}`\nconst { EOL } = require('os')\n\nconst archy = require('archy')\nconst chalk = require('chalk')\nconst Arborist = require('@npmcli/arborist')\nconst { breadth } = require('treeverse')\nconst npa = require('npm-package-arg')\n\nconst completion = require('./utils/completion/installed-deep.js')\n\nconst _depth = Symbol('depth')\nconst _dedupe = Symbol('dedupe')\nconst _filteredBy = Symbol('filteredBy')\nconst _include = Symbol('include')\nconst _invalid = Symbol('invalid')\nconst _name = Symbol('name')\nconst _missing = Symbol('missing')\nconst _parent = Symbol('parent')\nconst _problems = Symbol('problems')\nconst _required = Symbol('required')\nconst _type = Symbol('type')\nconst ArboristWorkspaceCmd = require('./workspaces/arborist-cmd.js')\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\n\nclass LS extends ArboristWorkspaceCmd {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description () {\n    return 'List installed packages'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'ls'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return ['[[<@scope>/]<pkg> ...]']\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return [\n      'all',\n      'json',\n      'long',\n      'parseable',\n      'global',\n      'depth',\n      'omit',\n      'link',\n      'package-lock-only',\n      'unicode',\n      ...super.params,\n    ]\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  async completion (opts) {\n    return completion(this.npm, opts)\n  }\n\n  exec (args, cb) {\n    this.ls(args).then(() => cb()).catch(cb)\n  }\n\n  async ls (args) {\n    const all = this.npm.config.get('all')\n    const color = this.npm.color\n    const depth = this.npm.config.get('depth')\n    const dev = this.npm.config.get('dev')\n    const development = this.npm.config.get('development')\n    const global = this.npm.config.get('global')\n    const json = this.npm.config.get('json')\n    const link = this.npm.config.get('link')\n    const long = this.npm.config.get('long')\n    const only = this.npm.config.get('only')\n    const parseable = this.npm.config.get('parseable')\n    const prod = this.npm.config.get('prod')\n    const production = this.npm.config.get('production')\n    const unicode = this.npm.config.get('unicode')\n    const packageLockOnly = this.npm.config.get('package-lock-only')\n\n    const path = global ? resolve(this.npm.globalDir, '..') : this.npm.prefix\n\n    const arb = new Arborist({\n      global,\n      ...this.npm.flatOptions,\n      legacyPeerDeps: false,\n      path,\n    })\n    const tree = await this.initTree({arb, args, packageLockOnly })\n\n    // filters by workspaces nodes when using -w <workspace-name>\n    // We only have to filter the first layer of edges, so we don't\n    // explore anything that isn't part of the selected workspace set.\n    let wsNodes\n    if (this.workspaceNames && this.workspaceNames.length)\n      wsNodes = arb.workspaceNodes(tree, this.workspaceNames)\n    const filterBySelectedWorkspaces = edge => {\n      if (!wsNodes || !wsNodes.length)\n        return true\n\n      if (edge.from.isProjectRoot) {\n        return edge.to &&\n          edge.to.isWorkspace &\n          wsNodes.includes(edge.to.target)\n      }\n\n      return true\n    }\n\n    const seenItems = new Set()\n    const seenNodes = new Map()\n    const problems = new Set()\n\n    // defines special handling of printed depth when filtering with args\n    const filterDefaultDepth = depth === null ? Infinity : depth\n    const depthToPrint = (all || args.length)\n      ? filterDefaultDepth\n      : (depth || 0)\n\n    // add root node of tree to list of seenNodes\n    seenNodes.set(tree.path, tree)\n\n    // tree traversal happens here, using treeverse.breadth\n    const result = await breadth({\n      tree,\n      // recursive method, `node` is going to be the current elem (starting from\n      // the `tree` obj) that was just visited in the `visit` method below\n      // `nodeResult` is going to be the returned `item` from `visit`\n      getChildren (node, nodeResult) {\n        const seenPaths = new Set()\n        const workspace = node.isWorkspace\n        const currentDepth = workspace ? 0 : node[_depth]\n        const shouldSkipChildren =\n          !(node instanceof Arborist.Node) || (currentDepth > depthToPrint)\n        return (shouldSkipChildren)\n          ? []\n          : [...(node.target).edgesOut.values()]\n            .filter(filterBySelectedWorkspaces)\n            .filter(filterByEdgesTypes({\n              currentDepth,\n              dev,\n              development,\n              link,\n              prod,\n              production,\n              only,\n            }))\n            .map(mapEdgesToNodes({ seenPaths }))\n            .concat(appendExtraneousChildren({ node, seenPaths }))\n            .sort(sortAlphabetically)\n            .map(augmentNodesWithMetadata({\n              args,\n              currentDepth,\n              nodeResult,\n              seenNodes,\n            }))\n      },\n      // visit each `node` of the `tree`, returning an `item` - these are\n      // the elements that will be used to build the final output\n      visit (node) {\n        node[_problems] = getProblems(node, { global })\n\n        const item = json\n          ? getJsonOutputItem(node, { global, long })\n          : parseable\n            ? null\n            : getHumanOutputItem(node, { args, color, global, long })\n\n        // loop through list of node problems to add them to global list\n        if (node[_include]) {\n          for (const problem of node[_problems])\n            problems.add(problem)\n        }\n\n        seenItems.add(item)\n\n        // return a promise so we don't blow the stack\n        return Promise.resolve(item)\n      },\n    })\n\n    // handle the special case of a broken package.json in the root folder\n    const [rootError] = tree.errors.filter(e =>\n      e.code === 'EJSONPARSE' && e.path === resolve(path, 'package.json'))\n\n    this.npm.output(\n      json\n        ? jsonOutput({ path, problems, result, rootError, seenItems })\n        : parseable\n          ? parseableOutput({ seenNodes, global, long })\n          : humanOutput({ color, result, seenItems, unicode })\n    )\n\n    // if filtering items, should exit with error code on no results\n    if (result && !result[_include] && args.length)\n      process.exitCode = 1\n\n    if (rootError) {\n      throw Object.assign(\n        new Error('Failed to parse root package.json'),\n        { code: 'EJSONPARSE' }\n      )\n    }\n\n    const shouldThrow = problems.size &&\n      ![...problems].every(problem => problem.startsWith('extraneous:'))\n\n    if (shouldThrow) {\n      throw Object.assign(\n        new Error([...problems].join(EOL)),\n        { code: 'ELSPROBLEMS' }\n      )\n    }\n  }\n\n  async initTree ({ arb, args, packageLockOnly }) {\n    const tree = await (\n      packageLockOnly\n        ? arb.loadVirtual()\n        : arb.loadActual()\n    )\n\n    tree[_include] = args.length === 0\n    tree[_depth] = 0\n\n    return tree\n  }\n}\nmodule.exports = LS\n\nconst isGitNode = (node) => {\n  if (!node.resolved)\n    return\n\n  try {\n    const { type } = npa(node.resolved)\n    return type === 'git' || type === 'hosted'\n  } catch (err) {\n    return false\n  }\n}\n\nconst isOptional = (node) =>\n  node[_type] === 'optional' || node[_type] === 'peerOptional'\n\nconst isExtraneous = (node, { global }) =>\n  node.extraneous && !global\n\nconst getProblems = (node, { global }) => {\n  const problems = new Set()\n\n  if (node[_missing] && !isOptional(node))\n    problems.add(`missing: ${node.pkgid}, required by ${node[_missing]}`)\n\n  if (node[_invalid])\n    problems.add(`invalid: ${node.pkgid} ${node.path}`)\n\n  if (isExtraneous(node, { global }))\n    problems.add(`extraneous: ${node.pkgid} ${node.path}`)\n\n  return problems\n}\n\n// annotates _parent and _include metadata into the resulting\n// item obj allowing for filtering out results during output\nconst augmentItemWithIncludeMetadata = (node, item) => {\n  item[_parent] = node[_parent]\n  item[_include] = node[_include]\n\n  // append current item to its parent.nodes which is the\n  // structure expected by archy in order to print tree\n  if (node[_include]) {\n    // includes all ancestors of included node\n    let p = node[_parent]\n    while (p) {\n      p[_include] = true\n      p = p[_parent]\n    }\n  }\n\n  return item\n}\n\nconst getHumanOutputItem = (node, { args, color, global, long }) => {\n  const { pkgid, path } = node\n  const workspacePkgId = color ? chalk.green(pkgid) : pkgid\n  let printable = node.isWorkspace ? workspacePkgId : pkgid\n\n  // special formatting for top-level package name\n  if (node.isRoot) {\n    const hasNoPackageJson = !Object.keys(node.package).length\n    if (hasNoPackageJson || global)\n      printable = path\n    else\n      printable += `${long ? EOL : ' '}${path}`\n  }\n\n  const highlightDepName =\n    color && args.length && node[_filteredBy]\n  const missingColor = isOptional(node)\n    ? chalk.yellow.bgBlack\n    : chalk.red.bgBlack\n  const missingMsg = `UNMET ${isOptional(node) ? 'OPTIONAL ' : ''}DEPENDENCY`\n  const targetLocation = node.root\n    ? relative(node.root.realpath, node.realpath)\n    : node.targetLocation\n  const invalid = node[_invalid]\n    ? `invalid: ${node[_invalid]}`\n    : ''\n  const label =\n    (\n      node[_missing]\n        ? (color ? missingColor(missingMsg) : missingMsg) + ' '\n        : ''\n    ) +\n    `${highlightDepName ? chalk.yellow.bgBlack(printable) : printable}` +\n    (\n      node[_dedupe]\n        ? ' ' + (color ? chalk.gray('deduped') : 'deduped')\n        : ''\n    ) +\n    (\n      invalid\n        ? ' ' + (color ? chalk.red.bgBlack(invalid) : invalid)\n        : ''\n    ) +\n    (\n      isExtraneous(node, { global })\n        ? ' ' + (color ? chalk.green.bgBlack('extraneous') : 'extraneous')\n        : ''\n    ) +\n    (isGitNode(node) ? ` (${node.resolved})` : '') +\n    (node.isLink ? ` -> ${relativePrefix}${targetLocation}` : '') +\n    (long ? `${EOL}${node.package.description || ''}` : '')\n\n  return augmentItemWithIncludeMetadata(node, { label, nodes: [] })\n}\n\nconst getJsonOutputItem = (node, { global, long }) => {\n  const item = {}\n\n  if (node.version)\n    item.version = node.version\n\n  if (node.resolved)\n    item.resolved = node.resolved\n\n  item[_name] = node.name\n\n  // special formatting for top-level package name\n  const hasPackageJson =\n    node && node.package && Object.keys(node.package).length\n  if (node.isRoot && hasPackageJson)\n    item.name = node.package.name || node.name\n\n  if (long && !node[_missing]) {\n    item.name = item[_name]\n    const { dependencies, ...packageInfo } = node.package\n    Object.assign(item, packageInfo)\n    item.extraneous = false\n    item.path = node.path\n    item._dependencies = {\n      ...node.package.dependencies,\n      ...node.package.optionalDependencies,\n    }\n    item.devDependencies = node.package.devDependencies || {}\n    item.peerDependencies = node.package.peerDependencies || {}\n  }\n\n  // augment json output items with extra metadata\n  if (isExtraneous(node, { global }))\n    item.extraneous = true\n\n  if (node[_invalid])\n    item.invalid = node[_invalid]\n\n  if (node[_missing] && !isOptional(node)) {\n    item.required = node[_required]\n    item.missing = true\n  }\n  if (node[_include] && node[_problems] && node[_problems].size)\n    item.problems = [...node[_problems]]\n\n  return augmentItemWithIncludeMetadata(node, item)\n}\n\nconst filterByEdgesTypes = ({\n  currentDepth,\n  dev,\n  development,\n  link,\n  prod,\n  production,\n  only,\n}) => {\n  // filter deps by type, allows for: `npm ls --dev`, `npm ls --prod`,\n  // `npm ls --link`, `npm ls --only=dev`, etc\n  const filterDev = currentDepth === 0 &&\n    (dev || development || /^dev(elopment)?$/.test(only))\n  const filterProd = currentDepth === 0 &&\n    (prod || production || /^prod(uction)?$/.test(only))\n  const filterLink = currentDepth === 0 && link\n\n  return (edge) =>\n    (filterDev ? edge.dev : true) &&\n    (filterProd ? (!edge.dev && !edge.peer && !edge.peerOptional) : true) &&\n    (filterLink ? (edge.to && edge.to.isLink) : true)\n}\n\nconst appendExtraneousChildren = ({ node, seenPaths }) =>\n  // extraneous children are not represented\n  // in edges out, so here we add them to the list:\n  [...node.children.values()]\n    .filter(i => !seenPaths.has(i.path) && i.extraneous)\n\nconst mapEdgesToNodes = ({ seenPaths }) => (edge) => {\n  let node = edge.to\n\n  // if the edge is linking to a missing node, we go ahead\n  // and create a new obj that will represent the missing node\n  if (edge.missing || (edge.optional && !node)) {\n    const { name, spec } = edge\n    const pkgid = `${name}@${spec}`\n    node = { name, pkgid, [_missing]: edge.from.pkgid }\n  }\n\n  // keeps track of a set of seen paths to avoid the edge case in which a tree\n  // item would appear twice given that it's a children of an extraneous item,\n  // so it's marked extraneous but it will ALSO show up in edgesOuts of\n  // its parent so it ends up as two diff nodes if we don't track it\n  if (node.path)\n    seenPaths.add(node.path)\n\n  node[_required] = edge.spec || '*'\n  node[_type] = edge.type\n\n  if (edge.invalid) {\n    const spec = JSON.stringify(node[_required])\n    const from = edge.from.location || 'the root project'\n    node[_invalid] = (node[_invalid] ? node[_invalid] + ', ' : '') +\n      (`${spec} from ${from}`)\n  }\n\n  return node\n}\n\nconst filterByPositionalArgs = (args, { node }) =>\n  args.length > 0 ? args.some(\n    (spec) => (node.satisfies && node.satisfies(spec))\n  ) : true\n\nconst augmentNodesWithMetadata = ({\n  args,\n  currentDepth,\n  nodeResult,\n  seenNodes,\n}) => (node) => {\n  // if the original edge was a deduped dep, treeverse will fail to\n  // revisit that node in tree traversal logic, so we make it so that\n  // we have a diff obj for deduped nodes:\n  if (seenNodes.has(node.path)) {\n    const { realpath, root } = node\n    const targetLocation = root ? relative(root.realpath, realpath)\n      : node.targetLocation\n    node = {\n      name: node.name,\n      version: node.version,\n      pkgid: node.pkgid,\n      package: node.package,\n      path: node.path,\n      isLink: node.isLink,\n      realpath: node.realpath,\n      targetLocation,\n      [_type]: node[_type],\n      [_invalid]: node[_invalid],\n      [_missing]: node[_missing],\n      // if it's missing, it's not deduped, it's just missing\n      [_dedupe]: !node[_missing],\n    }\n  } else {\n    // keeps track of already seen nodes in order to check for dedupes\n    seenNodes.set(node.path, node)\n  }\n\n  // _parent is going to be a ref to a treeverse-visited node (returned from\n  // getHumanOutputItem, getJsonOutputItem, etc) so that we have an easy\n  // shortcut to place new nodes in their right place during tree traversal\n  node[_parent] = nodeResult\n  // _include is the property that allow us to filter based on position args\n  // e.g: `npm ls foo`, `npm ls simple-output@2`\n  // _filteredBy is used to apply extra color info to the item that\n  // was used in args in order to filter\n  node[_filteredBy] = node[_include] =\n    filterByPositionalArgs(args, { node: seenNodes.get(node.path) })\n  // _depth keeps track of how many levels deep tree traversal currently is\n  // so that we can `npm ls --depth=1`\n  node[_depth] = currentDepth + 1\n\n  return node\n}\n\nconst sortAlphabetically = ({ pkgid: a }, { pkgid: b }) => localeCompare(a, b)\n\nconst humanOutput = ({ color, result, seenItems, unicode }) => {\n  // we need to traverse the entire tree in order to determine which items\n  // should be included (since a nested transitive included dep will make it\n  // so that all its ancestors should be displayed)\n  // here is where we put items in their expected place for archy output\n  for (const item of seenItems) {\n    if (item[_include] && item[_parent])\n      item[_parent].nodes.push(item)\n  }\n\n  if (!result.nodes.length)\n    result.nodes = ['(empty)']\n\n  const archyOutput = archy(result, '', { unicode })\n  return color ? chalk.reset(archyOutput) : archyOutput\n}\n\nconst jsonOutput = ({ path, problems, result, rootError, seenItems }) => {\n  if (problems.size)\n    result.problems = [...problems]\n\n  if (rootError) {\n    result.problems = [\n      ...(result.problems || []),\n      ...[`error in ${path}: Failed to parse root package.json`],\n    ]\n    result.invalid = true\n  }\n\n  // we need to traverse the entire tree in order to determine which items\n  // should be included (since a nested transitive included dep will make it\n  // so that all its ancestors should be displayed)\n  // here is where we put items in their expected place for json output\n  for (const item of seenItems) {\n    // append current item to its parent item.dependencies obj in order\n    // to provide a json object structure that represents the installed tree\n    if (item[_include] && item[_parent]) {\n      if (!item[_parent].dependencies)\n        item[_parent].dependencies = {}\n\n      item[_parent].dependencies[item[_name]] = item\n    }\n  }\n\n  return JSON.stringify(result, null, 2)\n}\n\nconst parseableOutput = ({ global, long, seenNodes }) => {\n  let out = ''\n  for (const node of seenNodes.values()) {\n    if (node.path && node[_include]) {\n      out += node.path\n      if (long) {\n        out += `:${node.pkgid}`\n        out += node.path !== node.realpath ? `:${node.realpath}` : ''\n        out += isExtraneous(node, { global }) ? ':EXTRANEOUS' : ''\n        out += node[_invalid] ? ':INVALID' : ''\n      }\n      out += EOL\n    }\n  }\n  return out.trim()\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}