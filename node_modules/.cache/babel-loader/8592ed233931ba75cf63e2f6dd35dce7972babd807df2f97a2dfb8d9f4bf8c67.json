{"ast":null,"code":"// check to see if a bin is allowed to be overwritten\n// either rejects or resolves to nothing.  return value not relevant.\nconst isWindows = require('./is-windows.js');\nconst binTarget = require('./bin-target.js');\nconst {\n  resolve,\n  dirname\n} = require('path');\nconst readCmdShim = require('read-cmd-shim');\nconst fs = require('fs');\nconst {\n  promisify\n} = require('util');\nconst readlink = promisify(fs.readlink);\nconst checkBin = async ({\n  bin,\n  path,\n  top,\n  global,\n  force\n}) => {\n  // always ok to clobber when forced\n  // always ok to clobber local bins, or when forced\n  if (force || !global || !top) return;\n\n  // ok, need to make sure, then\n  const target = resolve(binTarget({\n    path,\n    top\n  }), bin);\n  path = resolve(path);\n  return isWindows ? checkShim({\n    target,\n    path\n  }) : checkLink({\n    target,\n    path\n  });\n};\n\n// only enoent is allowed.  anything else is a problem.\nconst handleReadLinkError = async ({\n  er,\n  target\n}) => er.code === 'ENOENT' ? null : failEEXIST({\n  target\n});\nconst checkLink = async ({\n  target,\n  path\n}) => {\n  const current = await readlink(target).catch(er => handleReadLinkError({\n    er,\n    target\n  }));\n  if (!current) return;\n  const resolved = resolve(dirname(target), current);\n  if (resolved.toLowerCase().indexOf(path.toLowerCase()) !== 0) return failEEXIST({\n    target\n  });\n};\nconst handleReadCmdShimError = ({\n  er,\n  target\n}) => er.code === 'ENOENT' ? null : failEEXIST({\n  target\n});\nconst failEEXIST = ({\n  target\n}) => Promise.reject(Object.assign(new Error('EEXIST: file already exists'), {\n  path: target,\n  code: 'EEXIST'\n}));\nconst checkShim = async ({\n  target,\n  path\n}) => {\n  const shims = [target, target + '.cmd', target + '.ps1'];\n  await Promise.all(shims.map(async target => {\n    const current = await readCmdShim(target).catch(er => handleReadCmdShimError({\n      er,\n      target\n    }));\n    if (!current) return;\n    const resolved = resolve(dirname(target), current.replace(/\\\\/g, '/'));\n    if (resolved.toLowerCase().indexOf(path.toLowerCase()) !== 0) return failEEXIST({\n      target\n    });\n  }));\n};\nmodule.exports = checkBin;","map":{"version":3,"names":["isWindows","require","binTarget","resolve","dirname","readCmdShim","fs","promisify","readlink","checkBin","bin","path","top","global","force","target","checkShim","checkLink","handleReadLinkError","er","code","failEEXIST","current","catch","resolved","toLowerCase","indexOf","handleReadCmdShimError","Promise","reject","Object","assign","Error","shims","all","map","replace","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/bin-links/lib/check-bin.js"],"sourcesContent":["// check to see if a bin is allowed to be overwritten\n// either rejects or resolves to nothing.  return value not relevant.\nconst isWindows = require('./is-windows.js')\nconst binTarget = require('./bin-target.js')\nconst {resolve, dirname} = require('path')\nconst readCmdShim = require('read-cmd-shim')\nconst fs = require('fs')\nconst {promisify} = require('util')\nconst readlink = promisify(fs.readlink)\n\nconst checkBin = async ({bin, path, top, global, force}) => {\n  // always ok to clobber when forced\n  // always ok to clobber local bins, or when forced\n  if (force || !global || !top)\n    return\n\n  // ok, need to make sure, then\n  const target = resolve(binTarget({path, top}), bin)\n  path = resolve(path)\n  return isWindows ? checkShim({target, path}) : checkLink({target, path})\n}\n\n// only enoent is allowed.  anything else is a problem.\nconst handleReadLinkError = async ({er, target}) =>\n  er.code === 'ENOENT' ? null\n  : failEEXIST({target})\n\nconst checkLink = async ({target, path}) => {\n  const current = await readlink(target)\n    .catch(er => handleReadLinkError({er, target}))\n\n  if (!current)\n    return\n\n  const resolved = resolve(dirname(target), current)\n\n  if (resolved.toLowerCase().indexOf(path.toLowerCase()) !== 0)\n    return failEEXIST({target})\n}\n\nconst handleReadCmdShimError = ({er, target}) =>\n  er.code === 'ENOENT' ? null\n  : failEEXIST({target})\n\nconst failEEXIST = ({target}) =>\n  Promise.reject(Object.assign(new Error('EEXIST: file already exists'), {\n    path: target,\n    code: 'EEXIST',\n  }))\n\nconst checkShim = async ({target, path}) => {\n  const shims = [\n    target,\n    target + '.cmd',\n    target + '.ps1',\n  ]\n  await Promise.all(shims.map(async target => {\n    const current = await readCmdShim(target)\n      .catch(er => handleReadCmdShimError({er, target}))\n\n    if (!current)\n      return\n\n    const resolved = resolve(dirname(target), current.replace(/\\\\/g, '/'))\n\n    if (resolved.toLowerCase().indexOf(path.toLowerCase()) !== 0)\n      return failEEXIST({target})\n  }))\n}\n\nmodule.exports = checkBin\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}