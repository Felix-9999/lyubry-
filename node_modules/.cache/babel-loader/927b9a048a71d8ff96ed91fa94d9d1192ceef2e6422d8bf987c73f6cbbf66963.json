{"ast":null,"code":"const {\n  resolve\n} = require('path');\nconst semver = require('semver');\nconst libnpmdiff = require('libnpmdiff');\nconst npa = require('npm-package-arg');\nconst Arborist = require('@npmcli/arborist');\nconst npmlog = require('npmlog');\nconst pacote = require('pacote');\nconst pickManifest = require('npm-pick-manifest');\nconst readPackageName = require('./utils/read-package-name.js');\nconst BaseCommand = require('./base-command.js');\nclass Diff extends BaseCommand {\n  static get description() {\n    return 'The registry diff command';\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name() {\n    return 'diff';\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage() {\n    return ['[...<paths>]'];\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params() {\n    return ['diff', 'diff-name-only', 'diff-unified', 'diff-ignore-all-space', 'diff-no-prefix', 'diff-src-prefix', 'diff-dst-prefix', 'diff-text', 'global', 'tag', 'workspace', 'workspaces'];\n  }\n  exec(args, cb) {\n    this.diff(args).then(() => cb()).catch(cb);\n  }\n  execWorkspaces(args, filters, cb) {\n    this.diffWorkspaces(args, filters).then(() => cb()).catch(cb);\n  }\n  async diff(args) {\n    const specs = this.npm.config.get('diff').filter(d => d);\n    if (specs.length > 2) {\n      throw new TypeError('Can\\'t use more than two --diff arguments.\\n\\n' + `Usage:\\n${this.usage}`);\n    }\n\n    // diffWorkspaces may have set this already\n    if (!this.prefix) this.prefix = this.npm.prefix;\n\n    // this is the \"top\" directory, one up from node_modules\n    // in global mode we have to walk one up from globalDir because our\n    // node_modules is sometimes under ./lib, and in global mode we're only ever\n    // walking through node_modules (because we will have been given a package\n    // name already)\n    if (this.npm.config.get('global')) this.top = resolve(this.npm.globalDir, '..');else this.top = this.prefix;\n    const [a, b] = await this.retrieveSpecs(specs);\n    npmlog.info('diff', {\n      src: a,\n      dst: b\n    });\n    const res = await libnpmdiff([a, b], {\n      ...this.npm.flatOptions,\n      diffFiles: args,\n      where: this.top\n    });\n    return this.npm.output(res);\n  }\n  async diffWorkspaces(args, filters) {\n    await this.setWorkspaces(filters);\n    for (const workspacePath of this.workspacePaths) {\n      this.top = workspacePath;\n      this.prefix = workspacePath;\n      await this.diff(args);\n    }\n  }\n\n  // get the package name from the packument at `path`\n  // throws if no packument is present OR if it does not have `name` attribute\n  async packageName(path) {\n    let name;\n    try {\n      name = await readPackageName(this.prefix);\n    } catch (e) {\n      npmlog.verbose('diff', 'could not read project dir package.json');\n    }\n    if (!name) throw this.usageError('Needs multiple arguments to compare or run from a project dir.\\n');\n    return name;\n  }\n  async retrieveSpecs([a, b]) {\n    if (a && b) {\n      const specs = await this.convertVersionsToSpecs([a, b]);\n      return this.findVersionsByPackageName(specs);\n    }\n\n    // no arguments, defaults to comparing cwd\n    // to its latest published registry version\n    if (!a) {\n      const pkgName = await this.packageName(this.prefix);\n      return [`${pkgName}@${this.npm.config.get('tag')}`, `file:${this.prefix}`];\n    }\n\n    // single argument, used to compare wanted versions of an\n    // installed dependency or to compare the cwd to a published version\n    let noPackageJson;\n    let pkgName;\n    try {\n      pkgName = await readPackageName(this.prefix);\n    } catch (e) {\n      npmlog.verbose('diff', 'could not read project dir package.json');\n      noPackageJson = true;\n    }\n    const missingPackageJson = this.usageError('Needs multiple arguments to compare or run from a project dir.\\n');\n\n    // using a valid semver range, that means it should just diff\n    // the cwd against a published version to the registry using the\n    // same project name and the provided semver range\n    if (semver.validRange(a)) {\n      if (!pkgName) throw missingPackageJson;\n      return [`${pkgName}@${a}`, `file:${this.prefix}`];\n    }\n\n    // when using a single package name as arg and it's part of the current\n    // install tree, then retrieve the current installed version and compare\n    // it against the same value `npm outdated` would suggest you to update to\n    const spec = npa(a);\n    if (spec.registry) {\n      let actualTree;\n      let node;\n      try {\n        const opts = {\n          ...this.npm.flatOptions,\n          path: this.top\n        };\n        const arb = new Arborist(opts);\n        actualTree = await arb.loadActual(opts);\n        node = actualTree && actualTree.inventory.query('name', spec.name).values().next().value;\n      } catch (e) {\n        npmlog.verbose('diff', 'failed to load actual install tree');\n      }\n      if (!node || !node.name || !node.package || !node.package.version) {\n        if (noPackageJson) throw missingPackageJson;\n        return [`${spec.name}@${spec.fetchSpec}`, `file:${this.prefix}`];\n      }\n      const tryRootNodeSpec = () => (actualTree && actualTree.edgesOut.get(spec.name) || {}).spec;\n      const tryAnySpec = () => {\n        for (const edge of node.edgesIn) return edge.spec;\n      };\n      const aSpec = `file:${node.realpath}`;\n\n      // finds what version of the package to compare against, if a exact\n      // version or tag was passed than it should use that, otherwise\n      // work from the top of the arborist tree to find the original semver\n      // range declared in the package that depends on the package.\n      let bSpec;\n      if (spec.rawSpec) bSpec = spec.rawSpec;else {\n        const bTargetVersion = tryRootNodeSpec() || tryAnySpec();\n\n        // figure out what to compare against,\n        // follows same logic to npm outdated \"Wanted\" results\n        const packument = await pacote.packument(spec, {\n          ...this.npm.flatOptions,\n          preferOnline: true\n        });\n        bSpec = pickManifest(packument, bTargetVersion, {\n          ...this.npm.flatOptions\n        }).version;\n      }\n      return [`${spec.name}@${aSpec}`, `${spec.name}@${bSpec}`];\n    } else if (spec.type === 'directory') {\n      return [`file:${spec.fetchSpec}`, `file:${this.prefix}`];\n    } else throw this.usageError(`Spec type ${spec.type} not supported.\\n`);\n  }\n  async convertVersionsToSpecs([a, b]) {\n    const semverA = semver.validRange(a);\n    const semverB = semver.validRange(b);\n\n    // both specs are semver versions, assume current project dir name\n    if (semverA && semverB) {\n      let pkgName;\n      try {\n        pkgName = await readPackageName(this.prefix);\n      } catch (e) {\n        npmlog.verbose('diff', 'could not read project dir package.json');\n      }\n      if (!pkgName) throw this.usageError('Needs to be run from a project dir in order to diff two versions.\\n');\n      return [`${pkgName}@${a}`, `${pkgName}@${b}`];\n    }\n\n    // otherwise uses the name from the other arg to\n    // figure out the spec.name of what to compare\n    if (!semverA && semverB) return [a, `${npa(a).name}@${b}`];\n    if (semverA && !semverB) return [`${npa(b).name}@${a}`, b];\n\n    // no valid semver ranges used\n    return [a, b];\n  }\n  async findVersionsByPackageName(specs) {\n    let actualTree;\n    try {\n      const opts = {\n        ...this.npm.flatOptions,\n        path: this.top\n      };\n      const arb = new Arborist(opts);\n      actualTree = await arb.loadActual(opts);\n    } catch (e) {\n      npmlog.verbose('diff', 'failed to load actual install tree');\n    }\n    return specs.map(i => {\n      const spec = npa(i);\n      if (spec.rawSpec) return i;\n      const node = actualTree && actualTree.inventory.query('name', spec.name).values().next().value;\n      const res = !node || !node.package || !node.package.version ? spec.fetchSpec : `file:${node.realpath}`;\n      return `${spec.name}@${res}`;\n    });\n  }\n}\nmodule.exports = Diff;","map":{"version":3,"names":["resolve","require","semver","libnpmdiff","npa","Arborist","npmlog","pacote","pickManifest","readPackageName","BaseCommand","Diff","description","name","usage","params","exec","args","cb","diff","then","catch","execWorkspaces","filters","diffWorkspaces","specs","npm","config","get","filter","d","length","TypeError","prefix","top","globalDir","a","b","retrieveSpecs","info","src","dst","res","flatOptions","diffFiles","where","output","setWorkspaces","workspacePath","workspacePaths","packageName","path","e","verbose","usageError","convertVersionsToSpecs","findVersionsByPackageName","pkgName","noPackageJson","missingPackageJson","validRange","spec","registry","actualTree","node","opts","arb","loadActual","inventory","query","values","next","value","package","version","fetchSpec","tryRootNodeSpec","edgesOut","tryAnySpec","edge","edgesIn","aSpec","realpath","bSpec","rawSpec","bTargetVersion","packument","preferOnline","type","semverA","semverB","map","i","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/lib/diff.js"],"sourcesContent":["const { resolve } = require('path')\n\nconst semver = require('semver')\nconst libnpmdiff = require('libnpmdiff')\nconst npa = require('npm-package-arg')\nconst Arborist = require('@npmcli/arborist')\nconst npmlog = require('npmlog')\nconst pacote = require('pacote')\nconst pickManifest = require('npm-pick-manifest')\n\nconst readPackageName = require('./utils/read-package-name.js')\nconst BaseCommand = require('./base-command.js')\n\nclass Diff extends BaseCommand {\n  static get description () {\n    return 'The registry diff command'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'diff'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return [\n      '[...<paths>]',\n    ]\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return [\n      'diff',\n      'diff-name-only',\n      'diff-unified',\n      'diff-ignore-all-space',\n      'diff-no-prefix',\n      'diff-src-prefix',\n      'diff-dst-prefix',\n      'diff-text',\n      'global',\n      'tag',\n      'workspace',\n      'workspaces',\n    ]\n  }\n\n  exec (args, cb) {\n    this.diff(args).then(() => cb()).catch(cb)\n  }\n\n  execWorkspaces (args, filters, cb) {\n    this.diffWorkspaces(args, filters).then(() => cb()).catch(cb)\n  }\n\n  async diff (args) {\n    const specs = this.npm.config.get('diff').filter(d => d)\n    if (specs.length > 2) {\n      throw new TypeError(\n        'Can\\'t use more than two --diff arguments.\\n\\n' +\n        `Usage:\\n${this.usage}`\n      )\n    }\n\n    // diffWorkspaces may have set this already\n    if (!this.prefix)\n      this.prefix = this.npm.prefix\n\n    // this is the \"top\" directory, one up from node_modules\n    // in global mode we have to walk one up from globalDir because our\n    // node_modules is sometimes under ./lib, and in global mode we're only ever\n    // walking through node_modules (because we will have been given a package\n    // name already)\n    if (this.npm.config.get('global'))\n      this.top = resolve(this.npm.globalDir, '..')\n    else\n      this.top = this.prefix\n\n    const [a, b] = await this.retrieveSpecs(specs)\n    npmlog.info('diff', { src: a, dst: b })\n\n    const res = await libnpmdiff([a, b], {\n      ...this.npm.flatOptions,\n      diffFiles: args,\n      where: this.top,\n    })\n    return this.npm.output(res)\n  }\n\n  async diffWorkspaces (args, filters) {\n    await this.setWorkspaces(filters)\n    for (const workspacePath of this.workspacePaths) {\n      this.top = workspacePath\n      this.prefix = workspacePath\n      await this.diff(args)\n    }\n  }\n\n  // get the package name from the packument at `path`\n  // throws if no packument is present OR if it does not have `name` attribute\n  async packageName (path) {\n    let name\n    try {\n      name = await readPackageName(this.prefix)\n    } catch (e) {\n      npmlog.verbose('diff', 'could not read project dir package.json')\n    }\n\n    if (!name)\n      throw this.usageError('Needs multiple arguments to compare or run from a project dir.\\n')\n\n    return name\n  }\n\n  async retrieveSpecs ([a, b]) {\n    if (a && b) {\n      const specs = await this.convertVersionsToSpecs([a, b])\n      return this.findVersionsByPackageName(specs)\n    }\n\n    // no arguments, defaults to comparing cwd\n    // to its latest published registry version\n    if (!a) {\n      const pkgName = await this.packageName(this.prefix)\n      return [\n        `${pkgName}@${this.npm.config.get('tag')}`,\n        `file:${this.prefix}`,\n      ]\n    }\n\n    // single argument, used to compare wanted versions of an\n    // installed dependency or to compare the cwd to a published version\n    let noPackageJson\n    let pkgName\n    try {\n      pkgName = await readPackageName(this.prefix)\n    } catch (e) {\n      npmlog.verbose('diff', 'could not read project dir package.json')\n      noPackageJson = true\n    }\n\n    const missingPackageJson = this.usageError('Needs multiple arguments to compare or run from a project dir.\\n')\n\n    // using a valid semver range, that means it should just diff\n    // the cwd against a published version to the registry using the\n    // same project name and the provided semver range\n    if (semver.validRange(a)) {\n      if (!pkgName)\n        throw missingPackageJson\n      return [\n        `${pkgName}@${a}`,\n        `file:${this.prefix}`,\n      ]\n    }\n\n    // when using a single package name as arg and it's part of the current\n    // install tree, then retrieve the current installed version and compare\n    // it against the same value `npm outdated` would suggest you to update to\n    const spec = npa(a)\n    if (spec.registry) {\n      let actualTree\n      let node\n      try {\n        const opts = {\n          ...this.npm.flatOptions,\n          path: this.top,\n        }\n        const arb = new Arborist(opts)\n        actualTree = await arb.loadActual(opts)\n        node = actualTree &&\n          actualTree.inventory.query('name', spec.name)\n            .values().next().value\n      } catch (e) {\n        npmlog.verbose('diff', 'failed to load actual install tree')\n      }\n\n      if (!node || !node.name || !node.package || !node.package.version) {\n        if (noPackageJson)\n          throw missingPackageJson\n        return [\n          `${spec.name}@${spec.fetchSpec}`,\n          `file:${this.prefix}`,\n        ]\n      }\n\n      const tryRootNodeSpec = () =>\n        (actualTree && actualTree.edgesOut.get(spec.name) || {}).spec\n\n      const tryAnySpec = () => {\n        for (const edge of node.edgesIn)\n          return edge.spec\n      }\n\n      const aSpec = `file:${node.realpath}`\n\n      // finds what version of the package to compare against, if a exact\n      // version or tag was passed than it should use that, otherwise\n      // work from the top of the arborist tree to find the original semver\n      // range declared in the package that depends on the package.\n      let bSpec\n      if (spec.rawSpec)\n        bSpec = spec.rawSpec\n      else {\n        const bTargetVersion =\n          tryRootNodeSpec()\n          || tryAnySpec()\n\n        // figure out what to compare against,\n        // follows same logic to npm outdated \"Wanted\" results\n        const packument = await pacote.packument(spec, {\n          ...this.npm.flatOptions,\n          preferOnline: true,\n        })\n        bSpec = pickManifest(\n          packument,\n          bTargetVersion,\n          { ...this.npm.flatOptions }\n        ).version\n      }\n\n      return [\n        `${spec.name}@${aSpec}`,\n        `${spec.name}@${bSpec}`,\n      ]\n    } else if (spec.type === 'directory') {\n      return [\n        `file:${spec.fetchSpec}`,\n        `file:${this.prefix}`,\n      ]\n    } else\n      throw this.usageError(`Spec type ${spec.type} not supported.\\n`)\n  }\n\n  async convertVersionsToSpecs ([a, b]) {\n    const semverA = semver.validRange(a)\n    const semverB = semver.validRange(b)\n\n    // both specs are semver versions, assume current project dir name\n    if (semverA && semverB) {\n      let pkgName\n      try {\n        pkgName = await readPackageName(this.prefix)\n      } catch (e) {\n        npmlog.verbose('diff', 'could not read project dir package.json')\n      }\n\n      if (!pkgName)\n        throw this.usageError('Needs to be run from a project dir in order to diff two versions.\\n')\n\n      return [`${pkgName}@${a}`, `${pkgName}@${b}`]\n    }\n\n    // otherwise uses the name from the other arg to\n    // figure out the spec.name of what to compare\n    if (!semverA && semverB)\n      return [a, `${npa(a).name}@${b}`]\n\n    if (semverA && !semverB)\n      return [`${npa(b).name}@${a}`, b]\n\n    // no valid semver ranges used\n    return [a, b]\n  }\n\n  async findVersionsByPackageName (specs) {\n    let actualTree\n    try {\n      const opts = {\n        ...this.npm.flatOptions,\n        path: this.top,\n      }\n      const arb = new Arborist(opts)\n      actualTree = await arb.loadActual(opts)\n    } catch (e) {\n      npmlog.verbose('diff', 'failed to load actual install tree')\n    }\n\n    return specs.map(i => {\n      const spec = npa(i)\n      if (spec.rawSpec)\n        return i\n\n      const node = actualTree\n        && actualTree.inventory.query('name', spec.name)\n          .values().next().value\n\n      const res = !node || !node.package || !node.package.version\n        ? spec.fetchSpec\n        : `file:${node.realpath}`\n\n      return `${spec.name}@${res}`\n    })\n  }\n}\n\nmodule.exports = Diff\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}