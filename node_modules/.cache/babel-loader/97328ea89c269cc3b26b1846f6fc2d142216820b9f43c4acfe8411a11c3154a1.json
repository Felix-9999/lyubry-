{"ast":null,"code":"const debug = require('./debug.js');\nconst relpath = require('./relpath.js');\nconst Node = require('./node.js');\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps');\nconst _target = Symbol.for('_target');\nconst {\n  dirname\n} = require('path');\n// defined by Node class\nconst _delistFromMeta = Symbol.for('_delistFromMeta');\nconst _refreshLocation = Symbol.for('_refreshLocation');\nclass Link extends Node {\n  constructor(options) {\n    const {\n      root,\n      realpath,\n      target,\n      parent,\n      fsParent\n    } = options;\n    if (!realpath && !(target && target.path)) {\n      throw new TypeError('must provide realpath for Link node');\n    }\n    super({\n      ...options,\n      realpath: realpath || target.path,\n      root: root || (parent ? parent.root : fsParent ? fsParent.root : target ? target.root : null)\n    });\n    if (target) {\n      this.target = target;\n    } else if (this.realpath === this.root.path) {\n      this.target = this.root;\n    } else {\n      this.target = new Node({\n        ...options,\n        path: realpath,\n        parent: null,\n        fsParent: null,\n        root: this.root\n      });\n    }\n  }\n  get version() {\n    return this.target ? this.target.version : this.package.version || '';\n  }\n  get target() {\n    return this[_target];\n  }\n  set target(target) {\n    const current = this[_target];\n    if (target === current) {\n      return;\n    }\n    if (current && current.then) {\n      debug(() => {\n        throw Object.assign(new Error('cannot set target while awaiting'), {\n          path: this.path,\n          realpath: this.realpath\n        });\n      });\n    }\n    if (target && target.then) {\n      // can set to a promise during an async tree build operation\n      // wait until then to assign it.\n      this[_target] = target;\n      target.then(node => {\n        this[_target] = null;\n        this.target = node;\n      });\n      return;\n    }\n    if (!target) {\n      if (current && current.linksIn) {\n        current.linksIn.delete(this);\n      }\n      if (this.path) {\n        this[_delistFromMeta]();\n        this[_target] = null;\n        this.package = {};\n        this[_refreshLocation]();\n      } else {\n        this[_target] = null;\n      }\n      return;\n    }\n    if (!this.path) {\n      // temp node pending assignment to a tree\n      // we know it's not in the inventory yet, because no path.\n      if (target.path) {\n        this.realpath = target.path;\n      } else {\n        target.path = target.realpath = this.realpath;\n      }\n      target.root = this.root;\n      this[_target] = target;\n      target.linksIn.add(this);\n      this.package = target.package;\n      return;\n    }\n\n    // have to refresh metadata, because either realpath or package\n    // is very likely changing.\n    this[_delistFromMeta]();\n    this.package = target.package;\n    this.realpath = target.path;\n    this[_refreshLocation]();\n    target.root = this.root;\n  }\n\n  // a link always resolves to the relative path to its target\n  get resolved() {\n    // the path/realpath guard is there for the benefit of setting\n    // these things in the \"wrong\" order\n    return this.path && this.realpath ? `file:${relpath(dirname(this.path), this.realpath)}` : null;\n  }\n  set resolved(r) {}\n\n  // deps are resolved on the target, not the Link\n  // so this is a no-op\n  [_loadDeps]() {}\n\n  // links can't have children, only their targets can\n  // fix it to an empty list so that we can still call\n  // things that iterate over them, just as a no-op\n  get children() {\n    return new Map();\n  }\n  set children(c) {}\n  get isLink() {\n    return true;\n  }\n}\nmodule.exports = Link;","map":{"version":3,"names":["debug","require","relpath","Node","_loadDeps","Symbol","for","_target","dirname","_delistFromMeta","_refreshLocation","Link","constructor","options","root","realpath","target","parent","fsParent","path","TypeError","version","package","current","then","Object","assign","Error","node","linksIn","delete","add","resolved","r","children","Map","c","isLink","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/link.js"],"sourcesContent":["const debug = require('./debug.js')\nconst relpath = require('./relpath.js')\nconst Node = require('./node.js')\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps')\nconst _target = Symbol.for('_target')\nconst {dirname} = require('path')\n// defined by Node class\nconst _delistFromMeta = Symbol.for('_delistFromMeta')\nconst _refreshLocation = Symbol.for('_refreshLocation')\nclass Link extends Node {\n  constructor (options) {\n    const { root, realpath, target, parent, fsParent } = options\n\n    if (!realpath && !(target && target.path)) {\n      throw new TypeError('must provide realpath for Link node')\n    }\n\n    super({\n      ...options,\n      realpath: realpath || target.path,\n      root: root || (parent ? parent.root\n      : fsParent ? fsParent.root\n      : target ? target.root\n      : null),\n    })\n\n    if (target) {\n      this.target = target\n    } else if (this.realpath === this.root.path) {\n      this.target = this.root\n    } else {\n      this.target = new Node({\n        ...options,\n        path: realpath,\n        parent: null,\n        fsParent: null,\n        root: this.root,\n      })\n    }\n  }\n\n  get version () {\n    return this.target ? this.target.version : this.package.version || ''\n  }\n\n  get target () {\n    return this[_target]\n  }\n\n  set target (target) {\n    const current = this[_target]\n    if (target === current) {\n      return\n    }\n\n    if (current && current.then) {\n      debug(() => {\n        throw Object.assign(new Error('cannot set target while awaiting'), {\n          path: this.path,\n          realpath: this.realpath,\n        })\n      })\n    }\n\n    if (target && target.then) {\n      // can set to a promise during an async tree build operation\n      // wait until then to assign it.\n      this[_target] = target\n      target.then(node => {\n        this[_target] = null\n        this.target = node\n      })\n      return\n    }\n\n    if (!target) {\n      if (current && current.linksIn) {\n        current.linksIn.delete(this)\n      }\n      if (this.path) {\n        this[_delistFromMeta]()\n        this[_target] = null\n        this.package = {}\n        this[_refreshLocation]()\n      } else {\n        this[_target] = null\n      }\n      return\n    }\n\n    if (!this.path) {\n      // temp node pending assignment to a tree\n      // we know it's not in the inventory yet, because no path.\n      if (target.path) {\n        this.realpath = target.path\n      } else {\n        target.path = target.realpath = this.realpath\n      }\n      target.root = this.root\n      this[_target] = target\n      target.linksIn.add(this)\n      this.package = target.package\n      return\n    }\n\n    // have to refresh metadata, because either realpath or package\n    // is very likely changing.\n    this[_delistFromMeta]()\n    this.package = target.package\n    this.realpath = target.path\n    this[_refreshLocation]()\n\n    target.root = this.root\n  }\n\n  // a link always resolves to the relative path to its target\n  get resolved () {\n    // the path/realpath guard is there for the benefit of setting\n    // these things in the \"wrong\" order\n    return this.path && this.realpath\n      ? `file:${relpath(dirname(this.path), this.realpath)}`\n      : null\n  }\n\n  set resolved (r) {}\n\n  // deps are resolved on the target, not the Link\n  // so this is a no-op\n  [_loadDeps] () {}\n\n  // links can't have children, only their targets can\n  // fix it to an empty list so that we can still call\n  // things that iterate over them, just as a no-op\n  get children () {\n    return new Map()\n  }\n\n  set children (c) {}\n\n  get isLink () {\n    return true\n  }\n}\n\nmodule.exports = Link\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}