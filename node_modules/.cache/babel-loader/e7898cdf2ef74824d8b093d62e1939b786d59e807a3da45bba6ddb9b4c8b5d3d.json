{"ast":null,"code":"// Given a node in a tree, return all of the peer dependency sets that\n// it is a part of, with the entry (top or non-peer) edges into the sets\n// identified.\n//\n// With this information, we can determine whether it is appropriate to\n// replace the entire peer set with another (and remove the old one),\n// push the set deeper into the tree, and so on.\n//\n// Returns a Map of { edge => Set(peerNodes) },\n\nconst peerEntrySets = node => {\n  // this is the union of all peer groups that the node is a part of\n  // later, we identify all of the entry edges, and create a set of\n  // 1 or more overlapping sets that this node is a part of.\n  const unionSet = new Set([node]);\n  for (const node of unionSet) {\n    for (const edge of node.edgesOut.values()) {\n      if (edge.valid && edge.peer && edge.to) {\n        unionSet.add(edge.to);\n      }\n    }\n    for (const edge of node.edgesIn) {\n      if (edge.valid && edge.peer) {\n        unionSet.add(edge.from);\n      }\n    }\n  }\n  const entrySets = new Map();\n  for (const peer of unionSet) {\n    for (const edge of peer.edgesIn) {\n      // if not valid, it doesn't matter anyway.  either it's been previously\n      // overridden, or it's the thing we're interested in replacing.\n      if (!edge.valid) {\n        continue;\n      }\n      // this is the entry point into the peer set\n      if (!edge.peer || edge.from.isTop) {\n        // get the subset of peer brought in by this peer entry edge\n        const sub = new Set([peer]);\n        for (const peer of sub) {\n          for (const edge of peer.edgesOut.values()) {\n            if (edge.valid && edge.peer && edge.to) {\n              sub.add(edge.to);\n            }\n          }\n        }\n        // if this subset does not include the node we are focused on,\n        // then it is not relevant for our purposes.  Example:\n        //\n        // a -> (b, c, d)\n        // b -> PEER(d) b -> d -> e -> f <-> g\n        // c -> PEER(f, h) c -> (f <-> g, h -> g)\n        // d -> PEER(e) d -> e -> f <-> g\n        // e -> PEER(f)\n        // f -> PEER(g)\n        // g -> PEER(f)\n        // h -> PEER(g)\n        //\n        // The unionSet(e) will include c, but we don't actually care about\n        // it.  We only expanded to the edge of the peer nodes in order to\n        // find the entry edges that caused the inclusion of peer sets\n        // including (e), so we want:\n        //   Map{\n        //     Edge(a->b) => Set(b, d, e, f, g)\n        //     Edge(a->d) => Set(d, e, f, g)\n        //   }\n        if (sub.has(node)) {\n          entrySets.set(edge, sub);\n        }\n      }\n    }\n  }\n  return entrySets;\n};\nmodule.exports = peerEntrySets;","map":{"version":3,"names":["peerEntrySets","node","unionSet","Set","edge","edgesOut","values","valid","peer","to","add","edgesIn","from","entrySets","Map","isTop","sub","has","set","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/peer-entry-sets.js"],"sourcesContent":["// Given a node in a tree, return all of the peer dependency sets that\n// it is a part of, with the entry (top or non-peer) edges into the sets\n// identified.\n//\n// With this information, we can determine whether it is appropriate to\n// replace the entire peer set with another (and remove the old one),\n// push the set deeper into the tree, and so on.\n//\n// Returns a Map of { edge => Set(peerNodes) },\n\nconst peerEntrySets = node => {\n  // this is the union of all peer groups that the node is a part of\n  // later, we identify all of the entry edges, and create a set of\n  // 1 or more overlapping sets that this node is a part of.\n  const unionSet = new Set([node])\n  for (const node of unionSet) {\n    for (const edge of node.edgesOut.values()) {\n      if (edge.valid && edge.peer && edge.to) {\n        unionSet.add(edge.to)\n      }\n    }\n    for (const edge of node.edgesIn) {\n      if (edge.valid && edge.peer) {\n        unionSet.add(edge.from)\n      }\n    }\n  }\n  const entrySets = new Map()\n  for (const peer of unionSet) {\n    for (const edge of peer.edgesIn) {\n      // if not valid, it doesn't matter anyway.  either it's been previously\n      // overridden, or it's the thing we're interested in replacing.\n      if (!edge.valid) {\n        continue\n      }\n      // this is the entry point into the peer set\n      if (!edge.peer || edge.from.isTop) {\n        // get the subset of peer brought in by this peer entry edge\n        const sub = new Set([peer])\n        for (const peer of sub) {\n          for (const edge of peer.edgesOut.values()) {\n            if (edge.valid && edge.peer && edge.to) {\n              sub.add(edge.to)\n            }\n          }\n        }\n        // if this subset does not include the node we are focused on,\n        // then it is not relevant for our purposes.  Example:\n        //\n        // a -> (b, c, d)\n        // b -> PEER(d) b -> d -> e -> f <-> g\n        // c -> PEER(f, h) c -> (f <-> g, h -> g)\n        // d -> PEER(e) d -> e -> f <-> g\n        // e -> PEER(f)\n        // f -> PEER(g)\n        // g -> PEER(f)\n        // h -> PEER(g)\n        //\n        // The unionSet(e) will include c, but we don't actually care about\n        // it.  We only expanded to the edge of the peer nodes in order to\n        // find the entry edges that caused the inclusion of peer sets\n        // including (e), so we want:\n        //   Map{\n        //     Edge(a->b) => Set(b, d, e, f, g)\n        //     Edge(a->d) => Set(d, e, f, g)\n        //   }\n        if (sub.has(node)) {\n          entrySets.set(edge, sub)\n        }\n      }\n    }\n  }\n\n  return entrySets\n}\n\nmodule.exports = peerEntrySets\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,aAAa,GAAGC,IAAI,IAAI;EAC5B;EACA;EACA;EACA,MAAMC,QAAQ,GAAG,IAAIC,GAAG,CAAC,CAACF,IAAI,CAAC,CAAC;EAChC,KAAK,MAAMA,IAAI,IAAIC,QAAQ,EAAE;IAC3B,KAAK,MAAME,IAAI,IAAIH,IAAI,CAACI,QAAQ,CAACC,MAAM,CAAC,CAAC,EAAE;MACzC,IAAIF,IAAI,CAACG,KAAK,IAAIH,IAAI,CAACI,IAAI,IAAIJ,IAAI,CAACK,EAAE,EAAE;QACtCP,QAAQ,CAACQ,GAAG,CAACN,IAAI,CAACK,EAAE,CAAC;MACvB;IACF;IACA,KAAK,MAAML,IAAI,IAAIH,IAAI,CAACU,OAAO,EAAE;MAC/B,IAAIP,IAAI,CAACG,KAAK,IAAIH,IAAI,CAACI,IAAI,EAAE;QAC3BN,QAAQ,CAACQ,GAAG,CAACN,IAAI,CAACQ,IAAI,CAAC;MACzB;IACF;EACF;EACA,MAAMC,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;EAC3B,KAAK,MAAMN,IAAI,IAAIN,QAAQ,EAAE;IAC3B,KAAK,MAAME,IAAI,IAAII,IAAI,CAACG,OAAO,EAAE;MAC/B;MACA;MACA,IAAI,CAACP,IAAI,CAACG,KAAK,EAAE;QACf;MACF;MACA;MACA,IAAI,CAACH,IAAI,CAACI,IAAI,IAAIJ,IAAI,CAACQ,IAAI,CAACG,KAAK,EAAE;QACjC;QACA,MAAMC,GAAG,GAAG,IAAIb,GAAG,CAAC,CAACK,IAAI,CAAC,CAAC;QAC3B,KAAK,MAAMA,IAAI,IAAIQ,GAAG,EAAE;UACtB,KAAK,MAAMZ,IAAI,IAAII,IAAI,CAACH,QAAQ,CAACC,MAAM,CAAC,CAAC,EAAE;YACzC,IAAIF,IAAI,CAACG,KAAK,IAAIH,IAAI,CAACI,IAAI,IAAIJ,IAAI,CAACK,EAAE,EAAE;cACtCO,GAAG,CAACN,GAAG,CAACN,IAAI,CAACK,EAAE,CAAC;YAClB;UACF;QACF;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,IAAIO,GAAG,CAACC,GAAG,CAAChB,IAAI,CAAC,EAAE;UACjBY,SAAS,CAACK,GAAG,CAACd,IAAI,EAAEY,GAAG,CAAC;QAC1B;MACF;IACF;EACF;EAEA,OAAOH,SAAS;AAClB,CAAC;AAEDM,MAAM,CAACC,OAAO,GAAGpB,aAAa","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}