{"ast":null,"code":"// mix-in implementing the loadActual method\n\nconst {\n  relative,\n  dirname,\n  resolve,\n  join,\n  normalize\n} = require('path');\nconst rpj = require('read-package-json-fast');\nconst {\n  promisify\n} = require('util');\nconst readdir = promisify(require('readdir-scoped-modules'));\nconst walkUp = require('walk-up-path');\nconst ancestorPath = require('common-ancestor-path');\nconst treeCheck = require('../tree-check.js');\nconst Shrinkwrap = require('../shrinkwrap.js');\nconst calcDepFlags = require('../calc-dep-flags.js');\nconst Node = require('../node.js');\nconst Link = require('../link.js');\nconst realpath = require('../realpath.js');\nconst _loadFSNode = Symbol('loadFSNode');\nconst _newNode = Symbol('newNode');\nconst _newLink = Symbol('newLink');\nconst _loadFSTree = Symbol('loadFSTree');\nconst _loadFSChildren = Symbol('loadFSChildren');\nconst _findMissingEdges = Symbol('findMissingEdges');\nconst _findFSParents = Symbol('findFSParents');\nconst _resetDepFlags = Symbol('resetDepFlags');\nconst _actualTreeLoaded = Symbol('actualTreeLoaded');\nconst _rpcache = Symbol.for('realpathCache');\nconst _stcache = Symbol.for('statCache');\nconst _topNodes = Symbol('linkTargets');\nconst _cache = Symbol('nodeLoadingCache');\nconst _loadActual = Symbol('loadActual');\nconst _loadActualVirtually = Symbol('loadActualVirtually');\nconst _loadActualActually = Symbol('loadActualActually');\nconst _loadWorkspaces = Symbol.for('loadWorkspaces');\nconst _loadWorkspaceTargets = Symbol('loadWorkspaceTargets');\nconst _actualTreePromise = Symbol('actualTreePromise');\nconst _actualTree = Symbol('actualTree');\nconst _transplant = Symbol('transplant');\nconst _transplantFilter = Symbol('transplantFilter');\nconst _filter = Symbol('filter');\nconst _global = Symbol.for('global');\nconst _changePath = Symbol.for('_changePath');\nmodule.exports = cls => class ActualLoader extends cls {\n  constructor(options) {\n    super(options);\n    this[_global] = !!options.global;\n\n    // the tree of nodes on disk\n    this.actualTree = options.actualTree;\n\n    // ensure when walking the tree that we don't call loadTree on the\n    // same actual node more than one time.\n    this[_actualTreeLoaded] = new Set();\n\n    // caches for cached realpath calls\n    const cwd = process.cwd();\n    // assume that the cwd is real enough for our purposes\n    this[_rpcache] = new Map([[cwd, cwd]]);\n    this[_stcache] = new Map();\n\n    // cache of nodes when loading the actualTree, so that we avoid\n    // loaded the same node multiple times when symlinks attack.\n    this[_cache] = new Map();\n\n    // cache of link targets for setting fsParent links\n    // We don't do fsParent as a magic getter/setter, because\n    // it'd be too costly to keep up to date along the walk.\n    // And, we know that it can ONLY be relevant when the node\n    // is a target of a link, otherwise it'd be in a node_modules\n    // folder, so take advantage of that to limit the scans later.\n    this[_topNodes] = new Set();\n  }\n  [_resetDepFlags](tree, root) {\n    // reset all deps to extraneous prior to recalc\n    if (!root) {\n      for (const node of tree.inventory.values()) {\n        node.extraneous = true;\n      }\n    }\n\n    // only reset root flags if we're not re-rooting,\n    // otherwise leave as-is\n    calcDepFlags(tree, !root);\n    return tree;\n  }\n\n  // public method\n  async loadActual(options = {}) {\n    // allow the user to set options on the ctor as well.\n    // XXX: deprecate separate method options objects.\n    options = {\n      ...this.options,\n      ...options\n    };\n\n    // stash the promise so that we don't ever have more than one\n    // going at the same time.  This is so that buildIdealTree can\n    // default to the actualTree if no shrinkwrap present, but\n    // reify() can still call buildIdealTree and loadActual in parallel\n    // safely.\n    return this.actualTree ? this.actualTree : this[_actualTreePromise] ? this[_actualTreePromise] : this[_actualTreePromise] = this[_loadActual](options).then(tree => this[_resetDepFlags](tree, options.root)).then(tree => this.actualTree = treeCheck(tree));\n  }\n  async [_loadActual](options) {\n    // mostly realpath to throw if the root doesn't exist\n    const {\n      global = false,\n      filter = () => true,\n      root = null,\n      transplantFilter = () => true,\n      ignoreMissing = false\n    } = options;\n    this[_filter] = filter;\n    this[_transplantFilter] = transplantFilter;\n    if (global) {\n      const real = await realpath(this.path, this[_rpcache], this[_stcache]);\n      const newNodeOrLink = this.path === real ? _newNode : _newLink;\n      this[_actualTree] = await this[newNodeOrLink]({\n        path: this.path,\n        realpath: real,\n        pkg: {},\n        global\n      });\n      return this[_loadActualActually]({\n        root,\n        ignoreMissing,\n        global\n      });\n    }\n\n    // not in global mode, hidden lockfile is allowed, load root pkg too\n    this[_actualTree] = await this[_loadFSNode]({\n      path: this.path,\n      real: await realpath(this.path, this[_rpcache], this[_stcache])\n    });\n\n    // XXX only rely on this if the hidden lockfile is the newest thing?\n    // need some kind of heuristic, like if the package.json or sw have\n    // been touched more recently, then ignore it?  This is a hazard if\n    // user switches back and forth between Arborist and another way of\n    // mutating the node_modules folder.\n    const meta = await Shrinkwrap.load({\n      path: this[_actualTree].path,\n      hiddenLockfile: true\n    });\n    if (meta.loadedFromDisk) {\n      this[_actualTree].meta = meta;\n      return this[_loadActualVirtually]({\n        root\n      });\n    } else {\n      const meta = await Shrinkwrap.load({\n        path: this[_actualTree].path\n      });\n      this[_actualTree].meta = meta;\n      return this[_loadActualActually]({\n        root,\n        ignoreMissing\n      });\n    }\n  }\n  async [_loadActualVirtually]({\n    root\n  }) {\n    // have to load on a new Arborist object, so we don't assign\n    // the virtualTree on this one!  Also, the weird reference is because\n    // we can't easily get a ref to Arborist in this module, without\n    // creating a circular reference, since this class is a mixin used\n    // to build up the Arborist class itself.\n    await new this.constructor({\n      ...this.options\n    }).loadVirtual({\n      root: this[_actualTree]\n    });\n    await this[_loadWorkspaces](this[_actualTree]);\n    this[_transplant](root);\n    return this[_actualTree];\n  }\n  async [_loadActualActually]({\n    root,\n    ignoreMissing,\n    global\n  }) {\n    await this[_loadFSTree](this[_actualTree]);\n    await this[_loadWorkspaces](this[_actualTree]);\n    await this[_loadWorkspaceTargets](this[_actualTree]);\n    if (!ignoreMissing) {\n      await this[_findMissingEdges]();\n    }\n    this[_findFSParents]();\n    this[_transplant](root);\n    if (global) {\n      // need to depend on the children, or else all of them\n      // will end up being flagged as extraneous, since the\n      // global root isn't a \"real\" project\n      const tree = this[_actualTree];\n      const actualRoot = tree.isLink ? tree.target : tree;\n      const {\n        dependencies = {}\n      } = actualRoot.package;\n      for (const [name, kid] of actualRoot.children.entries()) {\n        const def = kid.isLink ? `file:${kid.realpath}` : '*';\n        dependencies[name] = dependencies[name] || def;\n      }\n      actualRoot.package = {\n        ...actualRoot.package,\n        dependencies\n      };\n    }\n    return this[_actualTree];\n  }\n\n  // if there are workspace targets without Link nodes created, load\n  // the targets, so that we know what they are.\n  async [_loadWorkspaceTargets](tree) {\n    if (!tree.workspaces || !tree.workspaces.size) {\n      return;\n    }\n    const promises = [];\n    for (const path of tree.workspaces.values()) {\n      if (!this[_cache].has(path)) {\n        const p = this[_loadFSNode]({\n          path,\n          root: this[_actualTree]\n        }).then(node => this[_loadFSTree](node));\n        promises.push(p);\n      }\n    }\n    await Promise.all(promises);\n  }\n  [_transplant](root) {\n    if (!root || root === this[_actualTree]) {\n      return;\n    }\n    this[_actualTree][_changePath](root.path);\n    for (const node of this[_actualTree].children.values()) {\n      if (!this[_transplantFilter](node)) {\n        node.root = null;\n      }\n    }\n    root.replace(this[_actualTree]);\n    for (const node of this[_actualTree].fsChildren) {\n      node.root = this[_transplantFilter](node) ? root : null;\n    }\n    this[_actualTree] = root;\n  }\n  [_loadFSNode]({\n    path,\n    parent,\n    real,\n    root\n  }) {\n    if (!real) {\n      return realpath(path, this[_rpcache], this[_stcache]).then(real => this[_loadFSNode]({\n        path,\n        parent,\n        real,\n        root\n      }),\n      // if realpath fails, just provide a dummy error node\n      error => new Node({\n        error,\n        path,\n        realpath: path,\n        parent,\n        root\n      }));\n    }\n\n    // cache temporarily holds a promise placeholder so we don't try to create\n    // the same node multiple times.  this is rare to encounter, given the\n    // aggressive caching on realpath and lstat calls, but it's possible that\n    // it's already loaded as a tree top, and then gets its parent loaded\n    // later, if a symlink points deeper in the tree.\n    const cached = this[_cache].get(path);\n    if (cached && !cached.dummy) {\n      return Promise.resolve(cached).then(node => {\n        node.parent = parent;\n        return node;\n      });\n    }\n    const p = rpj(join(real, 'package.json'))\n    // soldier on if read-package-json raises an error\n    .then(pkg => [pkg, null], error => [null, error]).then(([pkg, error]) => {\n      return this[normalize(path) === real ? _newNode : _newLink]({\n        legacyPeerDeps: this.legacyPeerDeps,\n        path,\n        realpath: real,\n        pkg,\n        error,\n        parent,\n        root\n      });\n    }).then(node => {\n      this[_cache].set(path, node);\n      return node;\n    });\n    this[_cache].set(path, p);\n    return p;\n  }\n\n  // this is the way it is to expose a timing issue which is difficult to\n  // test otherwise.  The creation of a Node may take slightly longer than\n  // the creation of a Link that targets it.  If the Node has _begun_ its\n  // creation phase (and put a Promise in the cache) then the Link will\n  // get a Promise as its cachedTarget instead of an actual Node object.\n  // This is not a problem, because it gets resolved prior to returning\n  // the tree or attempting to load children.  However, it IS remarkably\n  // difficult to get to happen in a test environment to verify reliably.\n  // Hence this kludge.\n  [_newNode](options) {\n    // check it for an fsParent if it's a tree top.  there's a decent chance\n    // it'll get parented later, making the fsParent scan a no-op, but better\n    // safe than sorry, since it's cheap.\n    const {\n      parent,\n      realpath\n    } = options;\n    if (!parent) {\n      this[_topNodes].add(realpath);\n    }\n    return process.env._TEST_ARBORIST_SLOW_LINK_TARGET_ === '1' ? new Promise(res => setTimeout(() => res(new Node(options)), 100)) : new Node(options);\n  }\n  [_newLink](options) {\n    const {\n      realpath\n    } = options;\n    this[_topNodes].add(realpath);\n    const target = this[_cache].get(realpath);\n    const link = new Link({\n      ...options,\n      target\n    });\n    if (!target) {\n      this[_cache].set(realpath, link.target);\n      // if a link target points at a node outside of the root tree's\n      // node_modules hierarchy, then load that node as well.\n      return this[_loadFSTree](link.target).then(() => link);\n    } else if (target.then) {\n      target.then(node => link.target = node);\n    }\n    return link;\n  }\n  [_loadFSTree](node) {\n    const did = this[_actualTreeLoaded];\n    node = node.target;\n\n    // if a Link target has started, but not completed, then\n    // a Promise will be in the cache to indicate this.\n    if (node.then) {\n      return node.then(node => this[_loadFSTree](node));\n    }\n\n    // impossible except in pathological ELOOP cases\n    /* istanbul ignore if */\n    if (did.has(node.realpath)) {\n      return Promise.resolve(node);\n    }\n    did.add(node.realpath);\n    return this[_loadFSChildren](node).then(() => Promise.all([...node.children.entries()].filter(([name, kid]) => !did.has(kid.realpath)).map(([name, kid]) => this[_loadFSTree](kid))));\n  }\n\n  // create child nodes for all the entries in node_modules\n  // and attach them to the node as a parent\n  [_loadFSChildren](node) {\n    const nm = resolve(node.realpath, 'node_modules');\n    return readdir(nm).then(kids => {\n      return Promise.all(\n      // ignore . dirs and retired scoped package folders\n      kids.filter(kid => !/^(@[^/]+\\/)?\\./.test(kid)).filter(kid => this[_filter](node, kid)).map(kid => this[_loadFSNode]({\n        parent: node,\n        path: resolve(nm, kid)\n      })));\n    },\n    // error in the readdir is not fatal, just means no kids\n    () => {});\n  }\n  async [_findMissingEdges]() {\n    // try to resolve any missing edges by walking up the directory tree,\n    // checking for the package in each node_modules folder.  stop at the\n    // root directory.\n    // The tricky move here is that we load a \"dummy\" node for the folder\n    // containing the node_modules folder, so that it can be assigned as\n    // the fsParent.  It's a bad idea to *actually* load that full node,\n    // because people sometimes develop in ~/projects/node_modules/...\n    // so we'd end up loading a massive tree with lots of unrelated junk.\n    const nmContents = new Map();\n    const tree = this[_actualTree];\n    for (const node of tree.inventory.values()) {\n      const ancestor = ancestorPath(node.realpath, this.path);\n      const depPromises = [];\n      for (const [name, edge] of node.edgesOut.entries()) {\n        const notMissing = !edge.missing && !(edge.to && (edge.to.dummy || edge.to.parent !== node));\n        if (notMissing) {\n          continue;\n        }\n\n        // start the walk from the dirname, because we would have found\n        // the dep in the loadFSTree step already if it was local.\n        for (const p of walkUp(dirname(node.realpath))) {\n          // only walk as far as the nearest ancestor\n          // this keeps us from going into completely unrelated\n          // places when a project is just missing something, but\n          // allows for finding the transitive deps of link targets.\n          // ie, if it has to go up and back out to get to the path\n          // from the nearest common ancestor, we've gone too far.\n          if (ancestor && /^\\.\\.(?:[\\\\/]|$)/.test(relative(ancestor, p))) {\n            break;\n          }\n          const entries = nmContents.get(p) || (await readdir(p + '/node_modules').catch(() => []));\n          nmContents.set(p, entries);\n          if (!entries.includes(name)) {\n            continue;\n          }\n          const d = this[_cache].has(p) ? await this[_cache].get(p) : new Node({\n            path: p,\n            root: node.root,\n            dummy: true\n          });\n          this[_cache].set(p, d);\n          if (d.dummy) {\n            // it's a placeholder, so likely would not have loaded this dep,\n            // unless another dep in the tree also needs it.\n            const depPath = `${p}/node_modules/${name}`;\n            const cached = this[_cache].get(depPath);\n            if (!cached || cached.dummy) {\n              depPromises.push(this[_loadFSNode]({\n                path: depPath,\n                root: node.root,\n                parent: d\n              }).then(node => this[_loadFSTree](node)));\n            }\n          }\n          break;\n        }\n      }\n      await Promise.all(depPromises);\n    }\n  }\n\n  // try to find a node that is the parent in a fs tree sense, but not a\n  // node_modules tree sense, of any link targets.  this allows us to\n  // resolve deps that node will find, but a legacy npm view of the\n  // world would not have noticed.\n  [_findFSParents]() {\n    for (const path of this[_topNodes]) {\n      const node = this[_cache].get(path);\n      if (node && !node.parent && !node.fsParent) {\n        for (const p of walkUp(dirname(path))) {\n          if (this[_cache].has(p)) {\n            node.fsParent = this[_cache].get(p);\n            break;\n          }\n        }\n      }\n    }\n  }\n};","map":{"version":3,"names":["relative","dirname","resolve","join","normalize","require","rpj","promisify","readdir","walkUp","ancestorPath","treeCheck","Shrinkwrap","calcDepFlags","Node","Link","realpath","_loadFSNode","Symbol","_newNode","_newLink","_loadFSTree","_loadFSChildren","_findMissingEdges","_findFSParents","_resetDepFlags","_actualTreeLoaded","_rpcache","for","_stcache","_topNodes","_cache","_loadActual","_loadActualVirtually","_loadActualActually","_loadWorkspaces","_loadWorkspaceTargets","_actualTreePromise","_actualTree","_transplant","_transplantFilter","_filter","_global","_changePath","module","exports","cls","ActualLoader","constructor","options","global","actualTree","Set","cwd","process","Map","tree","root","node","inventory","values","extraneous","loadActual","then","filter","transplantFilter","ignoreMissing","real","path","newNodeOrLink","pkg","meta","load","hiddenLockfile","loadedFromDisk","loadVirtual","actualRoot","isLink","target","dependencies","package","name","kid","children","entries","def","workspaces","size","promises","has","p","push","Promise","all","replace","fsChildren","parent","error","cached","get","dummy","legacyPeerDeps","set","add","env","_TEST_ARBORIST_SLOW_LINK_TARGET_","res","setTimeout","link","did","map","nm","kids","test","nmContents","ancestor","depPromises","edge","edgesOut","notMissing","missing","to","catch","includes","d","depPath","fsParent"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/load-actual.js"],"sourcesContent":["// mix-in implementing the loadActual method\n\nconst {relative, dirname, resolve, join, normalize} = require('path')\n\nconst rpj = require('read-package-json-fast')\nconst {promisify} = require('util')\nconst readdir = promisify(require('readdir-scoped-modules'))\nconst walkUp = require('walk-up-path')\nconst ancestorPath = require('common-ancestor-path')\nconst treeCheck = require('../tree-check.js')\n\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst realpath = require('../realpath.js')\n\nconst _loadFSNode = Symbol('loadFSNode')\nconst _newNode = Symbol('newNode')\nconst _newLink = Symbol('newLink')\nconst _loadFSTree = Symbol('loadFSTree')\nconst _loadFSChildren = Symbol('loadFSChildren')\nconst _findMissingEdges = Symbol('findMissingEdges')\nconst _findFSParents = Symbol('findFSParents')\nconst _resetDepFlags = Symbol('resetDepFlags')\n\nconst _actualTreeLoaded = Symbol('actualTreeLoaded')\nconst _rpcache = Symbol.for('realpathCache')\nconst _stcache = Symbol.for('statCache')\nconst _topNodes = Symbol('linkTargets')\nconst _cache = Symbol('nodeLoadingCache')\nconst _loadActual = Symbol('loadActual')\nconst _loadActualVirtually = Symbol('loadActualVirtually')\nconst _loadActualActually = Symbol('loadActualActually')\nconst _loadWorkspaces = Symbol.for('loadWorkspaces')\nconst _loadWorkspaceTargets = Symbol('loadWorkspaceTargets')\nconst _actualTreePromise = Symbol('actualTreePromise')\nconst _actualTree = Symbol('actualTree')\nconst _transplant = Symbol('transplant')\nconst _transplantFilter = Symbol('transplantFilter')\n\nconst _filter = Symbol('filter')\nconst _global = Symbol.for('global')\nconst _changePath = Symbol.for('_changePath')\n\nmodule.exports = cls => class ActualLoader extends cls {\n  constructor (options) {\n    super(options)\n\n    this[_global] = !!options.global\n\n    // the tree of nodes on disk\n    this.actualTree = options.actualTree\n\n    // ensure when walking the tree that we don't call loadTree on the\n    // same actual node more than one time.\n    this[_actualTreeLoaded] = new Set()\n\n    // caches for cached realpath calls\n    const cwd = process.cwd()\n    // assume that the cwd is real enough for our purposes\n    this[_rpcache] = new Map([[cwd, cwd]])\n    this[_stcache] = new Map()\n\n    // cache of nodes when loading the actualTree, so that we avoid\n    // loaded the same node multiple times when symlinks attack.\n    this[_cache] = new Map()\n\n    // cache of link targets for setting fsParent links\n    // We don't do fsParent as a magic getter/setter, because\n    // it'd be too costly to keep up to date along the walk.\n    // And, we know that it can ONLY be relevant when the node\n    // is a target of a link, otherwise it'd be in a node_modules\n    // folder, so take advantage of that to limit the scans later.\n    this[_topNodes] = new Set()\n  }\n\n  [_resetDepFlags] (tree, root) {\n    // reset all deps to extraneous prior to recalc\n    if (!root) {\n      for (const node of tree.inventory.values()) {\n        node.extraneous = true\n      }\n    }\n\n    // only reset root flags if we're not re-rooting,\n    // otherwise leave as-is\n    calcDepFlags(tree, !root)\n    return tree\n  }\n\n  // public method\n  async loadActual (options = {}) {\n    // allow the user to set options on the ctor as well.\n    // XXX: deprecate separate method options objects.\n    options = { ...this.options, ...options }\n\n    // stash the promise so that we don't ever have more than one\n    // going at the same time.  This is so that buildIdealTree can\n    // default to the actualTree if no shrinkwrap present, but\n    // reify() can still call buildIdealTree and loadActual in parallel\n    // safely.\n    return this.actualTree ? this.actualTree\n      : this[_actualTreePromise] ? this[_actualTreePromise]\n      : this[_actualTreePromise] = this[_loadActual](options)\n        .then(tree => this[_resetDepFlags](tree, options.root))\n        .then(tree => this.actualTree = treeCheck(tree))\n  }\n\n  async [_loadActual] (options) {\n    // mostly realpath to throw if the root doesn't exist\n    const {\n      global = false,\n      filter = () => true,\n      root = null,\n      transplantFilter = () => true,\n      ignoreMissing = false,\n    } = options\n    this[_filter] = filter\n    this[_transplantFilter] = transplantFilter\n\n    if (global) {\n      const real = await realpath(this.path, this[_rpcache], this[_stcache])\n      const newNodeOrLink = this.path === real ? _newNode : _newLink\n      this[_actualTree] = await this[newNodeOrLink]({\n        path: this.path,\n        realpath: real,\n        pkg: {},\n        global,\n      })\n      return this[_loadActualActually]({root, ignoreMissing, global})\n    }\n\n    // not in global mode, hidden lockfile is allowed, load root pkg too\n    this[_actualTree] = await this[_loadFSNode]({\n      path: this.path,\n      real: await realpath(this.path, this[_rpcache], this[_stcache]),\n    })\n\n    // XXX only rely on this if the hidden lockfile is the newest thing?\n    // need some kind of heuristic, like if the package.json or sw have\n    // been touched more recently, then ignore it?  This is a hazard if\n    // user switches back and forth between Arborist and another way of\n    // mutating the node_modules folder.\n    const meta = await Shrinkwrap.load({\n      path: this[_actualTree].path,\n      hiddenLockfile: true,\n    })\n    if (meta.loadedFromDisk) {\n      this[_actualTree].meta = meta\n      return this[_loadActualVirtually]({ root })\n    } else {\n      const meta = await Shrinkwrap.load({\n        path: this[_actualTree].path,\n      })\n      this[_actualTree].meta = meta\n      return this[_loadActualActually]({ root, ignoreMissing })\n    }\n  }\n\n  async [_loadActualVirtually] ({ root }) {\n    // have to load on a new Arborist object, so we don't assign\n    // the virtualTree on this one!  Also, the weird reference is because\n    // we can't easily get a ref to Arborist in this module, without\n    // creating a circular reference, since this class is a mixin used\n    // to build up the Arborist class itself.\n    await new this.constructor({...this.options}).loadVirtual({\n      root: this[_actualTree],\n    })\n    await this[_loadWorkspaces](this[_actualTree])\n\n    this[_transplant](root)\n    return this[_actualTree]\n  }\n\n  async [_loadActualActually] ({ root, ignoreMissing, global }) {\n    await this[_loadFSTree](this[_actualTree])\n    await this[_loadWorkspaces](this[_actualTree])\n    await this[_loadWorkspaceTargets](this[_actualTree])\n    if (!ignoreMissing) {\n      await this[_findMissingEdges]()\n    }\n    this[_findFSParents]()\n    this[_transplant](root)\n\n    if (global) {\n      // need to depend on the children, or else all of them\n      // will end up being flagged as extraneous, since the\n      // global root isn't a \"real\" project\n      const tree = this[_actualTree]\n      const actualRoot = tree.isLink ? tree.target : tree\n      const { dependencies = {} } = actualRoot.package\n      for (const [name, kid] of actualRoot.children.entries()) {\n        const def = kid.isLink ? `file:${kid.realpath}` : '*'\n        dependencies[name] = dependencies[name] || def\n      }\n      actualRoot.package = { ...actualRoot.package, dependencies }\n    }\n    return this[_actualTree]\n  }\n\n  // if there are workspace targets without Link nodes created, load\n  // the targets, so that we know what they are.\n  async [_loadWorkspaceTargets] (tree) {\n    if (!tree.workspaces || !tree.workspaces.size) {\n      return\n    }\n\n    const promises = []\n    for (const path of tree.workspaces.values()) {\n      if (!this[_cache].has(path)) {\n        const p = this[_loadFSNode]({ path, root: this[_actualTree] })\n          .then(node => this[_loadFSTree](node))\n        promises.push(p)\n      }\n    }\n    await Promise.all(promises)\n  }\n\n  [_transplant] (root) {\n    if (!root || root === this[_actualTree]) {\n      return\n    }\n\n    this[_actualTree][_changePath](root.path)\n    for (const node of this[_actualTree].children.values()) {\n      if (!this[_transplantFilter](node)) {\n        node.root = null\n      }\n    }\n\n    root.replace(this[_actualTree])\n    for (const node of this[_actualTree].fsChildren) {\n      node.root = this[_transplantFilter](node) ? root : null\n    }\n\n    this[_actualTree] = root\n  }\n\n  [_loadFSNode] ({ path, parent, real, root }) {\n    if (!real) {\n      return realpath(path, this[_rpcache], this[_stcache])\n        .then(\n          real => this[_loadFSNode]({ path, parent, real, root }),\n          // if realpath fails, just provide a dummy error node\n          error => new Node({ error, path, realpath: path, parent, root })\n        )\n    }\n\n    // cache temporarily holds a promise placeholder so we don't try to create\n    // the same node multiple times.  this is rare to encounter, given the\n    // aggressive caching on realpath and lstat calls, but it's possible that\n    // it's already loaded as a tree top, and then gets its parent loaded\n    // later, if a symlink points deeper in the tree.\n    const cached = this[_cache].get(path)\n    if (cached && !cached.dummy) {\n      return Promise.resolve(cached).then(node => {\n        node.parent = parent\n        return node\n      })\n    }\n\n    const p = rpj(join(real, 'package.json'))\n      // soldier on if read-package-json raises an error\n      .then(pkg => [pkg, null], error => [null, error])\n      .then(([pkg, error]) => {\n        return this[normalize(path) === real ? _newNode : _newLink]({\n          legacyPeerDeps: this.legacyPeerDeps,\n          path,\n          realpath: real,\n          pkg,\n          error,\n          parent,\n          root,\n        })\n      })\n      .then(node => {\n        this[_cache].set(path, node)\n        return node\n      })\n\n    this[_cache].set(path, p)\n    return p\n  }\n\n  // this is the way it is to expose a timing issue which is difficult to\n  // test otherwise.  The creation of a Node may take slightly longer than\n  // the creation of a Link that targets it.  If the Node has _begun_ its\n  // creation phase (and put a Promise in the cache) then the Link will\n  // get a Promise as its cachedTarget instead of an actual Node object.\n  // This is not a problem, because it gets resolved prior to returning\n  // the tree or attempting to load children.  However, it IS remarkably\n  // difficult to get to happen in a test environment to verify reliably.\n  // Hence this kludge.\n  [_newNode] (options) {\n    // check it for an fsParent if it's a tree top.  there's a decent chance\n    // it'll get parented later, making the fsParent scan a no-op, but better\n    // safe than sorry, since it's cheap.\n    const { parent, realpath } = options\n    if (!parent) {\n      this[_topNodes].add(realpath)\n    }\n    return process.env._TEST_ARBORIST_SLOW_LINK_TARGET_ === '1'\n      ? new Promise(res => setTimeout(() => res(new Node(options)), 100))\n      : new Node(options)\n  }\n\n  [_newLink] (options) {\n    const { realpath } = options\n    this[_topNodes].add(realpath)\n    const target = this[_cache].get(realpath)\n    const link = new Link({ ...options, target })\n\n    if (!target) {\n      this[_cache].set(realpath, link.target)\n      // if a link target points at a node outside of the root tree's\n      // node_modules hierarchy, then load that node as well.\n      return this[_loadFSTree](link.target).then(() => link)\n    } else if (target.then) {\n      target.then(node => link.target = node)\n    }\n\n    return link\n  }\n\n  [_loadFSTree] (node) {\n    const did = this[_actualTreeLoaded]\n    node = node.target\n\n    // if a Link target has started, but not completed, then\n    // a Promise will be in the cache to indicate this.\n    if (node.then) {\n      return node.then(node => this[_loadFSTree](node))\n    }\n\n    // impossible except in pathological ELOOP cases\n    /* istanbul ignore if */\n    if (did.has(node.realpath)) {\n      return Promise.resolve(node)\n    }\n\n    did.add(node.realpath)\n    return this[_loadFSChildren](node)\n      .then(() => Promise.all(\n        [...node.children.entries()]\n          .filter(([name, kid]) => !did.has(kid.realpath))\n          .map(([name, kid]) => this[_loadFSTree](kid))))\n  }\n\n  // create child nodes for all the entries in node_modules\n  // and attach them to the node as a parent\n  [_loadFSChildren] (node) {\n    const nm = resolve(node.realpath, 'node_modules')\n    return readdir(nm).then(kids => {\n      return Promise.all(\n      // ignore . dirs and retired scoped package folders\n        kids.filter(kid => !/^(@[^/]+\\/)?\\./.test(kid))\n          .filter(kid => this[_filter](node, kid))\n          .map(kid => this[_loadFSNode]({\n            parent: node,\n            path: resolve(nm, kid),\n          })))\n    },\n    // error in the readdir is not fatal, just means no kids\n    () => {})\n  }\n\n  async [_findMissingEdges] () {\n    // try to resolve any missing edges by walking up the directory tree,\n    // checking for the package in each node_modules folder.  stop at the\n    // root directory.\n    // The tricky move here is that we load a \"dummy\" node for the folder\n    // containing the node_modules folder, so that it can be assigned as\n    // the fsParent.  It's a bad idea to *actually* load that full node,\n    // because people sometimes develop in ~/projects/node_modules/...\n    // so we'd end up loading a massive tree with lots of unrelated junk.\n    const nmContents = new Map()\n    const tree = this[_actualTree]\n    for (const node of tree.inventory.values()) {\n      const ancestor = ancestorPath(node.realpath, this.path)\n\n      const depPromises = []\n      for (const [name, edge] of node.edgesOut.entries()) {\n        const notMissing = !edge.missing &&\n          !(edge.to && (edge.to.dummy || edge.to.parent !== node))\n        if (notMissing) {\n          continue\n        }\n\n        // start the walk from the dirname, because we would have found\n        // the dep in the loadFSTree step already if it was local.\n        for (const p of walkUp(dirname(node.realpath))) {\n          // only walk as far as the nearest ancestor\n          // this keeps us from going into completely unrelated\n          // places when a project is just missing something, but\n          // allows for finding the transitive deps of link targets.\n          // ie, if it has to go up and back out to get to the path\n          // from the nearest common ancestor, we've gone too far.\n          if (ancestor && /^\\.\\.(?:[\\\\/]|$)/.test(relative(ancestor, p))) {\n            break\n          }\n\n          const entries = nmContents.get(p) ||\n            await readdir(p + '/node_modules').catch(() => [])\n          nmContents.set(p, entries)\n          if (!entries.includes(name)) {\n            continue\n          }\n\n          const d = this[_cache].has(p) ? await this[_cache].get(p)\n            : new Node({ path: p, root: node.root, dummy: true })\n          this[_cache].set(p, d)\n          if (d.dummy) {\n            // it's a placeholder, so likely would not have loaded this dep,\n            // unless another dep in the tree also needs it.\n            const depPath = `${p}/node_modules/${name}`\n            const cached = this[_cache].get(depPath)\n            if (!cached || cached.dummy) {\n              depPromises.push(this[_loadFSNode]({\n                path: depPath,\n                root: node.root,\n                parent: d,\n              }).then(node => this[_loadFSTree](node)))\n            }\n          }\n          break\n        }\n      }\n      await Promise.all(depPromises)\n    }\n  }\n\n  // try to find a node that is the parent in a fs tree sense, but not a\n  // node_modules tree sense, of any link targets.  this allows us to\n  // resolve deps that node will find, but a legacy npm view of the\n  // world would not have noticed.\n  [_findFSParents] () {\n    for (const path of this[_topNodes]) {\n      const node = this[_cache].get(path)\n      if (node && !node.parent && !node.fsParent) {\n        for (const p of walkUp(dirname(path))) {\n          if (this[_cache].has(p)) {\n            node.fsParent = this[_cache].get(p)\n            break\n          }\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}