{"ast":null,"code":"const {\n  promisify\n} = require('util');\nconst path = require('path');\nconst getName = require('@npmcli/name-from-folder');\nconst minimatch = require('minimatch');\nconst rpj = require('read-package-json-fast');\nconst glob = require('glob');\nconst pGlob = promisify(glob);\nfunction appendNegatedPatterns(patterns) {\n  const results = [];\n  for (let pattern of patterns) {\n    const excl = pattern.match(/^!+/);\n    if (excl) {\n      pattern = pattern.substr(excl[0].length);\n    }\n\n    // strip off any / from the start of the pattern.  /foo => foo\n    pattern = pattern.replace(/^\\/+/, '');\n\n    // an odd number of ! means a negated pattern.  !!foo ==> foo\n    const negate = excl && excl[0].length % 2 === 1;\n    results.push({\n      pattern,\n      negate\n    });\n  }\n  return results;\n}\nfunction getPatterns(workspaces) {\n  const workspacesDeclaration = Array.isArray(workspaces.packages) ? workspaces.packages : workspaces;\n  if (!Array.isArray(workspacesDeclaration)) {\n    throw getError({\n      message: 'workspaces config expects an Array',\n      code: 'EWORKSPACESCONFIG'\n    });\n  }\n  return [...appendNegatedPatterns(workspacesDeclaration), {\n    pattern: '**/node_modules/**',\n    negate: true\n  }];\n}\nfunction isEmpty(patterns) {\n  return patterns.length < 2;\n}\nfunction getPackageName(pkg, pathname) {\n  const {\n    name\n  } = pkg;\n  return name || getName(pathname);\n}\nfunction pkgPathmame(opts) {\n  return (...args) => {\n    const cwd = opts.cwd ? opts.cwd : process.cwd();\n    return path.join.apply(null, [cwd, ...args]);\n  };\n}\n\n// make sure glob pattern only matches folders\nfunction getGlobPattern(pattern) {\n  return pattern.endsWith('/') ? pattern : `${pattern}/`;\n}\nfunction getError({\n  Type = TypeError,\n  message,\n  code\n}) {\n  return Object.assign(new Type(message), {\n    code\n  });\n}\nfunction reverseResultMap(map) {\n  return new Map(Array.from(map, item => item.reverse()));\n}\nasync function mapWorkspaces(opts = {}) {\n  if (!opts || !opts.pkg) {\n    throw getError({\n      message: 'mapWorkspaces missing pkg info',\n      code: 'EMAPWORKSPACESPKG'\n    });\n  }\n  const {\n    workspaces = []\n  } = opts.pkg;\n  const patterns = getPatterns(workspaces);\n  const results = new Map();\n  const seen = new Map();\n  if (isEmpty(patterns)) {\n    return results;\n  }\n  const getGlobOpts = () => ({\n    ...opts,\n    ignore: [...(opts.ignore || []), ...['**/node_modules/**']]\n  });\n  const getPackagePathname = pkgPathmame(opts);\n  for (const item of patterns) {\n    const matches = await pGlob(getGlobPattern(item.pattern), getGlobOpts());\n    for (const match of matches) {\n      let pkg;\n      const packageJsonPathname = getPackagePathname(match, 'package.json');\n      const packagePathname = path.dirname(packageJsonPathname);\n      try {\n        pkg = await rpj(packageJsonPathname);\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          continue;\n        } else {\n          throw err;\n        }\n      }\n      const name = getPackageName(pkg, packagePathname);\n      if (item.negate) {\n        results.delete(packagePathname, name);\n      } else {\n        if (seen.has(name) && seen.get(name) !== packagePathname) {\n          throw getError({\n            Type: Error,\n            message: ['must not have multiple workspaces with the same name', `package '${name}' has conflicts in the following paths:`, '    ' + seen.get(name), '    ' + packagePathname].join('\\n'),\n            code: 'EDUPLICATEWORKSPACE'\n          });\n        }\n        seen.set(name, packagePathname);\n        results.set(packagePathname, name);\n      }\n    }\n  }\n  return reverseResultMap(results);\n}\nmapWorkspaces.virtual = function (opts = {}) {\n  if (!opts || !opts.lockfile) {\n    throw getError({\n      message: 'mapWorkspaces.virtual missing lockfile info',\n      code: 'EMAPWORKSPACESLOCKFILE'\n    });\n  }\n  const {\n    packages = {}\n  } = opts.lockfile;\n  const {\n    workspaces = []\n  } = packages[''] || {};\n  const patterns = getPatterns(workspaces);\n\n  // uses a pathname-keyed map in order to negate the exact items\n  const results = new Map();\n  if (isEmpty(patterns)) {\n    return results;\n  }\n  const getPackagePathname = pkgPathmame(opts);\n  for (const packageKey of Object.keys(packages)) {\n    if (packageKey === '') {\n      continue;\n    }\n    for (const item of patterns) {\n      if (minimatch(packageKey, item.pattern)) {\n        const packagePathname = getPackagePathname(packageKey);\n        const name = getPackageName(packages[packageKey], packagePathname);\n        if (item.negate) {\n          results.delete(packagePathname);\n        } else {\n          results.set(packagePathname, name);\n        }\n      }\n    }\n  }\n\n  // Invert pathname-keyed to a proper name-to-pathnames Map\n  return reverseResultMap(results);\n};\nmodule.exports = mapWorkspaces;","map":{"version":3,"names":["promisify","require","path","getName","minimatch","rpj","glob","pGlob","appendNegatedPatterns","patterns","results","pattern","excl","match","substr","length","replace","negate","push","getPatterns","workspaces","workspacesDeclaration","Array","isArray","packages","getError","message","code","isEmpty","getPackageName","pkg","pathname","name","pkgPathmame","opts","args","cwd","process","join","apply","getGlobPattern","endsWith","Type","TypeError","Object","assign","reverseResultMap","map","Map","from","item","reverse","mapWorkspaces","seen","getGlobOpts","ignore","getPackagePathname","matches","packageJsonPathname","packagePathname","dirname","err","delete","has","get","Error","set","virtual","lockfile","packageKey","keys","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/map-workspaces/index.js"],"sourcesContent":["const { promisify } = require('util')\nconst path = require('path')\n\nconst getName = require('@npmcli/name-from-folder')\nconst minimatch = require('minimatch')\nconst rpj = require('read-package-json-fast')\nconst glob = require('glob')\nconst pGlob = promisify(glob)\n\nfunction appendNegatedPatterns (patterns) {\n  const results = []\n  for (let pattern of patterns) {\n    const excl = pattern.match(/^!+/)\n    if (excl) {\n      pattern = pattern.substr(excl[0].length)\n    }\n\n    // strip off any / from the start of the pattern.  /foo => foo\n    pattern = pattern.replace(/^\\/+/, '')\n\n    // an odd number of ! means a negated pattern.  !!foo ==> foo\n    const negate = excl && excl[0].length % 2 === 1\n    results.push({ pattern, negate })\n  }\n\n  return results\n}\n\nfunction getPatterns (workspaces) {\n  const workspacesDeclaration =\n    Array.isArray(workspaces.packages)\n      ? workspaces.packages\n      : workspaces\n\n  if (!Array.isArray(workspacesDeclaration)) {\n    throw getError({\n      message: 'workspaces config expects an Array',\n      code: 'EWORKSPACESCONFIG'\n    })\n  }\n\n  return [\n    ...appendNegatedPatterns(workspacesDeclaration),\n    { pattern: '**/node_modules/**', negate: true }\n  ]\n}\n\nfunction isEmpty (patterns) {\n  return patterns.length < 2\n}\n\nfunction getPackageName (pkg, pathname) {\n  const { name } = pkg\n  return name || getName(pathname)\n}\n\nfunction pkgPathmame (opts) {\n  return (...args) => {\n    const cwd = opts.cwd ? opts.cwd : process.cwd()\n    return path.join.apply(null, [cwd, ...args])\n  }\n}\n\n// make sure glob pattern only matches folders\nfunction getGlobPattern (pattern) {\n  return pattern.endsWith('/')\n    ? pattern\n    : `${pattern}/`\n}\n\nfunction getError ({ Type = TypeError, message, code }) {\n  return Object.assign(new Type(message), { code })\n}\n\nfunction reverseResultMap (map) {\n  return new Map(Array.from(map, item => item.reverse()))\n}\n\nasync function mapWorkspaces (opts = {}) {\n  if (!opts || !opts.pkg) {\n    throw getError({\n      message: 'mapWorkspaces missing pkg info',\n      code: 'EMAPWORKSPACESPKG'\n    })\n  }\n\n  const { workspaces = [] } = opts.pkg\n  const patterns = getPatterns(workspaces)\n  const results = new Map()\n  const seen = new Map()\n\n  if (isEmpty(patterns)) {\n    return results\n  }\n\n  const getGlobOpts = () => ({\n    ...opts,\n    ignore: [\n      ...opts.ignore || [],\n      ...['**/node_modules/**']\n    ]\n  })\n\n  const getPackagePathname = pkgPathmame(opts)\n\n  for (const item of patterns) {\n    const matches = await pGlob(getGlobPattern(item.pattern), getGlobOpts())\n\n    for (const match of matches) {\n      let pkg\n      const packageJsonPathname = getPackagePathname(match, 'package.json')\n      const packagePathname = path.dirname(packageJsonPathname)\n\n      try {\n        pkg = await rpj(packageJsonPathname)\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          continue\n        } else {\n          throw err\n        }\n      }\n\n      const name = getPackageName(pkg, packagePathname)\n\n      if (item.negate) {\n        results.delete(packagePathname, name)\n      } else {\n        if (seen.has(name) && seen.get(name) !== packagePathname) {\n          throw getError({\n            Type: Error,\n            message: [\n              'must not have multiple workspaces with the same name',\n              `package '${name}' has conflicts in the following paths:`,\n              '    ' + seen.get(name),\n              '    ' + packagePathname\n            ].join('\\n'),\n            code: 'EDUPLICATEWORKSPACE'\n          })\n        }\n\n        seen.set(name, packagePathname)\n        results.set(packagePathname, name)\n      }\n    }\n  }\n\n  return reverseResultMap(results)\n}\n\nmapWorkspaces.virtual = function (opts = {}) {\n  if (!opts || !opts.lockfile) {\n    throw getError({\n      message: 'mapWorkspaces.virtual missing lockfile info',\n      code: 'EMAPWORKSPACESLOCKFILE'\n    })\n  }\n\n  const { packages = {} } = opts.lockfile\n  const { workspaces = [] } = packages[''] || {}\n  const patterns = getPatterns(workspaces)\n\n  // uses a pathname-keyed map in order to negate the exact items\n  const results = new Map()\n\n  if (isEmpty(patterns)) {\n    return results\n  }\n\n  const getPackagePathname = pkgPathmame(opts)\n\n  for (const packageKey of Object.keys(packages)) {\n    if (packageKey === '') {\n      continue\n    }\n\n    for (const item of patterns) {\n      if (minimatch(packageKey, item.pattern)) {\n        const packagePathname = getPackagePathname(packageKey)\n        const name = getPackageName(packages[packageKey], packagePathname)\n\n        if (item.negate) {\n          results.delete(packagePathname)\n        } else {\n          results.set(packagePathname, name)\n        }\n      }\n    }\n  }\n\n  // Invert pathname-keyed to a proper name-to-pathnames Map\n  return reverseResultMap(results)\n}\n\nmodule.exports = mapWorkspaces\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}