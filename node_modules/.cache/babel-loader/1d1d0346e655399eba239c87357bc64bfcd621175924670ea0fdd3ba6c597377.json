{"ast":null,"code":"// Do not rely on package._fields, so that we don't throw\n// false failures if a tree is generated by other clients.\n// Only relies on child.resolved, which MAY come from\n// client-specific package.json meta _fields, but most of\n// the time will be pulled out of a lockfile\n\nconst semver = require('semver');\nconst npa = require('npm-package-arg');\nconst {\n  relative\n} = require('path');\nconst fromPath = require('./from-path.js');\nconst depValid = (child, requested, requestor) => {\n  // NB: we don't do much to verify 'tag' type requests.\n  // Just verify that we got a remote resolution.  Presumably, it\n  // came from a registry and was tagged at some point.\n\n  if (typeof requested === 'string') {\n    try {\n      // tarball/dir must have resolved to the same tgz on disk, but for\n      // file: deps that depend on other files/dirs, we must resolve the\n      // location based on the *requestor* file/dir, not where it ends up.\n      // '' is equivalent to '*'\n      requested = npa.resolve(child.name, requested || '*', fromPath(requestor));\n    } catch (er) {\n      // Not invalid because the child doesn't match, but because\n      // the spec itself is not supported.  Nothing would match,\n      // so the edge is definitely not valid and never can be.\n      er.dependency = child.name;\n      er.requested = requested;\n      requestor.errors.push(er);\n      return false;\n    }\n  }\n\n  // if the lockfile is super old, or hand-modified,\n  // then it's possible to hit this state.\n  if (!requested) {\n    const er = new Error('Invalid dependency specifier');\n    er.dependency = child.name;\n    er.requested = requested;\n    requestor.errors.push(er);\n    return false;\n  }\n  switch (requested.type) {\n    case 'range':\n      if (requested.fetchSpec === '*') {\n        return true;\n      }\n    // fallthrough\n    case 'version':\n      // if it's a version or a range other than '*', semver it\n      return semver.satisfies(child.version, requested.fetchSpec, true);\n    case 'directory':\n      // directory must be a link to the specified folder\n      return !!child.isLink && relative(child.realpath, requested.fetchSpec) === '';\n    case 'file':\n      return tarballValid(child, requested, requestor);\n    case 'alias':\n      // check that the alias target is valid\n      return depValid(child, requested.subSpec, requestor);\n    case 'tag':\n      // if it's a tag, we just verify that it has a tarball resolution\n      // presumably, it came from the registry and was tagged at some point\n      return child.resolved && npa(child.resolved).type === 'remote';\n    case 'remote':\n      // verify that we got it from the desired location\n      return child.resolved === requested.fetchSpec;\n    case 'git':\n      {\n        // if it's a git type, verify that they're the same repo\n        //\n        // if it specifies a definite commit, then it must have the\n        // same commit to be considered the same repo\n        //\n        // if it has a #semver:<range> specifier, verify that the\n        // version in the package is in the semver range\n        const resRepo = npa(child.resolved || '');\n        const resHost = resRepo.hosted;\n        const reqHost = requested.hosted;\n        const reqCommit = /^[a-fA-F0-9]{40}$/.test(requested.gitCommittish || '');\n        const nc = {\n          noCommittish: !reqCommit\n        };\n        const sameRepo = resHost ? reqHost && reqHost.ssh(nc) === resHost.ssh(nc) : resRepo.fetchSpec === requested.fetchSpec;\n        return !sameRepo ? false : !requested.gitRange ? true : semver.satisfies(child.package.version, requested.gitRange, {\n          loose: true\n        });\n      }\n    default:\n      // unpossible, just being cautious\n      break;\n  }\n  const er = new Error('Unsupported dependency type');\n  er.dependency = child.name;\n  er.requested = requested;\n  requestor.errors.push(er);\n  return false;\n};\nconst tarballValid = (child, requested, requestor) => {\n  if (child.isLink) {\n    return false;\n  }\n  if (child.resolved) {\n    return child.resolved.replace(/\\\\/g, '/') === `file:${requested.fetchSpec.replace(/\\\\/g, '/')}`;\n  }\n\n  // if we have a legacy mutated package.json file.  we can't be 100%\n  // sure that it resolved to the same file, but if it was the same\n  // request, that's a pretty good indicator of sameness.\n  if (child.package._requested) {\n    return child.package._requested.saveSpec === requested.saveSpec;\n  }\n\n  // ok, we're probably dealing with some legacy cruft here, not much\n  // we can do at this point unfortunately.\n  return false;\n};\nmodule.exports = (child, requested, accept, requestor) => depValid(child, requested, requestor) || (typeof accept === 'string' ? depValid(child, accept, requestor) : false);","map":{"version":3,"names":["semver","require","npa","relative","fromPath","depValid","child","requested","requestor","resolve","name","er","dependency","errors","push","Error","type","fetchSpec","satisfies","version","isLink","realpath","tarballValid","subSpec","resolved","resRepo","resHost","hosted","reqHost","reqCommit","test","gitCommittish","nc","noCommittish","sameRepo","ssh","gitRange","package","loose","replace","_requested","saveSpec","module","exports","accept"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/dep-valid.js"],"sourcesContent":["// Do not rely on package._fields, so that we don't throw\n// false failures if a tree is generated by other clients.\n// Only relies on child.resolved, which MAY come from\n// client-specific package.json meta _fields, but most of\n// the time will be pulled out of a lockfile\n\nconst semver = require('semver')\nconst npa = require('npm-package-arg')\nconst {relative} = require('path')\nconst fromPath = require('./from-path.js')\n\nconst depValid = (child, requested, requestor) => {\n  // NB: we don't do much to verify 'tag' type requests.\n  // Just verify that we got a remote resolution.  Presumably, it\n  // came from a registry and was tagged at some point.\n\n  if (typeof requested === 'string') {\n    try {\n      // tarball/dir must have resolved to the same tgz on disk, but for\n      // file: deps that depend on other files/dirs, we must resolve the\n      // location based on the *requestor* file/dir, not where it ends up.\n      // '' is equivalent to '*'\n      requested = npa.resolve(child.name, requested || '*', fromPath(requestor))\n    } catch (er) {\n      // Not invalid because the child doesn't match, but because\n      // the spec itself is not supported.  Nothing would match,\n      // so the edge is definitely not valid and never can be.\n      er.dependency = child.name\n      er.requested = requested\n      requestor.errors.push(er)\n      return false\n    }\n  }\n\n  // if the lockfile is super old, or hand-modified,\n  // then it's possible to hit this state.\n  if (!requested) {\n    const er = new Error('Invalid dependency specifier')\n    er.dependency = child.name\n    er.requested = requested\n    requestor.errors.push(er)\n    return false\n  }\n\n  switch (requested.type) {\n    case 'range':\n      if (requested.fetchSpec === '*') {\n        return true\n      }\n      // fallthrough\n    case 'version':\n      // if it's a version or a range other than '*', semver it\n      return semver.satisfies(child.version, requested.fetchSpec, true)\n\n    case 'directory':\n      // directory must be a link to the specified folder\n      return !!child.isLink &&\n        relative(child.realpath, requested.fetchSpec) === ''\n\n    case 'file':\n      return tarballValid(child, requested, requestor)\n\n    case 'alias':\n      // check that the alias target is valid\n      return depValid(child, requested.subSpec, requestor)\n\n    case 'tag':\n      // if it's a tag, we just verify that it has a tarball resolution\n      // presumably, it came from the registry and was tagged at some point\n      return child.resolved && npa(child.resolved).type === 'remote'\n\n    case 'remote':\n      // verify that we got it from the desired location\n      return child.resolved === requested.fetchSpec\n\n    case 'git': {\n      // if it's a git type, verify that they're the same repo\n      //\n      // if it specifies a definite commit, then it must have the\n      // same commit to be considered the same repo\n      //\n      // if it has a #semver:<range> specifier, verify that the\n      // version in the package is in the semver range\n      const resRepo = npa(child.resolved || '')\n      const resHost = resRepo.hosted\n      const reqHost = requested.hosted\n      const reqCommit = /^[a-fA-F0-9]{40}$/.test(requested.gitCommittish || '')\n      const nc = { noCommittish: !reqCommit }\n      const sameRepo =\n        resHost ? reqHost && reqHost.ssh(nc) === resHost.ssh(nc)\n        : resRepo.fetchSpec === requested.fetchSpec\n\n      return !sameRepo ? false\n        : !requested.gitRange ? true\n        : semver.satisfies(child.package.version, requested.gitRange, {\n          loose: true,\n        })\n    }\n\n    default: // unpossible, just being cautious\n      break\n  }\n\n  const er = new Error('Unsupported dependency type')\n  er.dependency = child.name\n  er.requested = requested\n  requestor.errors.push(er)\n  return false\n}\n\nconst tarballValid = (child, requested, requestor) => {\n  if (child.isLink) {\n    return false\n  }\n\n  if (child.resolved) {\n    return child.resolved.replace(/\\\\/g, '/') === `file:${requested.fetchSpec.replace(/\\\\/g, '/')}`\n  }\n\n  // if we have a legacy mutated package.json file.  we can't be 100%\n  // sure that it resolved to the same file, but if it was the same\n  // request, that's a pretty good indicator of sameness.\n  if (child.package._requested) {\n    return child.package._requested.saveSpec === requested.saveSpec\n  }\n\n  // ok, we're probably dealing with some legacy cruft here, not much\n  // we can do at this point unfortunately.\n  return false\n}\n\nmodule.exports = (child, requested, accept, requestor) =>\n  depValid(child, requested, requestor) ||\n  (typeof accept === 'string' ? depValid(child, accept, requestor) : false)\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMC,GAAG,GAAGD,OAAO,CAAC,iBAAiB,CAAC;AACtC,MAAM;EAACE;AAAQ,CAAC,GAAGF,OAAO,CAAC,MAAM,CAAC;AAClC,MAAMG,QAAQ,GAAGH,OAAO,CAAC,gBAAgB,CAAC;AAE1C,MAAMI,QAAQ,GAAGA,CAACC,KAAK,EAAEC,SAAS,EAAEC,SAAS,KAAK;EAChD;EACA;EACA;;EAEA,IAAI,OAAOD,SAAS,KAAK,QAAQ,EAAE;IACjC,IAAI;MACF;MACA;MACA;MACA;MACAA,SAAS,GAAGL,GAAG,CAACO,OAAO,CAACH,KAAK,CAACI,IAAI,EAAEH,SAAS,IAAI,GAAG,EAAEH,QAAQ,CAACI,SAAS,CAAC,CAAC;IAC5E,CAAC,CAAC,OAAOG,EAAE,EAAE;MACX;MACA;MACA;MACAA,EAAE,CAACC,UAAU,GAAGN,KAAK,CAACI,IAAI;MAC1BC,EAAE,CAACJ,SAAS,GAAGA,SAAS;MACxBC,SAAS,CAACK,MAAM,CAACC,IAAI,CAACH,EAAE,CAAC;MACzB,OAAO,KAAK;IACd;EACF;;EAEA;EACA;EACA,IAAI,CAACJ,SAAS,EAAE;IACd,MAAMI,EAAE,GAAG,IAAII,KAAK,CAAC,8BAA8B,CAAC;IACpDJ,EAAE,CAACC,UAAU,GAAGN,KAAK,CAACI,IAAI;IAC1BC,EAAE,CAACJ,SAAS,GAAGA,SAAS;IACxBC,SAAS,CAACK,MAAM,CAACC,IAAI,CAACH,EAAE,CAAC;IACzB,OAAO,KAAK;EACd;EAEA,QAAQJ,SAAS,CAACS,IAAI;IACpB,KAAK,OAAO;MACV,IAAIT,SAAS,CAACU,SAAS,KAAK,GAAG,EAAE;QAC/B,OAAO,IAAI;MACb;IACA;IACF,KAAK,SAAS;MACZ;MACA,OAAOjB,MAAM,CAACkB,SAAS,CAACZ,KAAK,CAACa,OAAO,EAAEZ,SAAS,CAACU,SAAS,EAAE,IAAI,CAAC;IAEnE,KAAK,WAAW;MACd;MACA,OAAO,CAAC,CAACX,KAAK,CAACc,MAAM,IACnBjB,QAAQ,CAACG,KAAK,CAACe,QAAQ,EAAEd,SAAS,CAACU,SAAS,CAAC,KAAK,EAAE;IAExD,KAAK,MAAM;MACT,OAAOK,YAAY,CAAChB,KAAK,EAAEC,SAAS,EAAEC,SAAS,CAAC;IAElD,KAAK,OAAO;MACV;MACA,OAAOH,QAAQ,CAACC,KAAK,EAAEC,SAAS,CAACgB,OAAO,EAAEf,SAAS,CAAC;IAEtD,KAAK,KAAK;MACR;MACA;MACA,OAAOF,KAAK,CAACkB,QAAQ,IAAItB,GAAG,CAACI,KAAK,CAACkB,QAAQ,CAAC,CAACR,IAAI,KAAK,QAAQ;IAEhE,KAAK,QAAQ;MACX;MACA,OAAOV,KAAK,CAACkB,QAAQ,KAAKjB,SAAS,CAACU,SAAS;IAE/C,KAAK,KAAK;MAAE;QACV;QACA;QACA;QACA;QACA;QACA;QACA;QACA,MAAMQ,OAAO,GAAGvB,GAAG,CAACI,KAAK,CAACkB,QAAQ,IAAI,EAAE,CAAC;QACzC,MAAME,OAAO,GAAGD,OAAO,CAACE,MAAM;QAC9B,MAAMC,OAAO,GAAGrB,SAAS,CAACoB,MAAM;QAChC,MAAME,SAAS,GAAG,mBAAmB,CAACC,IAAI,CAACvB,SAAS,CAACwB,aAAa,IAAI,EAAE,CAAC;QACzE,MAAMC,EAAE,GAAG;UAAEC,YAAY,EAAE,CAACJ;QAAU,CAAC;QACvC,MAAMK,QAAQ,GACZR,OAAO,GAAGE,OAAO,IAAIA,OAAO,CAACO,GAAG,CAACH,EAAE,CAAC,KAAKN,OAAO,CAACS,GAAG,CAACH,EAAE,CAAC,GACtDP,OAAO,CAACR,SAAS,KAAKV,SAAS,CAACU,SAAS;QAE7C,OAAO,CAACiB,QAAQ,GAAG,KAAK,GACpB,CAAC3B,SAAS,CAAC6B,QAAQ,GAAG,IAAI,GAC1BpC,MAAM,CAACkB,SAAS,CAACZ,KAAK,CAAC+B,OAAO,CAAClB,OAAO,EAAEZ,SAAS,CAAC6B,QAAQ,EAAE;UAC5DE,KAAK,EAAE;QACT,CAAC,CAAC;MACN;IAEA;MAAS;MACP;EACJ;EAEA,MAAM3B,EAAE,GAAG,IAAII,KAAK,CAAC,6BAA6B,CAAC;EACnDJ,EAAE,CAACC,UAAU,GAAGN,KAAK,CAACI,IAAI;EAC1BC,EAAE,CAACJ,SAAS,GAAGA,SAAS;EACxBC,SAAS,CAACK,MAAM,CAACC,IAAI,CAACH,EAAE,CAAC;EACzB,OAAO,KAAK;AACd,CAAC;AAED,MAAMW,YAAY,GAAGA,CAAChB,KAAK,EAAEC,SAAS,EAAEC,SAAS,KAAK;EACpD,IAAIF,KAAK,CAACc,MAAM,EAAE;IAChB,OAAO,KAAK;EACd;EAEA,IAAId,KAAK,CAACkB,QAAQ,EAAE;IAClB,OAAOlB,KAAK,CAACkB,QAAQ,CAACe,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,KAAK,QAAQhC,SAAS,CAACU,SAAS,CAACsB,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE;EACjG;;EAEA;EACA;EACA;EACA,IAAIjC,KAAK,CAAC+B,OAAO,CAACG,UAAU,EAAE;IAC5B,OAAOlC,KAAK,CAAC+B,OAAO,CAACG,UAAU,CAACC,QAAQ,KAAKlC,SAAS,CAACkC,QAAQ;EACjE;;EAEA;EACA;EACA,OAAO,KAAK;AACd,CAAC;AAEDC,MAAM,CAACC,OAAO,GAAG,CAACrC,KAAK,EAAEC,SAAS,EAAEqC,MAAM,EAAEpC,SAAS,KACnDH,QAAQ,CAACC,KAAK,EAAEC,SAAS,EAAEC,SAAS,CAAC,KACpC,OAAOoC,MAAM,KAAK,QAAQ,GAAGvC,QAAQ,CAACC,KAAK,EAAEsC,MAAM,EAAEpC,SAAS,CAAC,GAAG,KAAK,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}