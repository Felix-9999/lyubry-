{"ast":null,"code":"// The arborist manages three trees:\n// - actual\n// - virtual\n// - ideal\n//\n// The actual tree is what's present on disk in the node_modules tree\n// and elsewhere that links may extend.\n//\n// The virtual tree is loaded from metadata (package.json and lock files).\n//\n// The ideal tree is what we WANT that actual tree to become.  This starts\n// with the virtual tree, and then applies the options requesting\n// add/remove/update actions.\n//\n// To reify a tree, we calculate a diff between the ideal and actual trees,\n// and then turn the actual tree into the ideal tree by taking the actions\n// required.  At the end of the reification process, the actualTree is\n// updated to reflect the changes.\n//\n// Each tree has an Inventory at the root.  Shrinkwrap is tracked by Arborist\n// instance.  It always refers to the actual tree, but is updated (and written\n// to disk) on reification.\n\n// Each of the mixin \"classes\" adds functionality, but are not dependent on\n// constructor call order.  So, we just load them in an array, and build up\n// the base class, so that the overall voltron class is easier to test and\n// cover, and separation of concerns can be maintained.\n\nconst {\n  resolve\n} = require('path');\nconst {\n  homedir\n} = require('os');\nconst procLog = require('proc-log');\nconst {\n  saveTypeMap\n} = require('../add-rm-pkg-deps.js');\nconst mixins = [require('../tracker.js'), require('./pruner.js'), require('./deduper.js'), require('./audit.js'), require('./build-ideal-tree.js'), require('./load-workspaces.js'), require('./load-actual.js'), require('./load-virtual.js'), require('./rebuild.js'), require('./reify.js')];\nconst Base = mixins.reduce((a, b) => b(a), require('events'));\nconst getWorkspaceNodes = require('../get-workspace-nodes.js');\nclass Arborist extends Base {\n  constructor(options = {}) {\n    process.emit('time', 'arborist:ctor');\n    super(options);\n    this.options = {\n      nodeVersion: process.version,\n      ...options,\n      path: options.path || '.',\n      cache: options.cache || `${homedir()}/.npm/_cacache`,\n      packumentCache: options.packumentCache || new Map(),\n      log: options.log || procLog\n    };\n    if (options.saveType && !saveTypeMap.get(options.saveType)) {\n      throw new Error(`Invalid saveType ${options.saveType}`);\n    }\n    this.cache = resolve(this.options.cache);\n    this.path = resolve(this.options.path);\n    process.emit('timeEnd', 'arborist:ctor');\n  }\n\n  // returns an array of the actual nodes for all the workspaces\n  workspaceNodes(tree, workspaces) {\n    return getWorkspaceNodes(tree, workspaces, this.log);\n  }\n\n  // returns a set of workspace nodes and all their deps\n  workspaceDependencySet(tree, workspaces) {\n    const wsNodes = this.workspaceNodes(tree, workspaces);\n    const set = new Set(wsNodes);\n    const extraneous = new Set();\n    for (const node of set) {\n      for (const edge of node.edgesOut.values()) {\n        const dep = edge.to;\n        if (dep) {\n          set.add(dep);\n          if (dep.isLink) {\n            set.add(dep.target);\n          }\n        }\n      }\n      for (const child of node.children.values()) {\n        if (child.extraneous) {\n          extraneous.add(child);\n        }\n      }\n    }\n    for (const extra of extraneous) {\n      set.add(extra);\n    }\n    return set;\n  }\n}\nmodule.exports = Arborist;","map":{"version":3,"names":["resolve","require","homedir","procLog","saveTypeMap","mixins","Base","reduce","a","b","getWorkspaceNodes","Arborist","constructor","options","process","emit","nodeVersion","version","path","cache","packumentCache","Map","log","saveType","get","Error","workspaceNodes","tree","workspaces","workspaceDependencySet","wsNodes","set","Set","extraneous","node","edge","edgesOut","values","dep","to","add","isLink","target","child","children","extra","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/index.js"],"sourcesContent":["// The arborist manages three trees:\n// - actual\n// - virtual\n// - ideal\n//\n// The actual tree is what's present on disk in the node_modules tree\n// and elsewhere that links may extend.\n//\n// The virtual tree is loaded from metadata (package.json and lock files).\n//\n// The ideal tree is what we WANT that actual tree to become.  This starts\n// with the virtual tree, and then applies the options requesting\n// add/remove/update actions.\n//\n// To reify a tree, we calculate a diff between the ideal and actual trees,\n// and then turn the actual tree into the ideal tree by taking the actions\n// required.  At the end of the reification process, the actualTree is\n// updated to reflect the changes.\n//\n// Each tree has an Inventory at the root.  Shrinkwrap is tracked by Arborist\n// instance.  It always refers to the actual tree, but is updated (and written\n// to disk) on reification.\n\n// Each of the mixin \"classes\" adds functionality, but are not dependent on\n// constructor call order.  So, we just load them in an array, and build up\n// the base class, so that the overall voltron class is easier to test and\n// cover, and separation of concerns can be maintained.\n\nconst {resolve} = require('path')\nconst {homedir} = require('os')\nconst procLog = require('proc-log')\nconst { saveTypeMap } = require('../add-rm-pkg-deps.js')\n\nconst mixins = [\n  require('../tracker.js'),\n  require('./pruner.js'),\n  require('./deduper.js'),\n  require('./audit.js'),\n  require('./build-ideal-tree.js'),\n  require('./load-workspaces.js'),\n  require('./load-actual.js'),\n  require('./load-virtual.js'),\n  require('./rebuild.js'),\n  require('./reify.js'),\n]\n\nconst Base = mixins.reduce((a, b) => b(a), require('events'))\nconst getWorkspaceNodes = require('../get-workspace-nodes.js')\n\nclass Arborist extends Base {\n  constructor (options = {}) {\n    process.emit('time', 'arborist:ctor')\n    super(options)\n    this.options = {\n      nodeVersion: process.version,\n      ...options,\n      path: options.path || '.',\n      cache: options.cache || `${homedir()}/.npm/_cacache`,\n      packumentCache: options.packumentCache || new Map(),\n      log: options.log || procLog,\n    }\n    if (options.saveType && !saveTypeMap.get(options.saveType)) {\n      throw new Error(`Invalid saveType ${options.saveType}`)\n    }\n    this.cache = resolve(this.options.cache)\n    this.path = resolve(this.options.path)\n    process.emit('timeEnd', 'arborist:ctor')\n  }\n\n  // returns an array of the actual nodes for all the workspaces\n  workspaceNodes (tree, workspaces) {\n    return getWorkspaceNodes(tree, workspaces, this.log)\n  }\n\n  // returns a set of workspace nodes and all their deps\n  workspaceDependencySet (tree, workspaces) {\n    const wsNodes = this.workspaceNodes(tree, workspaces)\n    const set = new Set(wsNodes)\n    const extraneous = new Set()\n    for (const node of set) {\n      for (const edge of node.edgesOut.values()) {\n        const dep = edge.to\n        if (dep) {\n          set.add(dep)\n          if (dep.isLink) {\n            set.add(dep.target)\n          }\n        }\n      }\n      for (const child of node.children.values()) {\n        if (child.extraneous) {\n          extraneous.add(child)\n        }\n      }\n    }\n    for (const extra of extraneous) {\n      set.add(extra)\n    }\n    return set\n  }\n}\n\nmodule.exports = Arborist\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAM;EAACA;AAAO,CAAC,GAAGC,OAAO,CAAC,MAAM,CAAC;AACjC,MAAM;EAACC;AAAO,CAAC,GAAGD,OAAO,CAAC,IAAI,CAAC;AAC/B,MAAME,OAAO,GAAGF,OAAO,CAAC,UAAU,CAAC;AACnC,MAAM;EAAEG;AAAY,CAAC,GAAGH,OAAO,CAAC,uBAAuB,CAAC;AAExD,MAAMI,MAAM,GAAG,CACbJ,OAAO,CAAC,eAAe,CAAC,EACxBA,OAAO,CAAC,aAAa,CAAC,EACtBA,OAAO,CAAC,cAAc,CAAC,EACvBA,OAAO,CAAC,YAAY,CAAC,EACrBA,OAAO,CAAC,uBAAuB,CAAC,EAChCA,OAAO,CAAC,sBAAsB,CAAC,EAC/BA,OAAO,CAAC,kBAAkB,CAAC,EAC3BA,OAAO,CAAC,mBAAmB,CAAC,EAC5BA,OAAO,CAAC,cAAc,CAAC,EACvBA,OAAO,CAAC,YAAY,CAAC,CACtB;AAED,MAAMK,IAAI,GAAGD,MAAM,CAACE,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACD,CAAC,CAAC,EAAEP,OAAO,CAAC,QAAQ,CAAC,CAAC;AAC7D,MAAMS,iBAAiB,GAAGT,OAAO,CAAC,2BAA2B,CAAC;AAE9D,MAAMU,QAAQ,SAASL,IAAI,CAAC;EAC1BM,WAAWA,CAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IACzBC,OAAO,CAACC,IAAI,CAAC,MAAM,EAAE,eAAe,CAAC;IACrC,KAAK,CAACF,OAAO,CAAC;IACd,IAAI,CAACA,OAAO,GAAG;MACbG,WAAW,EAAEF,OAAO,CAACG,OAAO;MAC5B,GAAGJ,OAAO;MACVK,IAAI,EAAEL,OAAO,CAACK,IAAI,IAAI,GAAG;MACzBC,KAAK,EAAEN,OAAO,CAACM,KAAK,IAAI,GAAGjB,OAAO,CAAC,CAAC,gBAAgB;MACpDkB,cAAc,EAAEP,OAAO,CAACO,cAAc,IAAI,IAAIC,GAAG,CAAC,CAAC;MACnDC,GAAG,EAAET,OAAO,CAACS,GAAG,IAAInB;IACtB,CAAC;IACD,IAAIU,OAAO,CAACU,QAAQ,IAAI,CAACnB,WAAW,CAACoB,GAAG,CAACX,OAAO,CAACU,QAAQ,CAAC,EAAE;MAC1D,MAAM,IAAIE,KAAK,CAAC,oBAAoBZ,OAAO,CAACU,QAAQ,EAAE,CAAC;IACzD;IACA,IAAI,CAACJ,KAAK,GAAGnB,OAAO,CAAC,IAAI,CAACa,OAAO,CAACM,KAAK,CAAC;IACxC,IAAI,CAACD,IAAI,GAAGlB,OAAO,CAAC,IAAI,CAACa,OAAO,CAACK,IAAI,CAAC;IACtCJ,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,eAAe,CAAC;EAC1C;;EAEA;EACAW,cAAcA,CAAEC,IAAI,EAAEC,UAAU,EAAE;IAChC,OAAOlB,iBAAiB,CAACiB,IAAI,EAAEC,UAAU,EAAE,IAAI,CAACN,GAAG,CAAC;EACtD;;EAEA;EACAO,sBAAsBA,CAAEF,IAAI,EAAEC,UAAU,EAAE;IACxC,MAAME,OAAO,GAAG,IAAI,CAACJ,cAAc,CAACC,IAAI,EAAEC,UAAU,CAAC;IACrD,MAAMG,GAAG,GAAG,IAAIC,GAAG,CAACF,OAAO,CAAC;IAC5B,MAAMG,UAAU,GAAG,IAAID,GAAG,CAAC,CAAC;IAC5B,KAAK,MAAME,IAAI,IAAIH,GAAG,EAAE;MACtB,KAAK,MAAMI,IAAI,IAAID,IAAI,CAACE,QAAQ,CAACC,MAAM,CAAC,CAAC,EAAE;QACzC,MAAMC,GAAG,GAAGH,IAAI,CAACI,EAAE;QACnB,IAAID,GAAG,EAAE;UACPP,GAAG,CAACS,GAAG,CAACF,GAAG,CAAC;UACZ,IAAIA,GAAG,CAACG,MAAM,EAAE;YACdV,GAAG,CAACS,GAAG,CAACF,GAAG,CAACI,MAAM,CAAC;UACrB;QACF;MACF;MACA,KAAK,MAAMC,KAAK,IAAIT,IAAI,CAACU,QAAQ,CAACP,MAAM,CAAC,CAAC,EAAE;QAC1C,IAAIM,KAAK,CAACV,UAAU,EAAE;UACpBA,UAAU,CAACO,GAAG,CAACG,KAAK,CAAC;QACvB;MACF;IACF;IACA,KAAK,MAAME,KAAK,IAAIZ,UAAU,EAAE;MAC9BF,GAAG,CAACS,GAAG,CAACK,KAAK,CAAC;IAChB;IACA,OAAOd,GAAG;EACZ;AACF;AAEAe,MAAM,CAACC,OAAO,GAAGpC,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}