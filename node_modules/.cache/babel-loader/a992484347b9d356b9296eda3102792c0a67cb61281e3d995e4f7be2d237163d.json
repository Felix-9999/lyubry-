{"ast":null,"code":"const {\n  delimiter,\n  dirname,\n  resolve\n} = require('path');\nconst {\n  promisify\n} = require('util');\nconst read = promisify(require('read'));\nconst Arborist = require('@npmcli/arborist');\nconst ciDetect = require('@npmcli/ci-detect');\nconst logger = require('proc-log');\nconst mkdirp = require('mkdirp-infer-owner');\nconst npa = require('npm-package-arg');\nconst pacote = require('pacote');\nconst readPackageJson = require('read-package-json-fast');\nconst cacheInstallDir = require('./cache-install-dir.js');\nconst {\n  fileExists,\n  localFileExists\n} = require('./file-exists.js');\nconst getBinFromManifest = require('./get-bin-from-manifest.js');\nconst manifestMissing = require('./manifest-missing.js');\nconst noTTY = require('./no-tty.js');\nconst runScript = require('./run-script.js');\nconst isWindows = require('./is-windows.js');\n\n/* istanbul ignore next */\nconst PATH = (process.env.PATH || process.env.Path || process.env.path).split(delimiter);\nconst exec = async opts => {\n  const {\n    args = [],\n    call = '',\n    color = false,\n    localBin = resolve('./node_modules/.bin'),\n    locationMsg = undefined,\n    globalBin = '',\n    output,\n    packages: _packages = [],\n    path = '.',\n    runPath = '.',\n    scriptShell = isWindows ? process.env.ComSpec || 'cmd' : 'sh',\n    yes = undefined,\n    ...flatOptions\n  } = opts;\n  const log = flatOptions.log || logger;\n\n  // dereferences values because we manipulate it later\n  const packages = [..._packages];\n  const pathArr = [...PATH];\n  const _run = () => runScript({\n    args,\n    call,\n    color,\n    flatOptions,\n    locationMsg,\n    log,\n    output,\n    path,\n    pathArr,\n    runPath,\n    scriptShell\n  });\n\n  // nothing to maybe install, skip the arborist dance\n  if (!call && !args.length && !packages.length) return await _run();\n  const needPackageCommandSwap = args.length && !packages.length;\n  // if there's an argument and no package has been explicitly asked for\n  // check the local and global bin paths for a binary named the same as\n  // the argument and run it if it exists, otherwise fall through to\n  // the behavior of treating the single argument as a package name\n  if (needPackageCommandSwap) {\n    let binExists = false;\n    const dir = dirname(dirname(localBin));\n    const localBinPath = await localFileExists(dir, args[0]);\n    if (localBinPath) {\n      pathArr.unshift(localBinPath);\n      binExists = true;\n    } else if (await fileExists(`${globalBin}/${args[0]}`)) {\n      pathArr.unshift(globalBin);\n      binExists = true;\n    }\n    if (binExists) return await _run();\n    packages.push(args[0]);\n  }\n\n  // If we do `npm exec foo`, and have a `foo` locally, then we'll\n  // always use that, so we don't really need to fetch the manifest.\n  // So: run npa on each packages entry, and if it is a name with a\n  // rawSpec==='', then try to readPackageJson at\n  // node_modules/${name}/package.json, and only pacote fetch if\n  // that fails.\n  const manis = await Promise.all(packages.map(async p => {\n    const spec = npa(p, path);\n    if (spec.type === 'tag' && spec.rawSpec === '') {\n      // fall through to the pacote.manifest() approach\n      try {\n        const pj = resolve(path, 'node_modules', spec.name, 'package.json');\n        return await readPackageJson(pj);\n      } catch (er) {}\n    }\n    // Force preferOnline to true so we are making sure to pull in the latest\n    // This is especially useful if the user didn't give us a version, and\n    // they expect to be running @latest\n    return await pacote.manifest(p, {\n      ...flatOptions,\n      preferOnline: true\n    });\n  }));\n  if (needPackageCommandSwap) args[0] = getBinFromManifest(manis[0]);\n\n  // figure out whether we need to install stuff, or if local is fine\n  const localArb = new Arborist({\n    ...flatOptions,\n    path\n  });\n  const tree = await localArb.loadActual();\n\n  // do we have all the packages in manifest list?\n  const needInstall = manis.some(manifest => manifestMissing({\n    tree,\n    manifest\n  }));\n  if (needInstall) {\n    const {\n      npxCache\n    } = flatOptions;\n    const installDir = cacheInstallDir({\n      npxCache,\n      packages\n    });\n    await mkdirp(installDir);\n    const arb = new Arborist({\n      ...flatOptions,\n      path: installDir\n    });\n    const tree = await arb.loadActual();\n\n    // at this point, we have to ensure that we get the exact same\n    // version, because it's something that has only ever been installed\n    // by npm exec in the cache install directory\n    const add = manis.filter(mani => manifestMissing({\n      tree,\n      manifest: {\n        ...mani,\n        _from: `${mani.name}@${mani.version}`\n      }\n    })).map(mani => mani._from).sort((a, b) => a.localeCompare(b, 'en'));\n\n    // no need to install if already present\n    if (add.length) {\n      if (!yes) {\n        // set -n to always say no\n        if (yes === false) throw new Error('canceled');\n        if (noTTY() || ciDetect()) {\n          log.warn('exec', `The following package${add.length === 1 ? ' was' : 's were'} not found and will be installed: ${add.map(pkg => pkg.replace(/@$/, '')).join(', ')}`);\n        } else {\n          const addList = add.map(a => `  ${a.replace(/@$/, '')}`).join('\\n') + '\\n';\n          const prompt = `Need to install the following packages:\\n${addList}Ok to proceed? `;\n          if (typeof log.clearProgress === 'function') log.clearProgress();\n          const confirm = await read({\n            prompt,\n            default: 'y'\n          });\n          if (confirm.trim().toLowerCase().charAt(0) !== 'y') throw new Error('canceled');\n        }\n      }\n      await arb.reify({\n        ...flatOptions,\n        add\n      });\n    }\n    pathArr.unshift(resolve(installDir, 'node_modules/.bin'));\n  }\n  return await _run();\n};\nmodule.exports = exec;","map":{"version":3,"names":["delimiter","dirname","resolve","require","promisify","read","Arborist","ciDetect","logger","mkdirp","npa","pacote","readPackageJson","cacheInstallDir","fileExists","localFileExists","getBinFromManifest","manifestMissing","noTTY","runScript","isWindows","PATH","process","env","Path","path","split","exec","opts","args","call","color","localBin","locationMsg","undefined","globalBin","output","packages","_packages","runPath","scriptShell","ComSpec","yes","flatOptions","log","pathArr","_run","length","needPackageCommandSwap","binExists","dir","localBinPath","unshift","push","manis","Promise","all","map","p","spec","type","rawSpec","pj","name","er","manifest","preferOnline","localArb","tree","loadActual","needInstall","some","npxCache","installDir","arb","add","filter","mani","_from","version","sort","a","b","localeCompare","Error","warn","pkg","replace","join","addList","prompt","clearProgress","confirm","default","trim","toLowerCase","charAt","reify","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/libnpmexec/lib/index.js"],"sourcesContent":["const { delimiter, dirname, resolve } = require('path')\nconst { promisify } = require('util')\nconst read = promisify(require('read'))\n\nconst Arborist = require('@npmcli/arborist')\nconst ciDetect = require('@npmcli/ci-detect')\nconst logger = require('proc-log')\nconst mkdirp = require('mkdirp-infer-owner')\nconst npa = require('npm-package-arg')\nconst pacote = require('pacote')\nconst readPackageJson = require('read-package-json-fast')\n\nconst cacheInstallDir = require('./cache-install-dir.js')\nconst { fileExists, localFileExists } = require('./file-exists.js')\nconst getBinFromManifest = require('./get-bin-from-manifest.js')\nconst manifestMissing = require('./manifest-missing.js')\nconst noTTY = require('./no-tty.js')\nconst runScript = require('./run-script.js')\nconst isWindows = require('./is-windows.js')\n\n/* istanbul ignore next */\nconst PATH = (\n  process.env.PATH || process.env.Path || process.env.path\n).split(delimiter)\n\nconst exec = async (opts) => {\n  const {\n    args = [],\n    call = '',\n    color = false,\n    localBin = resolve('./node_modules/.bin'),\n    locationMsg = undefined,\n    globalBin = '',\n    output,\n    packages: _packages = [],\n    path = '.',\n    runPath = '.',\n    scriptShell = isWindows ? process.env.ComSpec || 'cmd' : 'sh',\n    yes = undefined,\n    ...flatOptions\n  } = opts\n  const log = flatOptions.log || logger\n\n  // dereferences values because we manipulate it later\n  const packages = [..._packages]\n  const pathArr = [...PATH]\n  const _run = () => runScript({\n    args,\n    call,\n    color,\n    flatOptions,\n    locationMsg,\n    log,\n    output,\n    path,\n    pathArr,\n    runPath,\n    scriptShell,\n  })\n\n  // nothing to maybe install, skip the arborist dance\n  if (!call && !args.length && !packages.length)\n    return await _run()\n\n  const needPackageCommandSwap = args.length && !packages.length\n  // if there's an argument and no package has been explicitly asked for\n  // check the local and global bin paths for a binary named the same as\n  // the argument and run it if it exists, otherwise fall through to\n  // the behavior of treating the single argument as a package name\n  if (needPackageCommandSwap) {\n    let binExists = false\n    const dir = dirname(dirname(localBin))\n    const localBinPath = await localFileExists(dir, args[0])\n    if (localBinPath) {\n      pathArr.unshift(localBinPath)\n      binExists = true\n    } else if (await fileExists(`${globalBin}/${args[0]}`)) {\n      pathArr.unshift(globalBin)\n      binExists = true\n    }\n\n    if (binExists)\n      return await _run()\n\n    packages.push(args[0])\n  }\n\n  // If we do `npm exec foo`, and have a `foo` locally, then we'll\n  // always use that, so we don't really need to fetch the manifest.\n  // So: run npa on each packages entry, and if it is a name with a\n  // rawSpec==='', then try to readPackageJson at\n  // node_modules/${name}/package.json, and only pacote fetch if\n  // that fails.\n  const manis = await Promise.all(packages.map(async p => {\n    const spec = npa(p, path)\n    if (spec.type === 'tag' && spec.rawSpec === '') {\n      // fall through to the pacote.manifest() approach\n      try {\n        const pj = resolve(path, 'node_modules', spec.name, 'package.json')\n        return await readPackageJson(pj)\n      } catch (er) {}\n    }\n    // Force preferOnline to true so we are making sure to pull in the latest\n    // This is especially useful if the user didn't give us a version, and\n    // they expect to be running @latest\n    return await pacote.manifest(p, {\n      ...flatOptions,\n      preferOnline: true,\n    })\n  }))\n\n  if (needPackageCommandSwap)\n    args[0] = getBinFromManifest(manis[0])\n\n  // figure out whether we need to install stuff, or if local is fine\n  const localArb = new Arborist({\n    ...flatOptions,\n    path,\n  })\n  const tree = await localArb.loadActual()\n\n  // do we have all the packages in manifest list?\n  const needInstall =\n    manis.some(manifest => manifestMissing({ tree, manifest }))\n\n  if (needInstall) {\n    const { npxCache } = flatOptions\n    const installDir = cacheInstallDir({ npxCache, packages })\n    await mkdirp(installDir)\n    const arb = new Arborist({\n      ...flatOptions,\n      path: installDir,\n    })\n    const tree = await arb.loadActual()\n\n    // at this point, we have to ensure that we get the exact same\n    // version, because it's something that has only ever been installed\n    // by npm exec in the cache install directory\n    const add = manis.filter(mani => manifestMissing({\n      tree,\n      manifest: {\n        ...mani,\n        _from: `${mani.name}@${mani.version}`,\n      },\n    }))\n      .map(mani => mani._from)\n      .sort((a, b) => a.localeCompare(b, 'en'))\n\n    // no need to install if already present\n    if (add.length) {\n      if (!yes) {\n        // set -n to always say no\n        if (yes === false)\n          throw new Error('canceled')\n\n        if (noTTY() || ciDetect()) {\n          log.warn('exec', `The following package${\n            add.length === 1 ? ' was' : 's were'\n          } not found and will be installed: ${\n            add.map((pkg) => pkg.replace(/@$/, '')).join(', ')\n          }`)\n        } else {\n          const addList = add.map(a => `  ${a.replace(/@$/, '')}`)\n            .join('\\n') + '\\n'\n          const prompt = `Need to install the following packages:\\n${\n          addList\n        }Ok to proceed? `\n          if (typeof log.clearProgress === 'function')\n            log.clearProgress()\n          const confirm = await read({ prompt, default: 'y' })\n          if (confirm.trim().toLowerCase().charAt(0) !== 'y')\n            throw new Error('canceled')\n        }\n      }\n      await arb.reify({\n        ...flatOptions,\n        add,\n      })\n    }\n    pathArr.unshift(resolve(installDir, 'node_modules/.bin'))\n  }\n\n  return await _run()\n}\n\nmodule.exports = exec\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}