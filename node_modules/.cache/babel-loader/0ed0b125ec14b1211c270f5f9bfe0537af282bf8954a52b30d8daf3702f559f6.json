{"ast":null,"code":"// Perform a depth-first walk of a tree, ONLY doing the descent (visit)\n//\n// This uses a stack rather than recursion, so that it can handle deeply\n// nested trees without call stack overflows.  (My kingdom for proper TCO!)\n//\n// This is only used for cases where leave() is not specified.\n//\n// a\n// +-- b\n// |   +-- 1\n// |   +-- 2\n// +-- c\n//     +-- 3\n//     +-- 4\n//\n// Expect:\n// visit a\n// visit b\n// visit 1\n// visit 2\n// visit c\n// visit 3\n// visit 4\n//\n// stack.push(tree)\n// while stack not empty\n//   pop T from stack\n//   VISIT(T)\n//   get children C of T\n//   push each C onto stack\n\nconst depth = ({\n  visit,\n  filter,\n  getChildren,\n  tree\n}) => {\n  const stack = [];\n  const seen = new Map();\n  const next = () => {\n    while (stack.length) {\n      const node = stack.pop();\n      const res = visitNode(node);\n      if (isPromise(res)) {\n        return res.then(() => next());\n      }\n    }\n    return seen.get(tree);\n  };\n  const visitNode = tree => {\n    if (seen.has(tree)) return seen.get(tree);\n    seen.set(tree, null);\n    const res = visit ? visit(tree) : tree;\n    if (isPromise(res)) {\n      const fullResult = res.then(res => {\n        seen.set(tree, res);\n        return kidNodes(tree);\n      });\n      seen.set(tree, fullResult);\n      return fullResult;\n    } else {\n      seen.set(tree, res);\n      return kidNodes(tree);\n    }\n  };\n  const kidNodes = tree => {\n    const kids = getChildren(tree, seen.get(tree));\n    return isPromise(kids) ? kids.then(processKids) : processKids(kids);\n  };\n  const processKids = kids => {\n    kids = (kids || []).filter(filter);\n    stack.push(...kids);\n  };\n  stack.push(tree);\n  return next();\n};\nconst isPromise = p => p && typeof p.then === 'function';\nmodule.exports = depth;","map":{"version":3,"names":["depth","visit","filter","getChildren","tree","stack","seen","Map","next","length","node","pop","res","visitNode","isPromise","then","get","has","set","fullResult","kidNodes","kids","processKids","push","p","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/treeverse/lib/depth-descent.js"],"sourcesContent":["// Perform a depth-first walk of a tree, ONLY doing the descent (visit)\n//\n// This uses a stack rather than recursion, so that it can handle deeply\n// nested trees without call stack overflows.  (My kingdom for proper TCO!)\n//\n// This is only used for cases where leave() is not specified.\n//\n// a\n// +-- b\n// |   +-- 1\n// |   +-- 2\n// +-- c\n//     +-- 3\n//     +-- 4\n//\n// Expect:\n// visit a\n// visit b\n// visit 1\n// visit 2\n// visit c\n// visit 3\n// visit 4\n//\n// stack.push(tree)\n// while stack not empty\n//   pop T from stack\n//   VISIT(T)\n//   get children C of T\n//   push each C onto stack\n\nconst depth = ({\n  visit,\n  filter,\n  getChildren,\n  tree,\n}) => {\n  const stack = []\n  const seen = new Map()\n\n  const next = () => {\n    while (stack.length) {\n      const node = stack.pop()\n      const res = visitNode(node)\n      if (isPromise(res)) {\n        return res.then(() => next())\n      }\n    }\n    return seen.get(tree)\n  }\n\n  const visitNode = (tree) => {\n    if (seen.has(tree))\n      return seen.get(tree)\n\n    seen.set(tree, null)\n    const res = visit ? visit(tree) : tree\n    if (isPromise(res)) {\n      const fullResult = res.then(res => {\n        seen.set(tree, res)\n        return kidNodes(tree)\n      })\n      seen.set(tree, fullResult)\n      return fullResult\n    } else {\n      seen.set(tree, res)\n      return kidNodes(tree)\n    }\n  }\n\n  const kidNodes = (tree) => {\n    const kids = getChildren(tree, seen.get(tree))\n    return isPromise(kids) ? kids.then(processKids) : processKids(kids)\n  }\n\n  const processKids = (kids) => {\n    kids = (kids || []).filter(filter)\n    stack.push(...kids)\n  }\n\n  stack.push(tree)\n  return next()\n}\n\nconst isPromise = p => p && typeof p.then === 'function'\n\nmodule.exports = depth\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,KAAK,GAAGA,CAAC;EACbC,KAAK;EACLC,MAAM;EACNC,WAAW;EACXC;AACF,CAAC,KAAK;EACJ,MAAMC,KAAK,GAAG,EAAE;EAChB,MAAMC,IAAI,GAAG,IAAIC,GAAG,CAAC,CAAC;EAEtB,MAAMC,IAAI,GAAGA,CAAA,KAAM;IACjB,OAAOH,KAAK,CAACI,MAAM,EAAE;MACnB,MAAMC,IAAI,GAAGL,KAAK,CAACM,GAAG,CAAC,CAAC;MACxB,MAAMC,GAAG,GAAGC,SAAS,CAACH,IAAI,CAAC;MAC3B,IAAII,SAAS,CAACF,GAAG,CAAC,EAAE;QAClB,OAAOA,GAAG,CAACG,IAAI,CAAC,MAAMP,IAAI,CAAC,CAAC,CAAC;MAC/B;IACF;IACA,OAAOF,IAAI,CAACU,GAAG,CAACZ,IAAI,CAAC;EACvB,CAAC;EAED,MAAMS,SAAS,GAAIT,IAAI,IAAK;IAC1B,IAAIE,IAAI,CAACW,GAAG,CAACb,IAAI,CAAC,EAChB,OAAOE,IAAI,CAACU,GAAG,CAACZ,IAAI,CAAC;IAEvBE,IAAI,CAACY,GAAG,CAACd,IAAI,EAAE,IAAI,CAAC;IACpB,MAAMQ,GAAG,GAAGX,KAAK,GAAGA,KAAK,CAACG,IAAI,CAAC,GAAGA,IAAI;IACtC,IAAIU,SAAS,CAACF,GAAG,CAAC,EAAE;MAClB,MAAMO,UAAU,GAAGP,GAAG,CAACG,IAAI,CAACH,GAAG,IAAI;QACjCN,IAAI,CAACY,GAAG,CAACd,IAAI,EAAEQ,GAAG,CAAC;QACnB,OAAOQ,QAAQ,CAAChB,IAAI,CAAC;MACvB,CAAC,CAAC;MACFE,IAAI,CAACY,GAAG,CAACd,IAAI,EAAEe,UAAU,CAAC;MAC1B,OAAOA,UAAU;IACnB,CAAC,MAAM;MACLb,IAAI,CAACY,GAAG,CAACd,IAAI,EAAEQ,GAAG,CAAC;MACnB,OAAOQ,QAAQ,CAAChB,IAAI,CAAC;IACvB;EACF,CAAC;EAED,MAAMgB,QAAQ,GAAIhB,IAAI,IAAK;IACzB,MAAMiB,IAAI,GAAGlB,WAAW,CAACC,IAAI,EAAEE,IAAI,CAACU,GAAG,CAACZ,IAAI,CAAC,CAAC;IAC9C,OAAOU,SAAS,CAACO,IAAI,CAAC,GAAGA,IAAI,CAACN,IAAI,CAACO,WAAW,CAAC,GAAGA,WAAW,CAACD,IAAI,CAAC;EACrE,CAAC;EAED,MAAMC,WAAW,GAAID,IAAI,IAAK;IAC5BA,IAAI,GAAG,CAACA,IAAI,IAAI,EAAE,EAAEnB,MAAM,CAACA,MAAM,CAAC;IAClCG,KAAK,CAACkB,IAAI,CAAC,GAAGF,IAAI,CAAC;EACrB,CAAC;EAEDhB,KAAK,CAACkB,IAAI,CAACnB,IAAI,CAAC;EAChB,OAAOI,IAAI,CAAC,CAAC;AACf,CAAC;AAED,MAAMM,SAAS,GAAGU,CAAC,IAAIA,CAAC,IAAI,OAAOA,CAAC,CAACT,IAAI,KAAK,UAAU;AAExDU,MAAM,CAACC,OAAO,GAAG1B,KAAK","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}