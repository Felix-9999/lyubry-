{"ast":null,"code":"const {\n  promisify\n} = require('util');\nconst {\n  resolve,\n  dirname\n} = require('path');\nconst fs = require('fs');\nconst lstat = promisify(fs.lstat);\nconst throwNonEnoent = er => {\n  if (er.code !== 'ENOENT') throw er;\n};\nconst cmdShim = require('cmd-shim');\nconst readCmdShim = require('read-cmd-shim');\nconst fixBin = require('./fix-bin.js');\n\n// even in --force mode, we never create a shim over a shim we've\n// already created.  you can have multiple packages in a tree trying\n// to contend for the same bin, which creates a race condition and\n// nondeterminism.\nconst seen = new Set();\nconst failEEXIST = ({\n  path,\n  to,\n  from\n}) => Promise.reject(Object.assign(new Error('EEXIST: file already exists'), {\n  path: to,\n  dest: from,\n  code: 'EEXIST'\n}));\nconst handleReadCmdShimError = ({\n  er,\n  from,\n  to\n}) => er.code === 'ENOENT' ? null : er.code === 'ENOTASHIM' ? failEEXIST({\n  from,\n  to\n}) : Promise.reject(er);\nconst SKIP = Symbol('skip - missing or already installed');\nconst shimBin = ({\n  path,\n  to,\n  from,\n  absFrom,\n  force\n}) => {\n  const shims = [to, to + '.cmd', to + '.ps1'];\n  for (const shim of shims) {\n    if (seen.has(shim)) return true;\n    seen.add(shim);\n  }\n  return Promise.all([...shims, absFrom].map(f => lstat(f).catch(throwNonEnoent))).then(stats => {\n    const [stToBase, stToCmd, stToPs1, stFrom] = stats;\n    if (!stFrom) return SKIP;\n    if (force) return;\n    return Promise.all(shims.map((s, i) => [s, stats[i]]).map(([s, st]) => {\n      if (!st) return;\n      return readCmdShim(s).then(target => {\n        target = resolve(dirname(to), target);\n        if (target.indexOf(resolve(path)) !== 0) return failEEXIST({\n          from,\n          to,\n          path\n        });\n      }, er => handleReadCmdShimError({\n        er,\n        from,\n        to\n      }));\n    }));\n  }).then(skip => skip !== SKIP && doShim(absFrom, to));\n};\nconst doShim = (absFrom, to) => cmdShim(absFrom, to).then(() => fixBin(absFrom));\nconst resetSeen = () => {\n  for (const p of seen) {\n    seen.delete(p);\n  }\n};\nmodule.exports = Object.assign(shimBin, {\n  resetSeen\n});","map":{"version":3,"names":["promisify","require","resolve","dirname","fs","lstat","throwNonEnoent","er","code","cmdShim","readCmdShim","fixBin","seen","Set","failEEXIST","path","to","from","Promise","reject","Object","assign","Error","dest","handleReadCmdShimError","SKIP","Symbol","shimBin","absFrom","force","shims","shim","has","add","all","map","f","catch","then","stats","stToBase","stToCmd","stToPs1","stFrom","s","i","st","target","indexOf","skip","doShim","resetSeen","p","delete","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/bin-links/lib/shim-bin.js"],"sourcesContent":["const { promisify } = require('util')\nconst { resolve, dirname } = require('path')\nconst fs = require('fs')\nconst lstat = promisify(fs.lstat)\nconst throwNonEnoent = er => { if (er.code !== 'ENOENT') throw er }\n\nconst cmdShim = require('cmd-shim')\nconst readCmdShim = require('read-cmd-shim')\n\nconst fixBin = require('./fix-bin.js')\n\n// even in --force mode, we never create a shim over a shim we've\n// already created.  you can have multiple packages in a tree trying\n// to contend for the same bin, which creates a race condition and\n// nondeterminism.\nconst seen = new Set()\n\nconst failEEXIST = ({path, to, from}) =>\n  Promise.reject(Object.assign(new Error('EEXIST: file already exists'), {\n    path: to,\n    dest: from,\n    code: 'EEXIST',\n  }))\n\nconst handleReadCmdShimError = ({er, from, to}) =>\n  er.code === 'ENOENT' ? null\n  : er.code === 'ENOTASHIM' ? failEEXIST({from, to})\n  : Promise.reject(er)\n\nconst SKIP = Symbol('skip - missing or already installed')\nconst shimBin = ({path, to, from, absFrom, force}) => {\n  const shims = [\n    to,\n    to + '.cmd',\n    to + '.ps1',\n  ]\n\n  for (const shim of shims) {\n    if (seen.has(shim))\n      return true\n    seen.add(shim)\n  }\n\n  return Promise.all([\n    ...shims,\n    absFrom,\n  ].map(f => lstat(f).catch(throwNonEnoent))).then((stats) => {\n    const [\n      stToBase,\n      stToCmd,\n      stToPs1,\n      stFrom,\n    ] = stats\n    if (!stFrom)\n      return SKIP\n\n    if (force)\n      return\n\n    return Promise.all(shims.map((s, i) => [s, stats[i]]).map(([s, st]) => {\n      if (!st)\n        return\n      return readCmdShim(s)\n        .then(target => {\n          target = resolve(dirname(to), target)\n          if (target.indexOf(resolve(path)) !== 0)\n            return failEEXIST({from, to, path})\n        }, er => handleReadCmdShimError({er, from, to}))\n    }))\n  })\n  .then(skip => skip !== SKIP && doShim(absFrom, to))\n}\n\nconst doShim = (absFrom, to) =>\n  cmdShim(absFrom, to).then(() => fixBin(absFrom))\n\nconst resetSeen = () => {\n  for (const p of seen) {\n    seen.delete(p)\n  }\n}\n\nmodule.exports = Object.assign(shimBin, { resetSeen })\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}