{"ast":null,"code":"// a tree representing the difference between two trees\n// A Diff node's parent is not necessarily the parent of\n// the node location it refers to, but rather the highest level\n// node that needs to be either changed or removed.\n// Thus, the root Diff node is the shallowest change required\n// for a given branch of the tree being mutated.\n\nconst {\n  depth\n} = require('treeverse');\nconst {\n  existsSync\n} = require('fs');\nconst ssri = require('ssri');\nclass Diff {\n  constructor({\n    actual,\n    ideal,\n    filterSet,\n    shrinkwrapInflated\n  }) {\n    this.filterSet = filterSet;\n    this.shrinkwrapInflated = shrinkwrapInflated;\n    this.children = [];\n    this.actual = actual;\n    this.ideal = ideal;\n    if (this.ideal) {\n      this.resolved = this.ideal.resolved;\n      this.integrity = this.ideal.integrity;\n    }\n    this.action = getAction(this);\n    this.parent = null;\n    // the set of leaf nodes that we rake up to the top level\n    this.leaves = [];\n    // the set of nodes that don't change in this branch of the tree\n    this.unchanged = [];\n    // the set of nodes that will be removed in this branch of the tree\n    this.removed = [];\n  }\n  static calculate({\n    actual,\n    ideal,\n    filterNodes = [],\n    shrinkwrapInflated = new Set()\n  }) {\n    // if there's a filterNode, then:\n    // - get the path from the root to the filterNode.  The root or\n    //   root.target should have an edge either to the filterNode or\n    //   a link to the filterNode.  If not, abort.  Add the path to the\n    //   filterSet.\n    // - Add set of Nodes depended on by the filterNode to filterSet.\n    // - Anything outside of that set should be ignored by getChildren\n    const filterSet = new Set();\n    const extraneous = new Set();\n    for (const filterNode of filterNodes) {\n      const {\n        root\n      } = filterNode;\n      if (root !== ideal && root !== actual) {\n        throw new Error('invalid filterNode: outside idealTree/actualTree');\n      }\n      const rootTarget = root.target;\n      const edge = [...rootTarget.edgesOut.values()].filter(e => {\n        return e.to && (e.to === filterNode || e.to.target === filterNode);\n      })[0];\n      filterSet.add(root);\n      filterSet.add(rootTarget);\n      filterSet.add(ideal);\n      filterSet.add(actual);\n      if (edge && edge.to) {\n        filterSet.add(edge.to);\n        filterSet.add(edge.to.target);\n      }\n      filterSet.add(filterNode);\n      depth({\n        tree: filterNode,\n        visit: node => filterSet.add(node),\n        getChildren: node => {\n          node = node.target;\n          const loc = node.location;\n          const idealNode = ideal.inventory.get(loc);\n          const ideals = !idealNode ? [] : [...idealNode.edgesOut.values()].filter(e => e.to).map(e => e.to);\n          const actualNode = actual.inventory.get(loc);\n          const actuals = !actualNode ? [] : [...actualNode.edgesOut.values()].filter(e => e.to).map(e => e.to);\n          if (actualNode) {\n            for (const child of actualNode.children.values()) {\n              if (child.extraneous) {\n                extraneous.add(child);\n              }\n            }\n          }\n          return ideals.concat(actuals);\n        }\n      });\n    }\n    for (const extra of extraneous) {\n      filterSet.add(extra);\n    }\n    return depth({\n      tree: new Diff({\n        actual,\n        ideal,\n        filterSet,\n        shrinkwrapInflated\n      }),\n      getChildren,\n      leave\n    });\n  }\n}\nconst getAction = ({\n  actual,\n  ideal\n}) => {\n  if (!ideal) {\n    return 'REMOVE';\n  }\n\n  // bundled meta-deps are copied over to the ideal tree when we visit it,\n  // so they'll appear to be missing here.  There's no need to handle them\n  // in the diff, though, because they'll be replaced at reify time anyway\n  // Otherwise, add the missing node.\n  if (!actual) {\n    return ideal.inDepBundle ? null : 'ADD';\n  }\n\n  // always ignore the root node\n  if (ideal.isRoot && actual.isRoot) {\n    return null;\n  }\n\n  // if the versions don't match, it's a change no matter what\n  if (ideal.version !== actual.version) {\n    return 'CHANGE';\n  }\n  const binsExist = ideal.binPaths.every(path => existsSync(path));\n\n  // top nodes, links, and git deps won't have integrity, but do have resolved\n  // if neither node has integrity, the bins exist, and either (a) neither\n  // node has a resolved value or (b) they both do and match, then we can\n  // leave this one alone since we already know the versions match due to\n  // the condition above.  The \"neither has resolved\" case (a) cannot be\n  // treated as a 'mark CHANGE and refetch', because shrinkwraps, bundles,\n  // and link deps may lack this information, and we don't want to try to\n  // go to the registry for something that isn't there.\n  const noIntegrity = !ideal.integrity && !actual.integrity;\n  const noResolved = !ideal.resolved && !actual.resolved;\n  const resolvedMatch = ideal.resolved && ideal.resolved === actual.resolved;\n  if (noIntegrity && binsExist && (resolvedMatch || noResolved)) {\n    return null;\n  }\n\n  // otherwise, verify that it's the same bits\n  // note that if ideal has integrity, and resolved doesn't, we treat\n  // that as a 'change', so that it gets re-fetched and locked down.\n  const integrityMismatch = !ideal.integrity || !actual.integrity || !ssri.parse(ideal.integrity).match(actual.integrity);\n  if (integrityMismatch || !binsExist) {\n    return 'CHANGE';\n  }\n  return null;\n};\nconst allChildren = node => {\n  if (!node) {\n    return new Map();\n  }\n\n  // if the node is root, and also a link, then what we really\n  // want is to traverse the target's children\n  if (node.isRoot && node.isLink) {\n    return allChildren(node.target);\n  }\n  const kids = new Map();\n  for (const n of [node, ...node.fsChildren]) {\n    for (const kid of n.children.values()) {\n      kids.set(kid.path, kid);\n    }\n  }\n  return kids;\n};\n\n// functions for the walk options when we traverse the trees\n// to create the diff tree\nconst getChildren = diff => {\n  const children = [];\n  const {\n    actual,\n    ideal,\n    unchanged,\n    removed,\n    filterSet,\n    shrinkwrapInflated\n  } = diff;\n\n  // Note: we DON'T diff fsChildren themselves, because they are either\n  // included in the package contents, or part of some other project, and\n  // will never appear in legacy shrinkwraps anyway.  but we _do_ include the\n  // child nodes of fsChildren, because those are nodes that we are typically\n  // responsible for installing.\n  const actualKids = allChildren(actual);\n  const idealKids = allChildren(ideal);\n  if (ideal && ideal.hasShrinkwrap && !shrinkwrapInflated.has(ideal)) {\n    // Guaranteed to get a diff.leaves here, because we always\n    // be called with a proper Diff object when ideal has a shrinkwrap\n    // that has not been inflated.\n    diff.leaves.push(diff);\n    return children;\n  }\n  const paths = new Set([...actualKids.keys(), ...idealKids.keys()]);\n  for (const path of paths) {\n    const actual = actualKids.get(path);\n    const ideal = idealKids.get(path);\n    diffNode({\n      actual,\n      ideal,\n      children,\n      unchanged,\n      removed,\n      filterSet,\n      shrinkwrapInflated\n    });\n  }\n  if (diff.leaves && !children.length) {\n    diff.leaves.push(diff);\n  }\n  return children;\n};\nconst diffNode = ({\n  actual,\n  ideal,\n  children,\n  unchanged,\n  removed,\n  filterSet,\n  shrinkwrapInflated\n}) => {\n  if (filterSet.size && !(filterSet.has(ideal) || filterSet.has(actual))) {\n    return;\n  }\n  const action = getAction({\n    actual,\n    ideal\n  });\n\n  // if it's a match, then get its children\n  // otherwise, this is the child diff node\n  if (action || !shrinkwrapInflated.has(ideal) && ideal.hasShrinkwrap) {\n    if (action === 'REMOVE') {\n      removed.push(actual);\n    }\n    children.push(new Diff({\n      actual,\n      ideal,\n      filterSet,\n      shrinkwrapInflated\n    }));\n  } else {\n    unchanged.push(ideal);\n    // !*! Weird dirty hack warning !*!\n    //\n    // Bundled deps aren't loaded in the ideal tree, because we don't know\n    // what they are going to be without unpacking.  Swap them over now if\n    // the bundling node isn't changing, so we don't prune them later.\n    //\n    // It's a little bit dirty to be doing this here, since it means that\n    // diffing trees can mutate them, but otherwise we have to walk over\n    // all unchanging bundlers and correct the diff later, so it's more\n    // efficient to just fix it while we're passing through already.\n    //\n    // Note that moving over a bundled dep will break the links to other\n    // deps under this parent, which may have been transitively bundled.\n    // Breaking those links means that we'll no longer see the transitive\n    // dependency, meaning that it won't appear as bundled any longer!\n    // In order to not end up dropping transitively bundled deps, we have\n    // to get the list of nodes to move, then move them all at once, rather\n    // than moving them one at a time in the first loop.\n    const bd = ideal.package.bundleDependencies;\n    if (actual && bd && bd.length) {\n      const bundledChildren = [];\n      for (const node of actual.children.values()) {\n        if (node.inBundle) {\n          bundledChildren.push(node);\n        }\n      }\n      for (const node of bundledChildren) {\n        node.parent = ideal;\n      }\n    }\n    children.push(...getChildren({\n      actual,\n      ideal,\n      unchanged,\n      removed,\n      filterSet,\n      shrinkwrapInflated\n    }));\n  }\n};\n\n// set the parentage in the leave step so that we aren't attaching\n// child nodes only to remove them later.  also bubble up the unchanged\n// nodes so that we can move them out of staging in the reification step.\nconst leave = (diff, children) => {\n  children.forEach(kid => {\n    kid.parent = diff;\n    diff.leaves.push(...kid.leaves);\n    diff.unchanged.push(...kid.unchanged);\n    diff.removed.push(...kid.removed);\n  });\n  diff.children = children;\n  return diff;\n};\nmodule.exports = Diff;","map":{"version":3,"names":["depth","require","existsSync","ssri","Diff","constructor","actual","ideal","filterSet","shrinkwrapInflated","children","resolved","integrity","action","getAction","parent","leaves","unchanged","removed","calculate","filterNodes","Set","extraneous","filterNode","root","Error","rootTarget","target","edge","edgesOut","values","filter","e","to","add","tree","visit","node","getChildren","loc","location","idealNode","inventory","get","ideals","map","actualNode","actuals","child","concat","extra","leave","inDepBundle","isRoot","version","binsExist","binPaths","every","path","noIntegrity","noResolved","resolvedMatch","integrityMismatch","parse","match","allChildren","Map","isLink","kids","n","fsChildren","kid","set","diff","actualKids","idealKids","hasShrinkwrap","has","push","paths","keys","diffNode","length","size","bd","package","bundleDependencies","bundledChildren","inBundle","forEach","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/diff.js"],"sourcesContent":["// a tree representing the difference between two trees\n// A Diff node's parent is not necessarily the parent of\n// the node location it refers to, but rather the highest level\n// node that needs to be either changed or removed.\n// Thus, the root Diff node is the shallowest change required\n// for a given branch of the tree being mutated.\n\nconst {depth} = require('treeverse')\nconst {existsSync} = require('fs')\n\nconst ssri = require('ssri')\n\nclass Diff {\n  constructor ({actual, ideal, filterSet, shrinkwrapInflated}) {\n    this.filterSet = filterSet\n    this.shrinkwrapInflated = shrinkwrapInflated\n    this.children = []\n    this.actual = actual\n    this.ideal = ideal\n    if (this.ideal) {\n      this.resolved = this.ideal.resolved\n      this.integrity = this.ideal.integrity\n    }\n    this.action = getAction(this)\n    this.parent = null\n    // the set of leaf nodes that we rake up to the top level\n    this.leaves = []\n    // the set of nodes that don't change in this branch of the tree\n    this.unchanged = []\n    // the set of nodes that will be removed in this branch of the tree\n    this.removed = []\n  }\n\n  static calculate ({\n    actual,\n    ideal,\n    filterNodes = [],\n    shrinkwrapInflated = new Set(),\n  }) {\n    // if there's a filterNode, then:\n    // - get the path from the root to the filterNode.  The root or\n    //   root.target should have an edge either to the filterNode or\n    //   a link to the filterNode.  If not, abort.  Add the path to the\n    //   filterSet.\n    // - Add set of Nodes depended on by the filterNode to filterSet.\n    // - Anything outside of that set should be ignored by getChildren\n    const filterSet = new Set()\n    const extraneous = new Set()\n    for (const filterNode of filterNodes) {\n      const { root } = filterNode\n      if (root !== ideal && root !== actual) {\n        throw new Error('invalid filterNode: outside idealTree/actualTree')\n      }\n      const rootTarget = root.target\n      const edge = [...rootTarget.edgesOut.values()].filter(e => {\n        return e.to && (e.to === filterNode || e.to.target === filterNode)\n      })[0]\n      filterSet.add(root)\n      filterSet.add(rootTarget)\n      filterSet.add(ideal)\n      filterSet.add(actual)\n      if (edge && edge.to) {\n        filterSet.add(edge.to)\n        filterSet.add(edge.to.target)\n      }\n      filterSet.add(filterNode)\n\n      depth({\n        tree: filterNode,\n        visit: node => filterSet.add(node),\n        getChildren: node => {\n          node = node.target\n          const loc = node.location\n          const idealNode = ideal.inventory.get(loc)\n          const ideals = !idealNode ? []\n            : [...idealNode.edgesOut.values()].filter(e => e.to).map(e => e.to)\n          const actualNode = actual.inventory.get(loc)\n          const actuals = !actualNode ? []\n            : [...actualNode.edgesOut.values()].filter(e => e.to).map(e => e.to)\n          if (actualNode) {\n            for (const child of actualNode.children.values()) {\n              if (child.extraneous) {\n                extraneous.add(child)\n              }\n            }\n          }\n\n          return ideals.concat(actuals)\n        },\n      })\n    }\n    for (const extra of extraneous) {\n      filterSet.add(extra)\n    }\n\n    return depth({\n      tree: new Diff({actual, ideal, filterSet, shrinkwrapInflated}),\n      getChildren,\n      leave,\n    })\n  }\n}\n\nconst getAction = ({actual, ideal}) => {\n  if (!ideal) {\n    return 'REMOVE'\n  }\n\n  // bundled meta-deps are copied over to the ideal tree when we visit it,\n  // so they'll appear to be missing here.  There's no need to handle them\n  // in the diff, though, because they'll be replaced at reify time anyway\n  // Otherwise, add the missing node.\n  if (!actual) {\n    return ideal.inDepBundle ? null : 'ADD'\n  }\n\n  // always ignore the root node\n  if (ideal.isRoot && actual.isRoot) {\n    return null\n  }\n\n  // if the versions don't match, it's a change no matter what\n  if (ideal.version !== actual.version) {\n    return 'CHANGE'\n  }\n\n  const binsExist = ideal.binPaths.every((path) => existsSync(path))\n\n  // top nodes, links, and git deps won't have integrity, but do have resolved\n  // if neither node has integrity, the bins exist, and either (a) neither\n  // node has a resolved value or (b) they both do and match, then we can\n  // leave this one alone since we already know the versions match due to\n  // the condition above.  The \"neither has resolved\" case (a) cannot be\n  // treated as a 'mark CHANGE and refetch', because shrinkwraps, bundles,\n  // and link deps may lack this information, and we don't want to try to\n  // go to the registry for something that isn't there.\n  const noIntegrity = !ideal.integrity && !actual.integrity\n  const noResolved = !ideal.resolved && !actual.resolved\n  const resolvedMatch = ideal.resolved && ideal.resolved === actual.resolved\n  if (noIntegrity && binsExist && (resolvedMatch || noResolved)) {\n    return null\n  }\n\n  // otherwise, verify that it's the same bits\n  // note that if ideal has integrity, and resolved doesn't, we treat\n  // that as a 'change', so that it gets re-fetched and locked down.\n  const integrityMismatch = !ideal.integrity || !actual.integrity ||\n    !ssri.parse(ideal.integrity).match(actual.integrity)\n  if (integrityMismatch || !binsExist) {\n    return 'CHANGE'\n  }\n\n  return null\n}\n\nconst allChildren = node => {\n  if (!node) {\n    return new Map()\n  }\n\n  // if the node is root, and also a link, then what we really\n  // want is to traverse the target's children\n  if (node.isRoot && node.isLink) {\n    return allChildren(node.target)\n  }\n\n  const kids = new Map()\n  for (const n of [node, ...node.fsChildren]) {\n    for (const kid of n.children.values()) {\n      kids.set(kid.path, kid)\n    }\n  }\n  return kids\n}\n\n// functions for the walk options when we traverse the trees\n// to create the diff tree\nconst getChildren = diff => {\n  const children = []\n  const {\n    actual,\n    ideal,\n    unchanged,\n    removed,\n    filterSet,\n    shrinkwrapInflated,\n  } = diff\n\n  // Note: we DON'T diff fsChildren themselves, because they are either\n  // included in the package contents, or part of some other project, and\n  // will never appear in legacy shrinkwraps anyway.  but we _do_ include the\n  // child nodes of fsChildren, because those are nodes that we are typically\n  // responsible for installing.\n  const actualKids = allChildren(actual)\n  const idealKids = allChildren(ideal)\n\n  if (ideal && ideal.hasShrinkwrap && !shrinkwrapInflated.has(ideal)) {\n    // Guaranteed to get a diff.leaves here, because we always\n    // be called with a proper Diff object when ideal has a shrinkwrap\n    // that has not been inflated.\n    diff.leaves.push(diff)\n    return children\n  }\n\n  const paths = new Set([...actualKids.keys(), ...idealKids.keys()])\n  for (const path of paths) {\n    const actual = actualKids.get(path)\n    const ideal = idealKids.get(path)\n    diffNode({\n      actual,\n      ideal,\n      children,\n      unchanged,\n      removed,\n      filterSet,\n      shrinkwrapInflated,\n    })\n  }\n\n  if (diff.leaves && !children.length) {\n    diff.leaves.push(diff)\n  }\n\n  return children\n}\n\nconst diffNode = ({\n  actual,\n  ideal,\n  children,\n  unchanged,\n  removed,\n  filterSet,\n  shrinkwrapInflated,\n}) => {\n  if (filterSet.size && !(filterSet.has(ideal) || filterSet.has(actual))) {\n    return\n  }\n\n  const action = getAction({actual, ideal})\n\n  // if it's a match, then get its children\n  // otherwise, this is the child diff node\n  if (action || (!shrinkwrapInflated.has(ideal) && ideal.hasShrinkwrap)) {\n    if (action === 'REMOVE') {\n      removed.push(actual)\n    }\n    children.push(new Diff({actual, ideal, filterSet, shrinkwrapInflated}))\n  } else {\n    unchanged.push(ideal)\n    // !*! Weird dirty hack warning !*!\n    //\n    // Bundled deps aren't loaded in the ideal tree, because we don't know\n    // what they are going to be without unpacking.  Swap them over now if\n    // the bundling node isn't changing, so we don't prune them later.\n    //\n    // It's a little bit dirty to be doing this here, since it means that\n    // diffing trees can mutate them, but otherwise we have to walk over\n    // all unchanging bundlers and correct the diff later, so it's more\n    // efficient to just fix it while we're passing through already.\n    //\n    // Note that moving over a bundled dep will break the links to other\n    // deps under this parent, which may have been transitively bundled.\n    // Breaking those links means that we'll no longer see the transitive\n    // dependency, meaning that it won't appear as bundled any longer!\n    // In order to not end up dropping transitively bundled deps, we have\n    // to get the list of nodes to move, then move them all at once, rather\n    // than moving them one at a time in the first loop.\n    const bd = ideal.package.bundleDependencies\n    if (actual && bd && bd.length) {\n      const bundledChildren = []\n      for (const node of actual.children.values()) {\n        if (node.inBundle) {\n          bundledChildren.push(node)\n        }\n      }\n      for (const node of bundledChildren) {\n        node.parent = ideal\n      }\n    }\n    children.push(...getChildren({\n      actual,\n      ideal,\n      unchanged,\n      removed,\n      filterSet,\n      shrinkwrapInflated,\n    }))\n  }\n}\n\n// set the parentage in the leave step so that we aren't attaching\n// child nodes only to remove them later.  also bubble up the unchanged\n// nodes so that we can move them out of staging in the reification step.\nconst leave = (diff, children) => {\n  children.forEach(kid => {\n    kid.parent = diff\n    diff.leaves.push(...kid.leaves)\n    diff.unchanged.push(...kid.unchanged)\n    diff.removed.push(...kid.removed)\n  })\n  diff.children = children\n  return diff\n}\n\nmodule.exports = Diff\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}