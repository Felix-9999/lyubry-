{"ast":null,"code":"// when an optional dep fails to install, we need to remove the branch of the\n// graph up to the first optionalDependencies, as well as any nodes that are\n// only required by other nodes in the set.\n//\n// This function finds the set of nodes that will need to be removed in that\n// case.\n//\n// Note that this is *only* going to work with trees where calcDepFlags\n// has been called, because we rely on the node.optional flag.\n\nconst gatherDepSet = require('./gather-dep-set.js');\nconst optionalSet = node => {\n  if (!node.optional) {\n    return new Set();\n  }\n\n  // start with the node, then walk up the dependency graph until we\n  // get to the boundaries that define the optional set.  since the\n  // node is optional, we know that all paths INTO this area of the\n  // graph are optional, but there may be non-optional dependencies\n  // WITHIN the area.\n  const set = new Set([node]);\n  for (const node of set) {\n    for (const edge of node.edgesIn) {\n      if (!edge.optional) {\n        set.add(edge.from);\n      }\n    }\n  }\n\n  // now that we've hit the boundary, gather the rest of the nodes in\n  // the optional section.  that's the set of dependencies that are only\n  // depended upon by other nodes within the set, or optional dependencies\n  // from outside the set.\n  return gatherDepSet(set, edge => !edge.optional);\n};\nmodule.exports = optionalSet;","map":{"version":3,"names":["gatherDepSet","require","optionalSet","node","optional","Set","set","edge","edgesIn","add","from","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/@npmcli/arborist/lib/optional-set.js"],"sourcesContent":["// when an optional dep fails to install, we need to remove the branch of the\n// graph up to the first optionalDependencies, as well as any nodes that are\n// only required by other nodes in the set.\n//\n// This function finds the set of nodes that will need to be removed in that\n// case.\n//\n// Note that this is *only* going to work with trees where calcDepFlags\n// has been called, because we rely on the node.optional flag.\n\nconst gatherDepSet = require('./gather-dep-set.js')\nconst optionalSet = node => {\n  if (!node.optional) {\n    return new Set()\n  }\n\n  // start with the node, then walk up the dependency graph until we\n  // get to the boundaries that define the optional set.  since the\n  // node is optional, we know that all paths INTO this area of the\n  // graph are optional, but there may be non-optional dependencies\n  // WITHIN the area.\n  const set = new Set([node])\n  for (const node of set) {\n    for (const edge of node.edgesIn) {\n      if (!edge.optional) {\n        set.add(edge.from)\n      }\n    }\n  }\n\n  // now that we've hit the boundary, gather the rest of the nodes in\n  // the optional section.  that's the set of dependencies that are only\n  // depended upon by other nodes within the set, or optional dependencies\n  // from outside the set.\n  return gatherDepSet(set, edge => !edge.optional)\n}\n\nmodule.exports = optionalSet\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,qBAAqB,CAAC;AACnD,MAAMC,WAAW,GAAGC,IAAI,IAAI;EAC1B,IAAI,CAACA,IAAI,CAACC,QAAQ,EAAE;IAClB,OAAO,IAAIC,GAAG,CAAC,CAAC;EAClB;;EAEA;EACA;EACA;EACA;EACA;EACA,MAAMC,GAAG,GAAG,IAAID,GAAG,CAAC,CAACF,IAAI,CAAC,CAAC;EAC3B,KAAK,MAAMA,IAAI,IAAIG,GAAG,EAAE;IACtB,KAAK,MAAMC,IAAI,IAAIJ,IAAI,CAACK,OAAO,EAAE;MAC/B,IAAI,CAACD,IAAI,CAACH,QAAQ,EAAE;QAClBE,GAAG,CAACG,GAAG,CAACF,IAAI,CAACG,IAAI,CAAC;MACpB;IACF;EACF;;EAEA;EACA;EACA;EACA;EACA,OAAOV,YAAY,CAACM,GAAG,EAAEC,IAAI,IAAI,CAACA,IAAI,CAACH,QAAQ,CAAC;AAClD,CAAC;AAEDO,MAAM,CAACC,OAAO,GAAGV,WAAW","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}