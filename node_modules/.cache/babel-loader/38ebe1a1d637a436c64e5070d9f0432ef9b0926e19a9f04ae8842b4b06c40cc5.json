{"ast":null,"code":"// On windows, create a .cmd file.\n// Read the #! in the file to see what it uses.  The vast majority\n// of the time, this will be either:\n// \"#!/usr/bin/env <prog> <args...>\"\n// or:\n// \"#!<prog> <args...>\"\n//\n// Write a binroot/pkg.bin + \".cmd\" file that has this line in it:\n// @<prog> <args...> %dp0%<target> %*\n\nconst {\n  promisify\n} = require('util');\nconst fs = require('fs');\nconst writeFile = promisify(fs.writeFile);\nconst readFile = promisify(fs.readFile);\nconst chmod = promisify(fs.chmod);\nconst stat = promisify(fs.stat);\nconst unlink = promisify(fs.unlink);\nconst {\n  dirname,\n  relative\n} = require('path');\nconst mkdir = require('mkdirp-infer-owner');\nconst toBatchSyntax = require('./lib/to-batch-syntax');\nconst shebangExpr = /^#\\!\\s*(?:\\/usr\\/bin\\/env)?\\s*([^ \\t]+=[^ \\t]+\\s+)*\\s*([^ \\t]+)(.*)$/;\nconst cmdShimIfExists = (from, to) => stat(from).then(() => cmdShim(from, to), () => {});\n\n// Try to unlink, but ignore errors.\n// Any problems will surface later.\nconst rm = path => unlink(path).catch(() => {});\nconst cmdShim = (from, to) => stat(from).then(() => cmdShim_(from, to));\nconst cmdShim_ = (from, to) => Promise.all([rm(to), rm(to + '.cmd'), rm(to + '.ps1')]).then(() => writeShim(from, to));\nconst writeShim = (from, to) =>\n// make a cmd file and a sh script\n// First, check if the bin is a #! of some sort.\n// If not, then assume it's something that'll be compiled, or some other\n// sort of script, and just call it directly.\nmkdir(dirname(to)).then(() => readFile(from, 'utf8')).then(data => {\n  const firstLine = data.trim().split(/\\r*\\n/)[0];\n  const shebang = firstLine.match(shebangExpr);\n  if (!shebang) return writeShim_(from, to);\n  const vars = shebang[1] || '';\n  const prog = shebang[2];\n  const args = shebang[3] || '';\n  return writeShim_(from, to, prog, args, vars);\n}, er => writeShim_(from, to));\nconst writeShim_ = (from, to, prog, args, variables) => {\n  let shTarget = relative(dirname(to), from);\n  let target = shTarget.split('/').join('\\\\');\n  let longProg;\n  let shProg = prog && prog.split('\\\\').join('/');\n  let shLongProg;\n  let pwshProg = shProg && `\"${shProg}$exe\"`;\n  let pwshLongProg;\n  shTarget = shTarget.split('\\\\').join('/');\n  args = args || '';\n  variables = variables || '';\n  if (!prog) {\n    prog = `\"%dp0%\\\\${target}\"`;\n    shProg = `\"$basedir/${shTarget}\"`;\n    pwshProg = shProg;\n    args = '';\n    target = '';\n    shTarget = '';\n  } else {\n    longProg = `\"%dp0%\\\\${prog}.exe\"`;\n    shLongProg = `\"$basedir/${prog}\"`;\n    pwshLongProg = `\"$basedir/${prog}$exe\"`;\n    target = `\"%dp0%\\\\${target}\"`;\n    shTarget = `\"$basedir/${shTarget}\"`;\n  }\n\n  // Subroutine trick to fix https://github.com/npm/cmd-shim/issues/10\n  // and https://github.com/npm/cli/issues/969\n  const head = '@ECHO off\\r\\n' + 'GOTO start\\r\\n' + ':find_dp0\\r\\n' + 'SET dp0=%~dp0\\r\\n' + 'EXIT /b\\r\\n' + ':start\\r\\n' + 'SETLOCAL\\r\\n' + 'CALL :find_dp0\\r\\n';\n  let cmd;\n  if (longProg) {\n    shLongProg = shLongProg.trim();\n    args = args.trim();\n    const variablesBatch = toBatchSyntax.convertToSetCommands(variables);\n    cmd = head + variablesBatch + '\\r\\n' + `IF EXIST ${longProg} (\\r\\n` + `  SET \"_prog=${longProg.replace(/(^\")|(\"$)/g, '')}\"\\r\\n` + ') ELSE (\\r\\n' + `  SET \"_prog=${prog.replace(/(^\")|(\"$)/g, '')}\"\\r\\n` + '  SET PATHEXT=%PATHEXT:;.JS;=;%\\r\\n' + ')\\r\\n' + '\\r\\n'\n    // prevent \"Terminate Batch Job? (Y/n)\" message\n    // https://github.com/npm/cli/issues/969#issuecomment-737496588\n    + 'endLocal & goto #_undefined_# 2>NUL || title %COMSPEC% & ' + `\"%_prog%\" ${args} ${target} %*\\r\\n`;\n  } else {\n    cmd = `${head}${prog} ${args} ${target} %*\\r\\n`;\n  }\n\n  // #!/bin/sh\n  // basedir=`dirname \"$0\"`\n  //\n  // case `uname` in\n  //     *CYGWIN*|*MINGW*|*MSYS*) basedir=`cygpath -w \"$basedir\"`;;\n  // esac\n  //\n  // if [ -x \"$basedir/node.exe\" ]; then\n  //   exec \"$basedir/node.exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" \"$@\"\n  // else\n  //   exec node \"$basedir/node_modules/npm/bin/npm-cli.js\" \"$@\"\n  // fi\n\n  let sh = \"#!/bin/sh\\n\";\n  sh = sh + `basedir=$(dirname \"$(echo \"$0\" | sed -e 's,\\\\\\\\,/,g')\")\\n` + '\\n' + 'case `uname` in\\n' + '    *CYGWIN*|*MINGW*|*MSYS*) basedir=`cygpath -w \"$basedir\"`;;\\n' + 'esac\\n' + '\\n';\n  if (shLongProg) {\n    sh = sh + `if [ -x ${shLongProg} ]; then\\n` + `  exec ${variables}${shLongProg} ${args} ${shTarget} \"$@\"\\n` + 'else \\n' + `  exec ${variables}${shProg} ${args} ${shTarget} \"$@\"\\n` + 'fi\\n';\n  } else {\n    sh = sh + `exec ${shProg} ${args} ${shTarget} \"$@\"\\n`;\n  }\n\n  // #!/usr/bin/env pwsh\n  // $basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\n  //\n  // $ret=0\n  // $exe = \"\"\n  // if ($PSVersionTable.PSVersion -lt \"6.0\" -or $IsWindows) {\n  //   # Fix case when both the Windows and Linux builds of Node\n  //   # are installed in the same directory\n  //   $exe = \".exe\"\n  // }\n  // if (Test-Path \"$basedir/node\") {\n  //   # Suport pipeline input\n  //   if ($MyInvocation.ExpectingInput) {\n  //     input | & \"$basedir/node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   } else {\n  //     & \"$basedir/node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   }\n  //   $ret=$LASTEXITCODE\n  // } else {\n  //   # Support pipeline input\n  //   if ($MyInvocation.ExpectingInput) {\n  //     $input | & \"node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   } else {\n  //     & \"node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   }\n  //   $ret=$LASTEXITCODE\n  // }\n  // exit $ret\n  let pwsh = '#!/usr/bin/env pwsh\\n' + '$basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\\n' + '\\n' + '$exe=\"\"\\n' + 'if ($PSVersionTable.PSVersion -lt \\\"6.0\\\" -or $IsWindows) {\\n' + '  # Fix case when both the Windows and Linux builds of Node\\n' + '  # are installed in the same directory\\n' + '  $exe=\".exe\"\\n' + '}\\n';\n  if (shLongProg) {\n    pwsh = pwsh + '$ret=0\\n' + `if (Test-Path ${pwshLongProg}) {\\n` + '  # Support pipeline input\\n' + '  if ($MyInvocation.ExpectingInput) {\\n' + `    $input | & ${pwshLongProg} ${args} ${shTarget} $args\\n` + '  } else {\\n' + `    & ${pwshLongProg} ${args} ${shTarget} $args\\n` + '  }\\n' + '  $ret=$LASTEXITCODE\\n' + '} else {\\n' + '  # Support pipeline input\\n' + '  if ($MyInvocation.ExpectingInput) {\\n' + `    $input | & ${pwshProg} ${args} ${shTarget} $args\\n` + '  } else {\\n' + `    & ${pwshProg} ${args} ${shTarget} $args\\n` + '  }\\n' + '  $ret=$LASTEXITCODE\\n' + '}\\n' + 'exit $ret\\n';\n  } else {\n    pwsh = pwsh + '# Support pipeline input\\n' + 'if ($MyInvocation.ExpectingInput) {\\n' + `  $input | & ${pwshProg} ${args} ${shTarget} $args\\n` + '} else {\\n' + `  & ${pwshProg} ${args} ${shTarget} $args\\n` + '}\\n' + 'exit $LASTEXITCODE\\n';\n  }\n  return Promise.all([writeFile(to + '.ps1', pwsh, 'utf8'), writeFile(to + '.cmd', cmd, 'utf8'), writeFile(to, sh, 'utf8')]).then(() => chmodShim(to));\n};\nconst chmodShim = to => Promise.all([chmod(to, 0o755), chmod(to + '.cmd', 0o755), chmod(to + '.ps1', 0o755)]);\nmodule.exports = cmdShim;\ncmdShim.ifExists = cmdShimIfExists;","map":{"version":3,"names":["promisify","require","fs","writeFile","readFile","chmod","stat","unlink","dirname","relative","mkdir","toBatchSyntax","shebangExpr","cmdShimIfExists","from","to","then","cmdShim","rm","path","catch","cmdShim_","Promise","all","writeShim","data","firstLine","trim","split","shebang","match","writeShim_","vars","prog","args","er","variables","shTarget","target","join","longProg","shProg","shLongProg","pwshProg","pwshLongProg","head","cmd","variablesBatch","convertToSetCommands","replace","sh","pwsh","chmodShim","module","exports","ifExists"],"sources":["C:/Users/Felo/node_modules/npm/node_modules/cmd-shim/index.js"],"sourcesContent":["// On windows, create a .cmd file.\n// Read the #! in the file to see what it uses.  The vast majority\n// of the time, this will be either:\n// \"#!/usr/bin/env <prog> <args...>\"\n// or:\n// \"#!<prog> <args...>\"\n//\n// Write a binroot/pkg.bin + \".cmd\" file that has this line in it:\n// @<prog> <args...> %dp0%<target> %*\n\nconst {promisify} = require('util')\nconst fs = require('fs')\nconst writeFile = promisify(fs.writeFile)\nconst readFile = promisify(fs.readFile)\nconst chmod = promisify(fs.chmod)\nconst stat = promisify(fs.stat)\nconst unlink = promisify(fs.unlink)\n\nconst {dirname, relative} = require('path')\nconst mkdir = require('mkdirp-infer-owner')\nconst toBatchSyntax = require('./lib/to-batch-syntax')\nconst shebangExpr = /^#\\!\\s*(?:\\/usr\\/bin\\/env)?\\s*([^ \\t]+=[^ \\t]+\\s+)*\\s*([^ \\t]+)(.*)$/\n\nconst cmdShimIfExists = (from, to) =>\n  stat(from).then(() => cmdShim(from, to), () => {})\n\n// Try to unlink, but ignore errors.\n// Any problems will surface later.\nconst rm = path => unlink(path).catch(() => {})\n\nconst cmdShim = (from, to) =>\n  stat(from).then(() => cmdShim_(from, to))\n\nconst cmdShim_ = (from, to) => Promise.all([\n  rm(to),\n  rm(to + '.cmd'),\n  rm(to + '.ps1'),\n]).then(() => writeShim(from, to))\n\nconst writeShim = (from, to) =>\n  // make a cmd file and a sh script\n  // First, check if the bin is a #! of some sort.\n  // If not, then assume it's something that'll be compiled, or some other\n  // sort of script, and just call it directly.\n  mkdir(dirname(to))\n    .then(() => readFile(from, 'utf8'))\n    .then(data => {\n      const firstLine = data.trim().split(/\\r*\\n/)[0]\n      const shebang = firstLine.match(shebangExpr)\n      if (!shebang) return writeShim_(from, to)\n      const vars = shebang[1] || ''\n      const prog = shebang[2]\n      const args = shebang[3] || ''\n      return writeShim_(from, to, prog, args, vars)\n    }, er => writeShim_(from, to))\n\n\nconst writeShim_ = (from, to, prog, args, variables) => {\n  let shTarget = relative(dirname(to), from)\n  let target = shTarget.split('/').join('\\\\')\n  let longProg\n  let shProg = prog && prog.split('\\\\').join('/')\n  let shLongProg\n  let pwshProg = shProg && `\"${shProg}$exe\"`\n  let pwshLongProg\n  shTarget = shTarget.split('\\\\').join('/')\n  args = args || ''\n  variables = variables || ''\n  if (!prog) {\n    prog = `\"%dp0%\\\\${target}\"`\n    shProg = `\"$basedir/${shTarget}\"`\n    pwshProg = shProg\n    args = ''\n    target = ''\n    shTarget = ''\n  } else {\n    longProg = `\"%dp0%\\\\${prog}.exe\"`\n    shLongProg = `\"$basedir/${prog}\"`\n    pwshLongProg = `\"$basedir/${prog}$exe\"`\n    target = `\"%dp0%\\\\${target}\"`\n    shTarget = `\"$basedir/${shTarget}\"`\n  }\n\n  // Subroutine trick to fix https://github.com/npm/cmd-shim/issues/10\n  // and https://github.com/npm/cli/issues/969\n  const head = '@ECHO off\\r\\n' +\n    'GOTO start\\r\\n' +\n    ':find_dp0\\r\\n' +\n    'SET dp0=%~dp0\\r\\n' +\n    'EXIT /b\\r\\n' +\n    ':start\\r\\n' +\n    'SETLOCAL\\r\\n' +\n    'CALL :find_dp0\\r\\n'\n\n  let cmd\n  if (longProg) {\n    shLongProg = shLongProg.trim();\n    args = args.trim();\n    const variablesBatch = toBatchSyntax.convertToSetCommands(variables)\n    cmd = head\n        + variablesBatch\n        + '\\r\\n'\n        + `IF EXIST ${longProg} (\\r\\n`\n        + `  SET \"_prog=${longProg.replace(/(^\")|(\"$)/g, '')}\"\\r\\n`\n        + ') ELSE (\\r\\n'\n        + `  SET \"_prog=${prog.replace(/(^\")|(\"$)/g, '')}\"\\r\\n`\n        + '  SET PATHEXT=%PATHEXT:;.JS;=;%\\r\\n'\n        + ')\\r\\n'\n        + '\\r\\n'\n        // prevent \"Terminate Batch Job? (Y/n)\" message\n        // https://github.com/npm/cli/issues/969#issuecomment-737496588\n        + 'endLocal & goto #_undefined_# 2>NUL || title %COMSPEC% & '\n        +  `\"%_prog%\" ${args} ${target} %*\\r\\n`\n  } else {\n    cmd = `${head}${prog} ${args} ${target} %*\\r\\n`\n  }\n\n  // #!/bin/sh\n  // basedir=`dirname \"$0\"`\n  //\n  // case `uname` in\n  //     *CYGWIN*|*MINGW*|*MSYS*) basedir=`cygpath -w \"$basedir\"`;;\n  // esac\n  //\n  // if [ -x \"$basedir/node.exe\" ]; then\n  //   exec \"$basedir/node.exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" \"$@\"\n  // else\n  //   exec node \"$basedir/node_modules/npm/bin/npm-cli.js\" \"$@\"\n  // fi\n\n  let sh = \"#!/bin/sh\\n\"\n\n  sh = sh\n      + `basedir=$(dirname \"$(echo \"$0\" | sed -e 's,\\\\\\\\,/,g')\")\\n`\n      + '\\n'\n      + 'case `uname` in\\n'\n      + '    *CYGWIN*|*MINGW*|*MSYS*) basedir=`cygpath -w \"$basedir\"`;;\\n'\n      + 'esac\\n'\n      + '\\n'\n\n  if (shLongProg) {\n    sh = sh\n       + `if [ -x ${shLongProg} ]; then\\n`\n       + `  exec ${variables}${shLongProg} ${args} ${shTarget} \"$@\"\\n`\n       + 'else \\n'\n       + `  exec ${variables}${shProg} ${args} ${shTarget} \"$@\"\\n`\n       + 'fi\\n'\n  } else {\n    sh = sh\n       + `exec ${shProg} ${args} ${shTarget} \"$@\"\\n`\n  }\n\n  // #!/usr/bin/env pwsh\n  // $basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\n  //\n  // $ret=0\n  // $exe = \"\"\n  // if ($PSVersionTable.PSVersion -lt \"6.0\" -or $IsWindows) {\n  //   # Fix case when both the Windows and Linux builds of Node\n  //   # are installed in the same directory\n  //   $exe = \".exe\"\n  // }\n  // if (Test-Path \"$basedir/node\") {\n  //   # Suport pipeline input\n  //   if ($MyInvocation.ExpectingInput) {\n  //     input | & \"$basedir/node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   } else {\n  //     & \"$basedir/node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   }\n  //   $ret=$LASTEXITCODE\n  // } else {\n  //   # Support pipeline input\n  //   if ($MyInvocation.ExpectingInput) {\n  //     $input | & \"node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   } else {\n  //     & \"node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   }\n  //   $ret=$LASTEXITCODE\n  // }\n  // exit $ret\n  let pwsh = '#!/usr/bin/env pwsh\\n'\n           + '$basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\\n'\n           + '\\n'\n           + '$exe=\"\"\\n'\n           + 'if ($PSVersionTable.PSVersion -lt \\\"6.0\\\" -or $IsWindows) {\\n'\n           + '  # Fix case when both the Windows and Linux builds of Node\\n'\n           + '  # are installed in the same directory\\n'\n           + '  $exe=\".exe\"\\n'\n           + '}\\n'\n  if (shLongProg) {\n    pwsh = pwsh\n         + '$ret=0\\n'\n         + `if (Test-Path ${pwshLongProg}) {\\n`\n         + '  # Support pipeline input\\n'\n         + '  if ($MyInvocation.ExpectingInput) {\\n'\n         + `    $input | & ${pwshLongProg} ${args} ${shTarget} $args\\n`\n         + '  } else {\\n'\n         + `    & ${pwshLongProg} ${args} ${shTarget} $args\\n`\n         + '  }\\n'\n         + '  $ret=$LASTEXITCODE\\n'\n         + '} else {\\n'\n         + '  # Support pipeline input\\n'\n         + '  if ($MyInvocation.ExpectingInput) {\\n'\n         + `    $input | & ${pwshProg} ${args} ${shTarget} $args\\n`\n         + '  } else {\\n'\n         + `    & ${pwshProg} ${args} ${shTarget} $args\\n`\n         + '  }\\n'\n         + '  $ret=$LASTEXITCODE\\n'\n         + '}\\n'\n         + 'exit $ret\\n'\n  } else {\n    pwsh = pwsh\n         + '# Support pipeline input\\n'\n         + 'if ($MyInvocation.ExpectingInput) {\\n'\n         + `  $input | & ${pwshProg} ${args} ${shTarget} $args\\n`\n         + '} else {\\n'\n         + `  & ${pwshProg} ${args} ${shTarget} $args\\n`\n         + '}\\n'\n         + 'exit $LASTEXITCODE\\n'\n  }\n\n  return Promise.all([\n    writeFile(to + '.ps1', pwsh, 'utf8'),\n    writeFile(to + '.cmd', cmd, 'utf8'),\n    writeFile(to, sh, 'utf8'),\n  ]).then(() => chmodShim(to))\n}\n\nconst chmodShim = to => Promise.all([\n  chmod(to, 0o755),\n  chmod(to + '.cmd', 0o755),\n  chmod(to + '.ps1', 0o755),\n])\n\nmodule.exports = cmdShim\ncmdShim.ifExists = cmdShimIfExists\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}