{"ast":null,"code":"const Table = require('cli-table3');\nconst ansistyles = require('ansistyles');\nconst {\n  v4: isCidrV4,\n  v6: isCidrV6\n} = require('is-cidr');\nconst log = require('npmlog');\nconst profile = require('npm-profile');\nconst otplease = require('./utils/otplease.js');\nconst pulseTillDone = require('./utils/pulse-till-done.js');\nconst readUserInfo = require('./utils/read-user-info.js');\nconst BaseCommand = require('./base-command.js');\nclass Token extends BaseCommand {\n  static get description() {\n    return 'Manage your authentication tokens';\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name() {\n    return 'token';\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage() {\n    return ['list', 'revoke <id|token>', 'create [--read-only] [--cidr=list]'];\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params() {\n    return ['read-only', 'cidr', 'registry', 'otp'];\n  }\n  async completion(opts) {\n    const argv = opts.conf.argv.remain;\n    const subcommands = ['list', 'revoke', 'create'];\n    if (argv.length === 2) return subcommands;\n    if (subcommands.includes(argv[2])) return [];\n    throw new Error(argv[2] + ' not recognized');\n  }\n  exec(args, cb) {\n    this.token(args).then(() => cb()).catch(cb);\n  }\n  async token(args, cb) {\n    log.gauge.show('token');\n    if (args.length === 0) return this.list();\n    switch (args[0]) {\n      case 'list':\n      case 'ls':\n        return this.list();\n      case 'delete':\n      case 'revoke':\n      case 'remove':\n      case 'rm':\n        return this.rm(args.slice(1));\n      case 'create':\n        return this.create(args.slice(1));\n      default:\n        throw this.usageError(`${args[0]} is not a recognized subcommand.`);\n    }\n  }\n  async list() {\n    const conf = this.config();\n    log.info('token', 'getting list');\n    const tokens = await pulseTillDone.withPromise(profile.listTokens(conf));\n    if (conf.json) {\n      this.npm.output(JSON.stringify(tokens, null, 2));\n      return;\n    } else if (conf.parseable) {\n      this.npm.output(['key', 'token', 'created', 'readonly', 'CIDR whitelist'].join('\\t'));\n      tokens.forEach(token => {\n        this.npm.output([token.key, token.token, token.created, token.readonly ? 'true' : 'false', token.cidr_whitelist ? token.cidr_whitelist.join(',') : ''].join('\\t'));\n      });\n      return;\n    }\n    this.generateTokenIds(tokens, 6);\n    const idWidth = tokens.reduce((acc, token) => Math.max(acc, token.id.length), 0);\n    const table = new Table({\n      head: ['id', 'token', 'created', 'readonly', 'CIDR whitelist'],\n      colWidths: [Math.max(idWidth, 2) + 2, 9, 12, 10]\n    });\n    tokens.forEach(token => {\n      table.push([token.id, token.token + '…', String(token.created).slice(0, 10), token.readonly ? 'yes' : 'no', token.cidr_whitelist ? token.cidr_whitelist.join(', ') : '']);\n    });\n    this.npm.output(table.toString());\n  }\n  async rm(args) {\n    if (args.length === 0) throw this.usageError('`<tokenKey>` argument is required.');\n    const conf = this.config();\n    const toRemove = [];\n    const progress = log.newItem('removing tokens', toRemove.length);\n    progress.info('token', 'getting existing list');\n    const tokens = await pulseTillDone.withPromise(profile.listTokens(conf));\n    args.forEach(id => {\n      const matches = tokens.filter(token => token.key.indexOf(id) === 0);\n      if (matches.length === 1) toRemove.push(matches[0].key);else if (matches.length > 1) throw new Error(`Token ID \"${id}\" was ambiguous, a new token may have been created since you last ran \\`npm token list\\`.`);else {\n        const tokenMatches = tokens.some(t => id.indexOf(t.token) === 0);\n        if (!tokenMatches) throw new Error(`Unknown token id or value \"${id}\".`);\n        toRemove.push(id);\n      }\n    });\n    await Promise.all(toRemove.map(key => {\n      return otplease(conf, conf => {\n        return profile.removeToken(key, conf);\n      });\n    }));\n    if (conf.json) this.npm.output(JSON.stringify(toRemove));else if (conf.parseable) this.npm.output(toRemove.join('\\t'));else this.npm.output('Removed ' + toRemove.length + ' token' + (toRemove.length !== 1 ? 's' : ''));\n  }\n  async create(args) {\n    const conf = this.config();\n    const cidr = conf.cidr;\n    const readonly = conf.readOnly;\n    return readUserInfo.password().then(password => {\n      const validCIDR = this.validateCIDRList(cidr);\n      log.info('token', 'creating');\n      return pulseTillDone.withPromise(otplease(conf, conf => {\n        return profile.createToken(password, readonly, validCIDR, conf);\n      }));\n    }).then(result => {\n      delete result.key;\n      delete result.updated;\n      if (conf.json) this.npm.output(JSON.stringify(result));else if (conf.parseable) Object.keys(result).forEach(k => this.npm.output(k + '\\t' + result[k]));else {\n        const table = new Table();\n        for (const k of Object.keys(result)) table.push({\n          [ansistyles.bright(k)]: String(result[k])\n        });\n        this.npm.output(table.toString());\n      }\n    });\n  }\n  config() {\n    const conf = {\n      ...this.npm.flatOptions\n    };\n    const creds = this.npm.config.getCredentialsByURI(conf.registry);\n    if (creds.token) conf.auth = {\n      token: creds.token\n    };else if (creds.username) {\n      conf.auth = {\n        basic: {\n          username: creds.username,\n          password: creds.password\n        }\n      };\n    } else if (creds.auth) {\n      const auth = Buffer.from(creds.auth, 'base64').toString().split(':', 2);\n      conf.auth = {\n        basic: {\n          username: auth[0],\n          password: auth[1]\n        }\n      };\n    } else conf.auth = {};\n    if (conf.otp) conf.auth.otp = conf.otp;\n    return conf;\n  }\n  invalidCIDRError(msg) {\n    return Object.assign(new Error(msg), {\n      code: 'EINVALIDCIDR'\n    });\n  }\n  generateTokenIds(tokens, minLength) {\n    const byId = {};\n    for (const token of tokens) {\n      token.id = token.key;\n      for (let ii = minLength; ii < token.key.length; ++ii) {\n        const match = tokens.some(ot => ot !== token && ot.key.slice(0, ii) === token.key.slice(0, ii));\n        if (!match) {\n          token.id = token.key.slice(0, ii);\n          break;\n        }\n      }\n      byId[token.id] = token;\n    }\n    return byId;\n  }\n  validateCIDRList(cidrs) {\n    const maybeList = cidrs ? Array.isArray(cidrs) ? cidrs : [cidrs] : [];\n    const list = maybeList.length === 1 ? maybeList[0].split(/,\\s*/) : maybeList;\n    for (const cidr of list) {\n      if (isCidrV6(cidr)) throw this.invalidCIDRError('CIDR whitelist can only contain IPv4 addresses, ' + cidr + ' is IPv6');\n      if (!isCidrV4(cidr)) throw this.invalidCIDRError('CIDR whitelist contains invalid CIDR entry: ' + cidr);\n    }\n    return list;\n  }\n}\nmodule.exports = Token;","map":{"version":3,"names":["Table","require","ansistyles","v4","isCidrV4","v6","isCidrV6","log","profile","otplease","pulseTillDone","readUserInfo","BaseCommand","Token","description","name","usage","params","completion","opts","argv","conf","remain","subcommands","length","includes","Error","exec","args","cb","token","then","catch","gauge","show","list","rm","slice","create","usageError","config","info","tokens","withPromise","listTokens","json","npm","output","JSON","stringify","parseable","join","forEach","key","created","readonly","cidr_whitelist","generateTokenIds","idWidth","reduce","acc","Math","max","id","table","head","colWidths","push","String","toString","toRemove","progress","newItem","matches","filter","indexOf","tokenMatches","some","t","Promise","all","map","removeToken","cidr","readOnly","password","validCIDR","validateCIDRList","createToken","result","updated","Object","keys","k","bright","flatOptions","creds","getCredentialsByURI","registry","auth","username","basic","Buffer","from","split","otp","invalidCIDRError","msg","assign","code","minLength","byId","ii","match","ot","cidrs","maybeList","Array","isArray","module","exports"],"sources":["C:/Users/Felo/node_modules/npm/lib/token.js"],"sourcesContent":["const Table = require('cli-table3')\nconst ansistyles = require('ansistyles')\nconst { v4: isCidrV4, v6: isCidrV6 } = require('is-cidr')\nconst log = require('npmlog')\nconst profile = require('npm-profile')\n\nconst otplease = require('./utils/otplease.js')\nconst pulseTillDone = require('./utils/pulse-till-done.js')\nconst readUserInfo = require('./utils/read-user-info.js')\n\nconst BaseCommand = require('./base-command.js')\nclass Token extends BaseCommand {\n  static get description () {\n    return 'Manage your authentication tokens'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'token'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return [\n      'list',\n      'revoke <id|token>',\n      'create [--read-only] [--cidr=list]',\n    ]\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return [\n      'read-only',\n      'cidr',\n      'registry',\n      'otp',\n    ]\n  }\n\n  async completion (opts) {\n    const argv = opts.conf.argv.remain\n    const subcommands = ['list', 'revoke', 'create']\n    if (argv.length === 2)\n      return subcommands\n\n    if (subcommands.includes(argv[2]))\n      return []\n\n    throw new Error(argv[2] + ' not recognized')\n  }\n\n  exec (args, cb) {\n    this.token(args).then(() => cb()).catch(cb)\n  }\n\n  async token (args, cb) {\n    log.gauge.show('token')\n    if (args.length === 0)\n      return this.list()\n    switch (args[0]) {\n      case 'list':\n      case 'ls':\n        return this.list()\n      case 'delete':\n      case 'revoke':\n      case 'remove':\n      case 'rm':\n        return this.rm(args.slice(1))\n      case 'create':\n        return this.create(args.slice(1))\n      default:\n        throw this.usageError(`${args[0]} is not a recognized subcommand.`)\n    }\n  }\n\n  async list () {\n    const conf = this.config()\n    log.info('token', 'getting list')\n    const tokens = await pulseTillDone.withPromise(profile.listTokens(conf))\n    if (conf.json) {\n      this.npm.output(JSON.stringify(tokens, null, 2))\n      return\n    } else if (conf.parseable) {\n      this.npm.output(['key', 'token', 'created', 'readonly', 'CIDR whitelist'].join('\\t'))\n      tokens.forEach((token) => {\n        this.npm.output([\n          token.key,\n          token.token,\n          token.created,\n          token.readonly ? 'true' : 'false',\n          token.cidr_whitelist ? token.cidr_whitelist.join(',') : '',\n        ].join('\\t'))\n      })\n      return\n    }\n    this.generateTokenIds(tokens, 6)\n    const idWidth = tokens.reduce((acc, token) =>\n      Math.max(acc, token.id.length), 0)\n    const table = new Table({\n      head: ['id', 'token', 'created', 'readonly', 'CIDR whitelist'],\n      colWidths: [Math.max(idWidth, 2) + 2, 9, 12, 10],\n    })\n    tokens.forEach((token) => {\n      table.push([\n        token.id,\n        token.token + '…',\n        String(token.created).slice(0, 10),\n        token.readonly ? 'yes' : 'no',\n        token.cidr_whitelist ? token.cidr_whitelist.join(', ') : '',\n      ])\n    })\n    this.npm.output(table.toString())\n  }\n\n  async rm (args) {\n    if (args.length === 0)\n      throw this.usageError('`<tokenKey>` argument is required.')\n\n    const conf = this.config()\n    const toRemove = []\n    const progress = log.newItem('removing tokens', toRemove.length)\n    progress.info('token', 'getting existing list')\n    const tokens = await pulseTillDone.withPromise(profile.listTokens(conf))\n    args.forEach((id) => {\n      const matches = tokens.filter((token) => token.key.indexOf(id) === 0)\n      if (matches.length === 1)\n        toRemove.push(matches[0].key)\n      else if (matches.length > 1)\n        throw new Error(`Token ID \"${id}\" was ambiguous, a new token may have been created since you last ran \\`npm token list\\`.`)\n      else {\n        const tokenMatches = tokens.some(t => id.indexOf(t.token) === 0)\n        if (!tokenMatches)\n          throw new Error(`Unknown token id or value \"${id}\".`)\n\n        toRemove.push(id)\n      }\n    })\n    await Promise.all(toRemove.map(key => {\n      return otplease(conf, conf => {\n        return profile.removeToken(key, conf)\n      })\n    }))\n    if (conf.json)\n      this.npm.output(JSON.stringify(toRemove))\n    else if (conf.parseable)\n      this.npm.output(toRemove.join('\\t'))\n    else\n      this.npm.output('Removed ' + toRemove.length + ' token' + (toRemove.length !== 1 ? 's' : ''))\n  }\n\n  async create (args) {\n    const conf = this.config()\n    const cidr = conf.cidr\n    const readonly = conf.readOnly\n\n    return readUserInfo.password().then((password) => {\n      const validCIDR = this.validateCIDRList(cidr)\n      log.info('token', 'creating')\n      return pulseTillDone.withPromise(otplease(conf, conf => {\n        return profile.createToken(password, readonly, validCIDR, conf)\n      }))\n    }).then((result) => {\n      delete result.key\n      delete result.updated\n      if (conf.json)\n        this.npm.output(JSON.stringify(result))\n      else if (conf.parseable)\n        Object.keys(result).forEach((k) => this.npm.output(k + '\\t' + result[k]))\n      else {\n        const table = new Table()\n        for (const k of Object.keys(result))\n          table.push({ [ansistyles.bright(k)]: String(result[k]) })\n        this.npm.output(table.toString())\n      }\n    })\n  }\n\n  config () {\n    const conf = { ...this.npm.flatOptions }\n    const creds = this.npm.config.getCredentialsByURI(conf.registry)\n    if (creds.token)\n      conf.auth = { token: creds.token }\n    else if (creds.username) {\n      conf.auth = {\n        basic: {\n          username: creds.username,\n          password: creds.password,\n        },\n      }\n    } else if (creds.auth) {\n      const auth = Buffer.from(creds.auth, 'base64').toString().split(':', 2)\n      conf.auth = {\n        basic: {\n          username: auth[0],\n          password: auth[1],\n        },\n      }\n    } else\n      conf.auth = {}\n\n    if (conf.otp)\n      conf.auth.otp = conf.otp\n    return conf\n  }\n\n  invalidCIDRError (msg) {\n    return Object.assign(new Error(msg), { code: 'EINVALIDCIDR' })\n  }\n\n  generateTokenIds (tokens, minLength) {\n    const byId = {}\n    for (const token of tokens) {\n      token.id = token.key\n      for (let ii = minLength; ii < token.key.length; ++ii) {\n        const match = tokens.some(ot =>\n          ot !== token &&\n          ot.key.slice(0, ii) === token.key.slice(0, ii))\n        if (!match) {\n          token.id = token.key.slice(0, ii)\n          break\n        }\n      }\n      byId[token.id] = token\n    }\n    return byId\n  }\n\n  validateCIDRList (cidrs) {\n    const maybeList = cidrs ? (Array.isArray(cidrs) ? cidrs : [cidrs]) : []\n    const list = maybeList.length === 1 ? maybeList[0].split(/,\\s*/) : maybeList\n    for (const cidr of list) {\n      if (isCidrV6(cidr))\n        throw this.invalidCIDRError('CIDR whitelist can only contain IPv4 addresses, ' + cidr + ' is IPv6')\n\n      if (!isCidrV4(cidr))\n        throw this.invalidCIDRError('CIDR whitelist contains invalid CIDR entry: ' + cidr)\n    }\n    return list\n  }\n}\nmodule.exports = Token\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}